import {
  SideBarModule
} from "./chunk-SSSCGJA6.js";
import {
  EnterpriseCoreModule
} from "./chunk-YLD6DBV6.js";
import {
  AgInputTextField,
  AgMenuItemComponent,
  AgMenuList,
  AgPromise,
  AgSelect,
  Autowired,
  Bean,
  BeanStub,
  Column,
  Component,
  CssClassApplier,
  DragAndDropService,
  DragSourceType,
  EventService,
  Events,
  KeyCode,
  ManagedFocusFeature,
  ModuleNames,
  ModuleRegistry,
  NumberSequence,
  Optional,
  PositionableFeature,
  PostConstruct,
  PreConstruct,
  PreDestroy,
  ProvidedColumnGroup,
  RefSelector,
  RowNode,
  TabGuardComp,
  TouchListener,
  VirtualList,
  VirtualListDragFeature,
  _
} from "./chunk-H2INHEN3.js";

// ../../node_modules/@ag-grid-enterprise/column-tool-panel/dist/esm/es6/columnToolPanel/primaryColsHeaderPanel.mjs
var __decorate = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
  else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var ExpandState;
(function(ExpandState2) {
  ExpandState2[ExpandState2["EXPANDED"] = 0] = "EXPANDED";
  ExpandState2[ExpandState2["COLLAPSED"] = 1] = "COLLAPSED";
  ExpandState2[ExpandState2["INDETERMINATE"] = 2] = "INDETERMINATE";
})(ExpandState || (ExpandState = {}));
var PrimaryColsHeaderPanel = class _PrimaryColsHeaderPanel extends Component {
  constructor() {
    super(_PrimaryColsHeaderPanel.TEMPLATE);
  }
  postConstruct() {
    this.createExpandIcons();
    this.addManagedListener(this.eExpand, "click", this.onExpandClicked.bind(this));
    this.addManagedListener(this.eExpand, "keydown", (e) => {
      if (e.key === KeyCode.SPACE) {
        e.preventDefault();
        this.onExpandClicked();
      }
    });
    this.addManagedListener(this.eSelect.getInputElement(), "click", this.onSelectClicked.bind(this));
    this.eFilterTextField.onValueChange(() => this.onFilterTextChanged());
    this.addManagedListener(this.eFilterTextField.getInputElement(), "keydown", this.onMiniFilterKeyDown.bind(this));
    this.addManagedListener(this.eventService, Events.EVENT_NEW_COLUMNS_LOADED, this.showOrHideOptions.bind(this));
    const translate = this.localeService.getLocaleTextFunc();
    this.eSelect.setInputAriaLabel(translate("ariaColumnSelectAll", "Toggle Select All Columns"));
    this.eFilterTextField.setInputAriaLabel(translate("ariaFilterColumnsInput", "Filter Columns Input"));
    this.activateTabIndex([this.eExpand]);
  }
  init(params) {
    this.params = params;
    if (this.columnModel.isReady()) {
      this.showOrHideOptions();
    }
  }
  createExpandIcons() {
    this.eExpand.appendChild(this.eExpandChecked = _.createIconNoSpan("columnSelectOpen", this.gridOptionsService));
    this.eExpand.appendChild(this.eExpandUnchecked = _.createIconNoSpan("columnSelectClosed", this.gridOptionsService));
    this.eExpand.appendChild(this.eExpandIndeterminate = _.createIconNoSpan("columnSelectIndeterminate", this.gridOptionsService));
    this.setExpandState(ExpandState.EXPANDED);
  }
  // we only show expand / collapse if we are showing columns
  showOrHideOptions() {
    const showFilter = !this.params.suppressColumnFilter;
    const showSelect = !this.params.suppressColumnSelectAll;
    const showExpand = !this.params.suppressColumnExpandAll;
    const groupsPresent = this.columnModel.isPrimaryColumnGroupsPresent();
    const translate = this.localeService.getLocaleTextFunc();
    this.eFilterTextField.setInputPlaceholder(translate("searchOoo", "Search..."));
    _.setDisplayed(this.eFilterTextField.getGui(), showFilter);
    _.setDisplayed(this.eSelect.getGui(), showSelect);
    _.setDisplayed(this.eExpand, showExpand && groupsPresent);
  }
  onFilterTextChanged() {
    if (!this.onFilterTextChangedDebounced) {
      this.onFilterTextChangedDebounced = _.debounce(() => {
        const filterText = this.eFilterTextField.getValue();
        this.dispatchEvent({ type: "filterChanged", filterText });
      }, _PrimaryColsHeaderPanel.DEBOUNCE_DELAY);
    }
    this.onFilterTextChangedDebounced();
  }
  onMiniFilterKeyDown(e) {
    if (e.key === KeyCode.ENTER) {
      setTimeout(() => this.onSelectClicked(), _PrimaryColsHeaderPanel.DEBOUNCE_DELAY);
    }
  }
  onSelectClicked() {
    this.dispatchEvent({ type: this.selectState ? "unselectAll" : "selectAll" });
  }
  onExpandClicked() {
    this.dispatchEvent({ type: this.expandState === ExpandState.EXPANDED ? "collapseAll" : "expandAll" });
  }
  setExpandState(state) {
    this.expandState = state;
    _.setDisplayed(this.eExpandChecked, this.expandState === ExpandState.EXPANDED);
    _.setDisplayed(this.eExpandUnchecked, this.expandState === ExpandState.COLLAPSED);
    _.setDisplayed(this.eExpandIndeterminate, this.expandState === ExpandState.INDETERMINATE);
  }
  setSelectionState(state) {
    this.selectState = state;
    this.eSelect.setValue(this.selectState);
  }
};
PrimaryColsHeaderPanel.DEBOUNCE_DELAY = 300;
PrimaryColsHeaderPanel.TEMPLATE = `<div class="ag-column-select-header" role="presentation">
            <div ref="eExpand" class="ag-column-select-header-icon"></div>
            <ag-checkbox ref="eSelect" class="ag-column-select-header-checkbox"></ag-checkbox>
            <ag-input-text-field class="ag-column-select-header-filter-wrapper" ref="eFilterTextField"></ag-input-text-field>
        </div>`;
__decorate([
  Autowired("columnModel")
], PrimaryColsHeaderPanel.prototype, "columnModel", void 0);
__decorate([
  RefSelector("eExpand")
], PrimaryColsHeaderPanel.prototype, "eExpand", void 0);
__decorate([
  RefSelector("eSelect")
], PrimaryColsHeaderPanel.prototype, "eSelect", void 0);
__decorate([
  RefSelector("eFilterTextField")
], PrimaryColsHeaderPanel.prototype, "eFilterTextField", void 0);
__decorate([
  PostConstruct
], PrimaryColsHeaderPanel.prototype, "postConstruct", null);

// ../../node_modules/@ag-grid-enterprise/column-tool-panel/dist/esm/es6/columnToolPanel/columnModelItem.mjs
var ColumnModelItem = class _ColumnModelItem {
  constructor(displayName, columnOrGroup, dept, group = false, expanded) {
    this.eventService = new EventService();
    this.displayName = displayName;
    this.dept = dept;
    this.group = group;
    if (group) {
      this.columnGroup = columnOrGroup;
      this.expanded = expanded;
      this.children = [];
    } else {
      this.column = columnOrGroup;
    }
  }
  isGroup() {
    return this.group;
  }
  getDisplayName() {
    return this.displayName;
  }
  getColumnGroup() {
    return this.columnGroup;
  }
  getColumn() {
    return this.column;
  }
  getDept() {
    return this.dept;
  }
  isExpanded() {
    return !!this.expanded;
  }
  getChildren() {
    return this.children;
  }
  isPassesFilter() {
    return this.passesFilter;
  }
  setExpanded(expanded) {
    if (expanded === this.expanded) {
      return;
    }
    this.expanded = expanded;
    this.eventService.dispatchEvent({ type: _ColumnModelItem.EVENT_EXPANDED_CHANGED });
  }
  setPassesFilter(passesFilter) {
    this.passesFilter = passesFilter;
  }
  addEventListener(eventType, listener) {
    this.eventService.addEventListener(eventType, listener);
  }
  removeEventListener(eventType, listener) {
    this.eventService.removeEventListener(eventType, listener);
  }
};
ColumnModelItem.EVENT_EXPANDED_CHANGED = "expandedChanged";

// ../../node_modules/@ag-grid-enterprise/column-tool-panel/dist/esm/es6/columnToolPanel/toolPanelContextMenu.mjs
var __decorate2 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
  else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var ToolPanelContextMenu = class extends Component {
  constructor(column, mouseEvent, parentEl) {
    super(
      /* html */
      `<div class="ag-menu"></div>`
    );
    this.column = column;
    this.mouseEvent = mouseEvent;
    this.parentEl = parentEl;
    this.displayName = null;
  }
  postConstruct() {
    this.initializeProperties(this.column);
    this.buildMenuItemMap();
    if (this.column instanceof Column) {
      this.displayName = this.columnModel.getDisplayNameForColumn(this.column, "columnToolPanel");
    } else {
      this.displayName = this.columnModel.getDisplayNameForProvidedColumnGroup(null, this.column, "columnToolPanel");
    }
    if (this.isActive()) {
      this.mouseEvent.preventDefault();
      this.displayContextMenu();
    }
  }
  initializeProperties(column) {
    if (column instanceof ProvidedColumnGroup) {
      this.columns = column.getLeafColumns();
    } else {
      this.columns = [column];
    }
    this.allowGrouping = this.columns.some((col) => col.isPrimary() && col.isAllowRowGroup());
    this.allowValues = this.columns.some((col) => col.isPrimary() && col.isAllowValue());
    this.allowPivoting = this.columnModel.isPivotMode() && this.columns.some((col) => col.isPrimary() && col.isAllowPivot());
  }
  buildMenuItemMap() {
    const localeTextFunc = this.localeService.getLocaleTextFunc();
    this.menuItemMap = /* @__PURE__ */ new Map();
    this.menuItemMap.set("rowGroup", {
      allowedFunction: (col) => col.isPrimary() && col.isAllowRowGroup(),
      activeFunction: (col) => col.isRowGroupActive(),
      activateLabel: () => `${localeTextFunc("groupBy", "Group by")} ${this.displayName}`,
      deactivateLabel: () => `${localeTextFunc("ungroupBy", "Un-Group by")} ${this.displayName}`,
      activateFunction: () => {
        const groupedColumns = this.columnModel.getRowGroupColumns();
        this.columnModel.setRowGroupColumns(this.addColumnsToList(groupedColumns), "toolPanelUi");
      },
      deActivateFunction: () => {
        const groupedColumns = this.columnModel.getRowGroupColumns();
        this.columnModel.setRowGroupColumns(this.removeColumnsFromList(groupedColumns), "toolPanelUi");
      },
      addIcon: "menuAddRowGroup",
      removeIcon: "menuRemoveRowGroup"
    });
    this.menuItemMap.set("value", {
      allowedFunction: (col) => col.isPrimary() && col.isAllowValue(),
      activeFunction: (col) => col.isValueActive(),
      activateLabel: () => localeTextFunc("addToValues", `Add ${this.displayName} to values`, [this.displayName]),
      deactivateLabel: () => localeTextFunc("removeFromValues", `Remove ${this.displayName} from values`, [this.displayName]),
      activateFunction: () => {
        const valueColumns = this.columnModel.getValueColumns();
        this.columnModel.setValueColumns(this.addColumnsToList(valueColumns), "toolPanelUi");
      },
      deActivateFunction: () => {
        const valueColumns = this.columnModel.getValueColumns();
        this.columnModel.setValueColumns(this.removeColumnsFromList(valueColumns), "toolPanelUi");
      },
      addIcon: "valuePanel",
      removeIcon: "valuePanel"
    });
    this.menuItemMap.set("pivot", {
      allowedFunction: (col) => this.columnModel.isPivotMode() && col.isPrimary() && col.isAllowPivot(),
      activeFunction: (col) => col.isPivotActive(),
      activateLabel: () => localeTextFunc("addToLabels", `Add ${this.displayName} to labels`, [this.displayName]),
      deactivateLabel: () => localeTextFunc("removeFromLabels", `Remove ${this.displayName} from labels`, [this.displayName]),
      activateFunction: () => {
        const pivotColumns = this.columnModel.getPivotColumns();
        this.columnModel.setPivotColumns(this.addColumnsToList(pivotColumns), "toolPanelUi");
      },
      deActivateFunction: () => {
        const pivotColumns = this.columnModel.getPivotColumns();
        this.columnModel.setPivotColumns(this.removeColumnsFromList(pivotColumns), "toolPanelUi");
      },
      addIcon: "pivotPanel",
      removeIcon: "pivotPanel"
    });
  }
  addColumnsToList(columnList) {
    return [...columnList].concat(this.columns.filter((col) => columnList.indexOf(col) === -1));
  }
  removeColumnsFromList(columnList) {
    return columnList.filter((col) => this.columns.indexOf(col) === -1);
  }
  displayContextMenu() {
    const eGui = this.getGui();
    const menuList = this.createBean(new AgMenuList());
    const menuItemsMapped = this.getMappedMenuItems();
    const localeTextFunc = this.localeService.getLocaleTextFunc();
    let hideFunc = () => {
    };
    eGui.appendChild(menuList.getGui());
    menuList.addMenuItems(menuItemsMapped);
    menuList.addManagedListener(menuList, AgMenuItemComponent.EVENT_MENU_ITEM_SELECTED, () => {
      this.parentEl.focus();
      hideFunc();
    });
    const addPopupRes = this.popupService.addPopup({
      modal: true,
      eChild: eGui,
      closeOnEsc: true,
      afterGuiAttached: () => this.focusService.focusInto(menuList.getGui()),
      ariaLabel: localeTextFunc("ariaLabelContextMenu", "Context Menu"),
      closedCallback: (e) => {
        if (e instanceof KeyboardEvent) {
          this.parentEl.focus();
        }
        this.destroyBean(menuList);
      }
    });
    if (addPopupRes) {
      hideFunc = addPopupRes.hideFunc;
    }
    this.popupService.positionPopupUnderMouseEvent({
      type: "columnContextMenu",
      mouseEvent: this.mouseEvent,
      ePopup: eGui
    });
  }
  isActive() {
    return this.allowGrouping || this.allowValues || this.allowPivoting;
  }
  getMappedMenuItems() {
    const ret = [];
    for (const val of this.menuItemMap.values()) {
      const isInactive = this.columns.some((col) => val.allowedFunction(col) && !val.activeFunction(col));
      const isActive = this.columns.some((col) => val.allowedFunction(col) && val.activeFunction(col));
      if (isInactive) {
        ret.push({
          name: val.activateLabel(this.displayName),
          icon: _.createIconNoSpan(val.addIcon, this.gridOptionsService, null),
          action: () => val.activateFunction()
        });
      }
      if (isActive) {
        ret.push({
          name: val.deactivateLabel(this.displayName),
          icon: _.createIconNoSpan(val.removeIcon, this.gridOptionsService, null),
          action: () => val.deActivateFunction()
        });
      }
    }
    return ret;
  }
};
__decorate2([
  Autowired("columnModel")
], ToolPanelContextMenu.prototype, "columnModel", void 0);
__decorate2([
  Autowired("popupService")
], ToolPanelContextMenu.prototype, "popupService", void 0);
__decorate2([
  Autowired("focusService")
], ToolPanelContextMenu.prototype, "focusService", void 0);
__decorate2([
  PostConstruct
], ToolPanelContextMenu.prototype, "postConstruct", null);

// ../../node_modules/@ag-grid-enterprise/column-tool-panel/dist/esm/es6/columnToolPanel/toolPanelColumnGroupComp.mjs
var __decorate3 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
  else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var ToolPanelColumnGroupComp = class _ToolPanelColumnGroupComp extends Component {
  constructor(modelItem, allowDragging, eventType, focusWrapper) {
    super();
    this.modelItem = modelItem;
    this.allowDragging = allowDragging;
    this.eventType = eventType;
    this.focusWrapper = focusWrapper;
    this.processingColumnStateChange = false;
    this.modelItem = modelItem;
    this.columnGroup = modelItem.getColumnGroup();
    this.columnDept = modelItem.getDept();
    this.displayName = modelItem.getDisplayName();
    this.allowDragging = allowDragging;
  }
  init() {
    this.setTemplate(_ToolPanelColumnGroupComp.TEMPLATE);
    this.eDragHandle = _.createIconNoSpan("columnDrag", this.gridOptionsService);
    this.eDragHandle.classList.add("ag-drag-handle", "ag-column-select-column-group-drag-handle");
    const checkboxGui = this.cbSelect.getGui();
    const checkboxInput = this.cbSelect.getInputElement();
    checkboxGui.insertAdjacentElement("afterend", this.eDragHandle);
    checkboxInput.setAttribute("tabindex", "-1");
    this.eLabel.innerHTML = this.displayName ? this.displayName : "";
    this.setupExpandContract();
    this.addCssClass("ag-column-select-indent-" + this.columnDept);
    this.addManagedListener(this.eventService, Events.EVENT_COLUMN_PIVOT_MODE_CHANGED, this.onColumnStateChanged.bind(this));
    this.addManagedListener(this.eLabel, "click", this.onLabelClicked.bind(this));
    this.addManagedListener(this.cbSelect, Events.EVENT_FIELD_VALUE_CHANGED, this.onCheckboxChanged.bind(this));
    this.addManagedListener(this.modelItem, ColumnModelItem.EVENT_EXPANDED_CHANGED, this.onExpandChanged.bind(this));
    this.addManagedListener(this.focusWrapper, "keydown", this.handleKeyDown.bind(this));
    this.addManagedListener(this.focusWrapper, "contextmenu", this.onContextMenu.bind(this));
    this.setOpenClosedIcons();
    this.setupDragging();
    this.onColumnStateChanged();
    this.addVisibilityListenersToAllChildren();
    this.refreshAriaExpanded();
    this.refreshAriaLabel();
    this.setupTooltip();
    const classes = CssClassApplier.getToolPanelClassesFromColDef(this.columnGroup.getColGroupDef(), this.gridOptionsService, null, this.columnGroup);
    classes.forEach((c) => this.addOrRemoveCssClass(c, true));
  }
  getColumns() {
    return this.columnGroup.getLeafColumns();
  }
  setupTooltip() {
    const colGroupDef = this.columnGroup.getColGroupDef();
    if (!colGroupDef) {
      return;
    }
    const refresh = () => {
      const newTooltipText = colGroupDef.headerTooltip;
      this.setTooltip(newTooltipText);
    };
    refresh();
    this.addManagedListener(this.eventService, Events.EVENT_NEW_COLUMNS_LOADED, refresh);
  }
  getTooltipParams() {
    const res = super.getTooltipParams();
    res.location = "columnToolPanelColumnGroup";
    return res;
  }
  handleKeyDown(e) {
    switch (e.key) {
      case KeyCode.LEFT:
        e.preventDefault();
        this.modelItem.setExpanded(false);
        break;
      case KeyCode.RIGHT:
        e.preventDefault();
        this.modelItem.setExpanded(true);
        break;
      case KeyCode.SPACE:
        e.preventDefault();
        if (this.isSelectable()) {
          this.onSelectAllChanged(!this.isSelected());
        }
        break;
    }
  }
  onContextMenu(e) {
    const { columnGroup, gridOptionsService } = this;
    if (gridOptionsService.is("functionsReadOnly")) {
      return;
    }
    const contextMenu = this.createBean(new ToolPanelContextMenu(columnGroup, e, this.focusWrapper));
    this.addDestroyFunc(() => {
      if (contextMenu.isAlive()) {
        this.destroyBean(contextMenu);
      }
    });
  }
  addVisibilityListenersToAllChildren() {
    this.columnGroup.getLeafColumns().forEach((column) => {
      this.addManagedListener(column, Column.EVENT_VISIBLE_CHANGED, this.onColumnStateChanged.bind(this));
      this.addManagedListener(column, Column.EVENT_VALUE_CHANGED, this.onColumnStateChanged.bind(this));
      this.addManagedListener(column, Column.EVENT_PIVOT_CHANGED, this.onColumnStateChanged.bind(this));
      this.addManagedListener(column, Column.EVENT_ROW_GROUP_CHANGED, this.onColumnStateChanged.bind(this));
    });
  }
  setupDragging() {
    if (!this.allowDragging) {
      _.setDisplayed(this.eDragHandle, false);
      return;
    }
    let hideColumnOnExit = !this.gridOptionsService.is("suppressDragLeaveHidesColumns");
    const dragSource = {
      type: DragSourceType.ToolPanel,
      eElement: this.eDragHandle,
      dragItemName: this.displayName,
      getDefaultIconName: () => hideColumnOnExit ? DragAndDropService.ICON_HIDE : DragAndDropService.ICON_NOT_ALLOWED,
      getDragItem: () => this.createDragItem(),
      onDragStarted: () => {
        hideColumnOnExit = !this.gridOptionsService.is("suppressDragLeaveHidesColumns");
        const event = {
          type: Events.EVENT_COLUMN_PANEL_ITEM_DRAG_START,
          column: this.columnGroup
        };
        this.eventService.dispatchEvent(event);
      },
      onDragStopped: () => {
        const event = {
          type: Events.EVENT_COLUMN_PANEL_ITEM_DRAG_END
        };
        this.eventService.dispatchEvent(event);
      },
      onGridEnter: (dragItem) => {
        if (hideColumnOnExit) {
          this.modelItemUtils.updateColumns({
            columns: this.columnGroup.getLeafColumns(),
            visibleState: dragItem === null || dragItem === void 0 ? void 0 : dragItem.visibleState,
            pivotState: dragItem === null || dragItem === void 0 ? void 0 : dragItem.pivotState,
            eventType: this.eventType
          });
        }
      },
      onGridExit: () => {
        if (hideColumnOnExit) {
          this.onChangeCommon(false);
        }
      }
    };
    this.dragAndDropService.addDragSource(dragSource, true);
    this.addDestroyFunc(() => this.dragAndDropService.removeDragSource(dragSource));
  }
  createDragItem() {
    const columns = this.columnGroup.getLeafColumns();
    const visibleState = {};
    const pivotState = {};
    columns.forEach((col) => {
      const colId = col.getId();
      visibleState[colId] = col.isVisible();
      pivotState[colId] = this.modelItemUtils.createPivotState(col);
    });
    return {
      columns,
      visibleState,
      pivotState
    };
  }
  setupExpandContract() {
    this.eGroupClosedIcon.appendChild(_.createIcon("columnSelectClosed", this.gridOptionsService, null));
    this.eGroupOpenedIcon.appendChild(_.createIcon("columnSelectOpen", this.gridOptionsService, null));
    this.addManagedListener(this.eGroupClosedIcon, "click", this.onExpandOrContractClicked.bind(this));
    this.addManagedListener(this.eGroupOpenedIcon, "click", this.onExpandOrContractClicked.bind(this));
    const touchListener = new TouchListener(this.eColumnGroupIcons, true);
    this.addManagedListener(touchListener, TouchListener.EVENT_TAP, this.onExpandOrContractClicked.bind(this));
    this.addDestroyFunc(touchListener.destroy.bind(touchListener));
  }
  onLabelClicked() {
    const nextState = !this.cbSelect.getValue();
    this.onChangeCommon(nextState);
  }
  onCheckboxChanged(event) {
    this.onChangeCommon(event.selected);
  }
  getVisibleLeafColumns() {
    const childColumns = [];
    const extractCols = (children) => {
      children.forEach((child) => {
        if (!child.isPassesFilter()) {
          return;
        }
        if (child.isGroup()) {
          extractCols(child.getChildren());
        } else {
          childColumns.push(child.getColumn());
        }
      });
    };
    extractCols(this.modelItem.getChildren());
    return childColumns;
  }
  onChangeCommon(nextState) {
    this.refreshAriaLabel();
    if (this.processingColumnStateChange) {
      return;
    }
    this.modelItemUtils.selectAllChildren(this.modelItem.getChildren(), nextState, this.eventType);
  }
  refreshAriaLabel() {
    const translate = this.localeService.getLocaleTextFunc();
    const columnLabel = translate("ariaColumnGroup", "Column Group");
    const checkboxValue = this.cbSelect.getValue();
    const state = checkboxValue === void 0 ? translate("ariaIndeterminate", "indeterminate") : checkboxValue ? translate("ariaVisible", "visible") : translate("ariaHidden", "hidden");
    const visibilityLabel = translate("ariaToggleVisibility", "Press SPACE to toggle visibility");
    _.setAriaLabel(this.focusWrapper, `${this.displayName} ${columnLabel}`);
    this.cbSelect.setInputAriaLabel(`${visibilityLabel} (${state})`);
    _.setAriaDescribedBy(this.focusWrapper, this.cbSelect.getInputElement().id);
  }
  onColumnStateChanged() {
    const selectedValue = this.workOutSelectedValue();
    const readOnlyValue = this.workOutReadOnlyValue();
    this.processingColumnStateChange = true;
    this.cbSelect.setValue(selectedValue);
    this.cbSelect.setReadOnly(readOnlyValue);
    this.addOrRemoveCssClass("ag-column-select-column-group-readonly", readOnlyValue);
    this.processingColumnStateChange = false;
  }
  workOutSelectedValue() {
    const pivotMode = this.columnModel.isPivotMode();
    const visibleLeafColumns = this.getVisibleLeafColumns();
    let checkedCount = 0;
    let uncheckedCount = 0;
    visibleLeafColumns.forEach((column) => {
      if (!pivotMode && column.getColDef().lockVisible) {
        return;
      }
      if (this.isColumnChecked(column, pivotMode)) {
        checkedCount++;
      } else {
        uncheckedCount++;
      }
    });
    if (checkedCount > 0 && uncheckedCount > 0) {
      return void 0;
    }
    return checkedCount > 0;
  }
  workOutReadOnlyValue() {
    const pivotMode = this.columnModel.isPivotMode();
    let colsThatCanAction = 0;
    this.columnGroup.getLeafColumns().forEach((col) => {
      if (pivotMode) {
        if (col.isAnyFunctionAllowed()) {
          colsThatCanAction++;
        }
      } else {
        if (!col.getColDef().lockVisible) {
          colsThatCanAction++;
        }
      }
    });
    return colsThatCanAction === 0;
  }
  isColumnChecked(column, pivotMode) {
    if (pivotMode) {
      const pivoted = column.isPivotActive();
      const grouped = column.isRowGroupActive();
      const aggregated = column.isValueActive();
      return pivoted || grouped || aggregated;
    }
    return column.isVisible();
  }
  onExpandOrContractClicked() {
    const oldState = this.modelItem.isExpanded();
    this.modelItem.setExpanded(!oldState);
  }
  onExpandChanged() {
    this.setOpenClosedIcons();
    this.refreshAriaExpanded();
  }
  setOpenClosedIcons() {
    const folderOpen = this.modelItem.isExpanded();
    _.setDisplayed(this.eGroupClosedIcon, !folderOpen);
    _.setDisplayed(this.eGroupOpenedIcon, folderOpen);
  }
  refreshAriaExpanded() {
    _.setAriaExpanded(this.focusWrapper, this.modelItem.isExpanded());
  }
  getDisplayName() {
    return this.displayName;
  }
  onSelectAllChanged(value) {
    const cbValue = this.cbSelect.getValue();
    const readOnly = this.cbSelect.isReadOnly();
    if (!readOnly && (value && !cbValue || !value && cbValue)) {
      this.cbSelect.toggle();
    }
  }
  isSelected() {
    return this.cbSelect.getValue();
  }
  isSelectable() {
    return !this.cbSelect.isReadOnly();
  }
  setSelected(selected) {
    this.cbSelect.setValue(selected, true);
  }
};
ToolPanelColumnGroupComp.TEMPLATE = `<div class="ag-column-select-column-group" aria-hidden="true">
            <span class="ag-column-group-icons" ref="eColumnGroupIcons" >
                <span class="ag-column-group-closed-icon" ref="eGroupClosedIcon"></span>
                <span class="ag-column-group-opened-icon" ref="eGroupOpenedIcon"></span>
            </span>
            <ag-checkbox ref="cbSelect" class="ag-column-select-checkbox"></ag-checkbox>
            <span class="ag-column-select-column-label" ref="eLabel"></span>
        </div>`;
__decorate3([
  Autowired("columnModel")
], ToolPanelColumnGroupComp.prototype, "columnModel", void 0);
__decorate3([
  Autowired("dragAndDropService")
], ToolPanelColumnGroupComp.prototype, "dragAndDropService", void 0);
__decorate3([
  Autowired("modelItemUtils")
], ToolPanelColumnGroupComp.prototype, "modelItemUtils", void 0);
__decorate3([
  RefSelector("cbSelect")
], ToolPanelColumnGroupComp.prototype, "cbSelect", void 0);
__decorate3([
  RefSelector("eLabel")
], ToolPanelColumnGroupComp.prototype, "eLabel", void 0);
__decorate3([
  RefSelector("eGroupOpenedIcon")
], ToolPanelColumnGroupComp.prototype, "eGroupOpenedIcon", void 0);
__decorate3([
  RefSelector("eGroupClosedIcon")
], ToolPanelColumnGroupComp.prototype, "eGroupClosedIcon", void 0);
__decorate3([
  RefSelector("eColumnGroupIcons")
], ToolPanelColumnGroupComp.prototype, "eColumnGroupIcons", void 0);
__decorate3([
  PostConstruct
], ToolPanelColumnGroupComp.prototype, "init", null);

// ../../node_modules/@ag-grid-enterprise/column-tool-panel/dist/esm/es6/columnToolPanel/primaryColsListPanelItemDragFeature.mjs
var __decorate4 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
  else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var PrimaryColsListPanelItemDragFeature = class extends BeanStub {
  constructor(comp, virtualList) {
    super();
    this.comp = comp;
    this.virtualList = virtualList;
  }
  postConstruct() {
    this.createManagedBean(new VirtualListDragFeature(this.comp, this.virtualList, {
      dragSourceType: DragSourceType.ToolPanel,
      listItemDragStartEvent: Events.EVENT_COLUMN_PANEL_ITEM_DRAG_START,
      listItemDragEndEvent: Events.EVENT_COLUMN_PANEL_ITEM_DRAG_END,
      eventSource: this.eventService,
      getCurrentDragValue: (listItemDragStartEvent) => this.getCurrentDragValue(listItemDragStartEvent),
      isMoveBlocked: (currentDragValue) => this.isMoveBlocked(currentDragValue),
      getNumRows: (comp) => comp.getDisplayedColsList().length,
      moveItem: (currentDragValue, lastHoveredListItem) => this.moveItem(currentDragValue, lastHoveredListItem)
    }));
  }
  getCurrentDragValue(listItemDragStartEvent) {
    return listItemDragStartEvent.column;
  }
  isMoveBlocked(currentDragValue) {
    const currentColumns = this.getCurrentColumns(currentDragValue);
    const hasNotMovable = currentColumns.find((col) => {
      const colDef = col.getColDef();
      return !!colDef.suppressMovable || !!colDef.lockPosition;
    });
    return !!hasNotMovable;
  }
  moveItem(currentDragValue, lastHoveredListItem) {
    const targetIndex = this.getTargetIndex(currentDragValue, lastHoveredListItem);
    const columnsToMove = this.getCurrentColumns(currentDragValue);
    if (targetIndex != null) {
      this.columnModel.moveColumns(columnsToMove, targetIndex, "toolPanelUi");
    }
  }
  getMoveDiff(currentDragValue, end) {
    const allColumns = this.columnModel.getAllGridColumns();
    const currentColumns = this.getCurrentColumns(currentDragValue);
    const currentColumn = currentColumns[0];
    const span = currentColumns.length;
    const currentIndex = allColumns.indexOf(currentColumn);
    if (currentIndex < end) {
      return span;
    }
    return 0;
  }
  getCurrentColumns(currentDragValue) {
    if (currentDragValue instanceof ProvidedColumnGroup) {
      return currentDragValue.getLeafColumns();
    }
    return [currentDragValue];
  }
  getTargetIndex(currentDragValue, lastHoveredListItem) {
    if (!lastHoveredListItem) {
      return null;
    }
    const columnItemComponent = lastHoveredListItem.component;
    let isBefore = lastHoveredListItem.position === "top";
    let targetColumn;
    if (columnItemComponent instanceof ToolPanelColumnGroupComp) {
      const columns = columnItemComponent.getColumns();
      targetColumn = columns[0];
      isBefore = true;
    } else {
      targetColumn = columnItemComponent.getColumn();
    }
    const movingCols = this.getCurrentColumns(currentDragValue);
    if (movingCols.indexOf(targetColumn) !== -1) {
      return null;
    }
    const targetColumnIndex = this.columnModel.getAllGridColumns().indexOf(targetColumn);
    const adjustedTarget = isBefore ? targetColumnIndex : targetColumnIndex + 1;
    const diff = this.getMoveDiff(currentDragValue, adjustedTarget);
    return adjustedTarget - diff;
  }
};
__decorate4([
  Autowired("columnModel")
], PrimaryColsListPanelItemDragFeature.prototype, "columnModel", void 0);
__decorate4([
  PostConstruct
], PrimaryColsListPanelItemDragFeature.prototype, "postConstruct", null);

// ../../node_modules/@ag-grid-enterprise/column-tool-panel/dist/esm/es6/columnToolPanel/toolPanelColumnComp.mjs
var __decorate5 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
  else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var ToolPanelColumnComp = class _ToolPanelColumnComp extends Component {
  constructor(modelItem, allowDragging, groupsExist, focusWrapper) {
    super();
    this.allowDragging = allowDragging;
    this.groupsExist = groupsExist;
    this.focusWrapper = focusWrapper;
    this.processingColumnStateChange = false;
    this.column = modelItem.getColumn();
    this.columnDept = modelItem.getDept();
    this.displayName = modelItem.getDisplayName();
  }
  init() {
    this.setTemplate(_ToolPanelColumnComp.TEMPLATE);
    this.eDragHandle = _.createIconNoSpan("columnDrag", this.gridOptionsService);
    this.eDragHandle.classList.add("ag-drag-handle", "ag-column-select-column-drag-handle");
    const checkboxGui = this.cbSelect.getGui();
    const checkboxInput = this.cbSelect.getInputElement();
    checkboxGui.insertAdjacentElement("afterend", this.eDragHandle);
    checkboxInput.setAttribute("tabindex", "-1");
    const displayNameSanitised = _.escapeString(this.displayName);
    this.eLabel.innerHTML = displayNameSanitised;
    const indent = this.columnDept;
    if (this.groupsExist) {
      this.addCssClass("ag-column-select-add-group-indent");
    }
    this.addCssClass(`ag-column-select-indent-${indent}`);
    this.setupDragging();
    this.addManagedListener(this.eventService, Events.EVENT_COLUMN_PIVOT_MODE_CHANGED, this.onColumnStateChanged.bind(this));
    this.addManagedListener(this.column, Column.EVENT_VALUE_CHANGED, this.onColumnStateChanged.bind(this));
    this.addManagedListener(this.column, Column.EVENT_PIVOT_CHANGED, this.onColumnStateChanged.bind(this));
    this.addManagedListener(this.column, Column.EVENT_ROW_GROUP_CHANGED, this.onColumnStateChanged.bind(this));
    this.addManagedListener(this.column, Column.EVENT_VISIBLE_CHANGED, this.onColumnStateChanged.bind(this));
    this.addManagedListener(this.focusWrapper, "keydown", this.handleKeyDown.bind(this));
    this.addManagedListener(this.focusWrapper, "contextmenu", this.onContextMenu.bind(this));
    this.addManagedPropertyListener("functionsReadOnly", this.onColumnStateChanged.bind(this));
    this.addManagedListener(this.cbSelect, Events.EVENT_FIELD_VALUE_CHANGED, this.onCheckboxChanged.bind(this));
    this.addManagedListener(this.eLabel, "click", this.onLabelClicked.bind(this));
    this.onColumnStateChanged();
    this.refreshAriaLabel();
    this.setupTooltip();
    const classes = CssClassApplier.getToolPanelClassesFromColDef(this.column.getColDef(), this.gridOptionsService, this.column, null);
    classes.forEach((c) => this.addOrRemoveCssClass(c, true));
  }
  getColumn() {
    return this.column;
  }
  setupTooltip() {
    const refresh = () => {
      const newTooltipText = this.column.getColDef().headerTooltip;
      this.setTooltip(newTooltipText);
    };
    refresh();
    this.addManagedListener(this.eventService, Events.EVENT_NEW_COLUMNS_LOADED, refresh);
  }
  getTooltipParams() {
    const res = super.getTooltipParams();
    res.location = "columnToolPanelColumn";
    res.colDef = this.column.getColDef();
    return res;
  }
  onContextMenu(e) {
    const { column, gridOptionsService } = this;
    if (gridOptionsService.is("functionsReadOnly")) {
      return;
    }
    const contextMenu = this.createBean(new ToolPanelContextMenu(column, e, this.focusWrapper));
    this.addDestroyFunc(() => {
      if (contextMenu.isAlive()) {
        this.destroyBean(contextMenu);
      }
    });
  }
  handleKeyDown(e) {
    if (e.key === KeyCode.SPACE) {
      e.preventDefault();
      if (this.isSelectable()) {
        this.onSelectAllChanged(!this.isSelected());
      }
    }
  }
  onLabelClicked() {
    if (this.gridOptionsService.is("functionsReadOnly")) {
      return;
    }
    const nextState = !this.cbSelect.getValue();
    this.onChangeCommon(nextState);
  }
  onCheckboxChanged(event) {
    this.onChangeCommon(event.selected);
  }
  onChangeCommon(nextState) {
    if (this.cbSelect.isReadOnly()) {
      return;
    }
    this.refreshAriaLabel();
    if (this.processingColumnStateChange) {
      return;
    }
    this.modelItemUtils.setColumn(this.column, nextState, "toolPanelUi");
  }
  refreshAriaLabel() {
    const translate = this.localeService.getLocaleTextFunc();
    const columnLabel = translate("ariaColumn", "Column");
    const state = this.cbSelect.getValue() ? translate("ariaVisible", "visible") : translate("ariaHidden", "hidden");
    const visibilityLabel = translate("ariaToggleVisibility", "Press SPACE to toggle visibility");
    _.setAriaLabel(this.focusWrapper, `${this.displayName} ${columnLabel}`);
    this.cbSelect.setInputAriaLabel(`${visibilityLabel} (${state})`);
    _.setAriaDescribedBy(this.focusWrapper, this.cbSelect.getInputElement().id);
  }
  setupDragging() {
    if (!this.allowDragging) {
      _.setDisplayed(this.eDragHandle, false);
      return;
    }
    let hideColumnOnExit = !this.gridOptionsService.is("suppressDragLeaveHidesColumns");
    const dragSource = {
      type: DragSourceType.ToolPanel,
      eElement: this.eDragHandle,
      dragItemName: this.displayName,
      getDefaultIconName: () => hideColumnOnExit ? DragAndDropService.ICON_HIDE : DragAndDropService.ICON_NOT_ALLOWED,
      getDragItem: () => this.createDragItem(),
      onDragStarted: () => {
        hideColumnOnExit = !this.gridOptionsService.is("suppressDragLeaveHidesColumns");
        const event = {
          type: Events.EVENT_COLUMN_PANEL_ITEM_DRAG_START,
          column: this.column
        };
        this.eventService.dispatchEvent(event);
      },
      onDragStopped: () => {
        const event = {
          type: Events.EVENT_COLUMN_PANEL_ITEM_DRAG_END
        };
        this.eventService.dispatchEvent(event);
      },
      onGridEnter: (dragItem) => {
        if (hideColumnOnExit) {
          this.modelItemUtils.updateColumns({
            columns: [this.column],
            visibleState: dragItem === null || dragItem === void 0 ? void 0 : dragItem.visibleState,
            pivotState: dragItem === null || dragItem === void 0 ? void 0 : dragItem.pivotState,
            eventType: "toolPanelUi"
          });
        }
      },
      onGridExit: () => {
        if (hideColumnOnExit) {
          this.onChangeCommon(false);
        }
      }
    };
    this.dragAndDropService.addDragSource(dragSource, true);
    this.addDestroyFunc(() => this.dragAndDropService.removeDragSource(dragSource));
  }
  createDragItem() {
    const colId = this.column.getColId();
    const visibleState = { [colId]: this.column.isVisible() };
    const pivotState = { [colId]: this.modelItemUtils.createPivotState(this.column) };
    return {
      columns: [this.column],
      visibleState,
      pivotState
    };
  }
  onColumnStateChanged() {
    this.processingColumnStateChange = true;
    const isPivotMode = this.columnModel.isPivotMode();
    if (isPivotMode) {
      const anyFunctionActive = this.column.isAnyFunctionActive();
      this.cbSelect.setValue(anyFunctionActive);
    } else {
      this.cbSelect.setValue(this.column.isVisible());
    }
    let canBeToggled = true;
    let canBeDragged = true;
    if (isPivotMode) {
      const functionsReadOnly = this.gridOptionsService.is("functionsReadOnly");
      const noFunctionsAllowed = !this.column.isAnyFunctionAllowed();
      canBeToggled = !functionsReadOnly && !noFunctionsAllowed;
      canBeDragged = canBeToggled;
    } else {
      const { enableRowGroup, enableValue, lockPosition, suppressMovable, lockVisible } = this.column.getColDef();
      const forceDraggable = !!enableRowGroup || !!enableValue;
      const disableDraggable = !!lockPosition || !!suppressMovable;
      canBeToggled = !lockVisible;
      canBeDragged = forceDraggable || !disableDraggable;
    }
    this.cbSelect.setReadOnly(!canBeToggled);
    this.eDragHandle.classList.toggle("ag-column-select-column-readonly", !canBeDragged);
    this.addOrRemoveCssClass("ag-column-select-column-readonly", !canBeDragged && !canBeToggled);
    const checkboxPassive = isPivotMode && this.gridOptionsService.is("functionsPassive");
    this.cbSelect.setPassive(checkboxPassive);
    this.processingColumnStateChange = false;
  }
  getDisplayName() {
    return this.displayName;
  }
  onSelectAllChanged(value) {
    if (value !== this.cbSelect.getValue()) {
      if (!this.cbSelect.isReadOnly()) {
        this.cbSelect.toggle();
      }
    }
  }
  isSelected() {
    return this.cbSelect.getValue();
  }
  isSelectable() {
    return !this.cbSelect.isReadOnly();
  }
  isExpandable() {
    return false;
  }
  setExpanded(value) {
    console.warn("AG Grid: can not expand a column item that does not represent a column group header");
  }
};
ToolPanelColumnComp.TEMPLATE = `<div class="ag-column-select-column" aria-hidden="true">
            <ag-checkbox ref="cbSelect" class="ag-column-select-checkbox"></ag-checkbox>
            <span class="ag-column-select-column-label" ref="eLabel"></span>
        </div>`;
__decorate5([
  Autowired("columnModel")
], ToolPanelColumnComp.prototype, "columnModel", void 0);
__decorate5([
  Autowired("dragAndDropService")
], ToolPanelColumnComp.prototype, "dragAndDropService", void 0);
__decorate5([
  Autowired("modelItemUtils")
], ToolPanelColumnComp.prototype, "modelItemUtils", void 0);
__decorate5([
  RefSelector("eLabel")
], ToolPanelColumnComp.prototype, "eLabel", void 0);
__decorate5([
  RefSelector("cbSelect")
], ToolPanelColumnComp.prototype, "cbSelect", void 0);
__decorate5([
  PostConstruct
], ToolPanelColumnComp.prototype, "init", null);

// ../../node_modules/@ag-grid-enterprise/column-tool-panel/dist/esm/es6/columnToolPanel/primaryColsListPanel.mjs
var __decorate6 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
  else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var UIColumnModel = class {
  constructor(items) {
    this.items = items;
  }
  getRowCount() {
    return this.items.length;
  }
  getRow(index) {
    return this.items[index];
  }
};
var PRIMARY_COLS_LIST_PANEL_CLASS = "ag-column-select-list";
var PrimaryColsListPanel = class _PrimaryColsListPanel extends Component {
  constructor() {
    super(_PrimaryColsListPanel.TEMPLATE);
    this.destroyColumnItemFuncs = [];
  }
  destroyColumnTree() {
    this.allColsTree = [];
    this.destroyColumnItemFuncs.forEach((f) => f());
    this.destroyColumnItemFuncs = [];
  }
  init(params, allowDragging, eventType) {
    this.params = params;
    this.allowDragging = allowDragging;
    this.eventType = eventType;
    if (!this.params.suppressSyncLayoutWithGrid) {
      this.addManagedListener(this.eventService, Events.EVENT_COLUMN_MOVED, this.onColumnsChanged.bind(this));
    }
    this.addManagedListener(this.eventService, Events.EVENT_NEW_COLUMNS_LOADED, this.onColumnsChanged.bind(this));
    const eventsImpactingCheckedState = [
      Events.EVENT_COLUMN_PIVOT_CHANGED,
      Events.EVENT_COLUMN_PIVOT_MODE_CHANGED,
      Events.EVENT_COLUMN_ROW_GROUP_CHANGED,
      Events.EVENT_COLUMN_VALUE_CHANGED,
      Events.EVENT_COLUMN_VISIBLE,
      Events.EVENT_NEW_COLUMNS_LOADED
    ];
    eventsImpactingCheckedState.forEach((event) => {
      this.addManagedListener(this.eventService, event, this.fireSelectionChangedEvent.bind(this));
    });
    this.expandGroupsByDefault = !this.params.contractColumnSelection;
    const translate = this.localeService.getLocaleTextFunc();
    const columnListName = translate("ariaColumnList", "Column List");
    this.virtualList = this.createManagedBean(new VirtualList({
      cssIdentifier: "column-select",
      ariaRole: "tree",
      listName: columnListName
    }));
    this.appendChild(this.virtualList.getGui());
    this.virtualList.setComponentCreator((item, listItemElement) => {
      _.setAriaLevel(listItemElement, item.getDept() + 1);
      return this.createComponentFromItem(item, listItemElement);
    });
    if (this.columnModel.isReady()) {
      this.onColumnsChanged();
    }
    if (!params.suppressColumnMove && !this.gridOptionsService.is("suppressMovableColumns")) {
      this.createManagedBean(new PrimaryColsListPanelItemDragFeature(this, this.virtualList));
    }
  }
  createComponentFromItem(item, listItemElement) {
    if (item.isGroup()) {
      const renderedGroup = new ToolPanelColumnGroupComp(item, this.allowDragging, this.eventType, listItemElement);
      this.getContext().createBean(renderedGroup);
      return renderedGroup;
    }
    const columnComp = new ToolPanelColumnComp(item, this.allowDragging, this.groupsExist, listItemElement);
    this.getContext().createBean(columnComp);
    return columnComp;
  }
  onColumnsChanged() {
    const expandedStates = this.getExpandedStates();
    const pivotModeActive = this.columnModel.isPivotMode();
    const shouldSyncColumnLayoutWithGrid = !this.params.suppressSyncLayoutWithGrid && !pivotModeActive;
    if (shouldSyncColumnLayoutWithGrid) {
      this.buildTreeFromWhatGridIsDisplaying();
    } else {
      this.buildTreeFromProvidedColumnDefs();
    }
    this.setExpandedStates(expandedStates);
    this.markFilteredColumns();
    this.flattenAndFilterModel();
  }
  getDisplayedColsList() {
    return this.displayedColsList;
  }
  getExpandedStates() {
    if (!this.allColsTree) {
      return {};
    }
    const res = {};
    this.forEachItem((item) => {
      if (!item.isGroup()) {
        return;
      }
      const colGroup = item.getColumnGroup();
      if (colGroup) {
        res[colGroup.getId()] = item.isExpanded();
      }
    });
    return res;
  }
  setExpandedStates(states) {
    if (!this.allColsTree) {
      return;
    }
    this.forEachItem((item) => {
      if (!item.isGroup()) {
        return;
      }
      const colGroup = item.getColumnGroup();
      if (colGroup) {
        const expanded = states[colGroup.getId()];
        const groupExistedLastTime = expanded != null;
        if (groupExistedLastTime) {
          item.setExpanded(expanded);
        }
      }
    });
  }
  buildTreeFromWhatGridIsDisplaying() {
    this.colDefService.syncLayoutWithGrid(this.setColumnLayout.bind(this));
  }
  setColumnLayout(colDefs) {
    const columnTree = this.colDefService.createColumnTree(colDefs);
    this.buildListModel(columnTree);
    this.groupsExist = colDefs.some((colDef) => {
      return colDef && typeof colDef.children !== "undefined";
    });
    this.markFilteredColumns();
    this.flattenAndFilterModel();
  }
  buildTreeFromProvidedColumnDefs() {
    this.buildListModel(this.columnModel.getPrimaryColumnTree());
    this.groupsExist = this.columnModel.isPrimaryColumnGroupsPresent();
  }
  buildListModel(columnTree) {
    const columnExpandedListener = this.onColumnExpanded.bind(this);
    const addListeners = (item) => {
      item.addEventListener(ColumnModelItem.EVENT_EXPANDED_CHANGED, columnExpandedListener);
      const removeFunc = item.removeEventListener.bind(item, ColumnModelItem.EVENT_EXPANDED_CHANGED, columnExpandedListener);
      this.destroyColumnItemFuncs.push(removeFunc);
    };
    const recursivelyBuild = (tree, dept, parentList) => {
      tree.forEach((child) => {
        if (child instanceof ProvidedColumnGroup) {
          createGroupItem(child, dept, parentList);
        } else {
          createColumnItem(child, dept, parentList);
        }
      });
    };
    const createGroupItem = (columnGroup, dept, parentList) => {
      const columnGroupDef = columnGroup.getColGroupDef();
      const skipThisGroup = columnGroupDef && columnGroupDef.suppressColumnsToolPanel;
      if (skipThisGroup) {
        return;
      }
      if (columnGroup.isPadding()) {
        recursivelyBuild(columnGroup.getChildren(), dept, parentList);
        return;
      }
      const displayName = this.columnModel.getDisplayNameForProvidedColumnGroup(null, columnGroup, "columnToolPanel");
      const item = new ColumnModelItem(displayName, columnGroup, dept, true, this.expandGroupsByDefault);
      parentList.push(item);
      addListeners(item);
      recursivelyBuild(columnGroup.getChildren(), dept + 1, item.getChildren());
    };
    const createColumnItem = (column, dept, parentList) => {
      const skipThisColumn = column.getColDef() && column.getColDef().suppressColumnsToolPanel;
      if (skipThisColumn) {
        return;
      }
      const displayName = this.columnModel.getDisplayNameForColumn(column, "columnToolPanel");
      parentList.push(new ColumnModelItem(displayName, column, dept));
    };
    this.destroyColumnTree();
    recursivelyBuild(columnTree, 0, this.allColsTree);
  }
  onColumnExpanded() {
    this.flattenAndFilterModel();
  }
  flattenAndFilterModel() {
    this.displayedColsList = [];
    const recursiveFunc = (item) => {
      if (!item.isPassesFilter()) {
        return;
      }
      this.displayedColsList.push(item);
      if (item.isGroup() && item.isExpanded()) {
        item.getChildren().forEach(recursiveFunc);
      }
    };
    this.allColsTree.forEach(recursiveFunc);
    this.virtualList.setModel(new UIColumnModel(this.displayedColsList));
    const focusedRow = this.virtualList.getLastFocusedRow();
    this.virtualList.refresh();
    if (focusedRow != null) {
      this.focusRowIfAlive(focusedRow);
    }
    this.notifyListeners();
  }
  focusRowIfAlive(rowIndex) {
    window.setTimeout(() => {
      if (this.isAlive()) {
        this.virtualList.focusRow(rowIndex);
      }
    }, 0);
  }
  forEachItem(callback) {
    const recursiveFunc = (items) => {
      items.forEach((item) => {
        callback(item);
        if (item.isGroup()) {
          recursiveFunc(item.getChildren());
        }
      });
    };
    recursiveFunc(this.allColsTree);
  }
  doSetExpandedAll(value) {
    this.forEachItem((item) => {
      if (item.isGroup()) {
        item.setExpanded(value);
      }
    });
  }
  setGroupsExpanded(expand, groupIds) {
    if (!groupIds) {
      this.doSetExpandedAll(expand);
      return;
    }
    const expandedGroupIds = [];
    this.forEachItem((item) => {
      if (!item.isGroup()) {
        return;
      }
      const groupId = item.getColumnGroup().getId();
      if (groupIds.indexOf(groupId) >= 0) {
        item.setExpanded(expand);
        expandedGroupIds.push(groupId);
      }
    });
    const unrecognisedGroupIds = groupIds.filter((groupId) => !_.includes(expandedGroupIds, groupId));
    if (unrecognisedGroupIds.length > 0) {
      console.warn("AG Grid: unable to find group(s) for supplied groupIds:", unrecognisedGroupIds);
    }
  }
  getExpandState() {
    let expandedCount = 0;
    let notExpandedCount = 0;
    this.forEachItem((item) => {
      if (!item.isGroup()) {
        return;
      }
      if (item.isExpanded()) {
        expandedCount++;
      } else {
        notExpandedCount++;
      }
    });
    if (expandedCount > 0 && notExpandedCount > 0) {
      return ExpandState.INDETERMINATE;
    }
    if (notExpandedCount > 0) {
      return ExpandState.COLLAPSED;
    }
    return ExpandState.EXPANDED;
  }
  doSetSelectedAll(selectAllChecked) {
    this.modelItemUtils.selectAllChildren(this.allColsTree, selectAllChecked, this.eventType);
  }
  getSelectionState() {
    let checkedCount = 0;
    let uncheckedCount = 0;
    const pivotMode = this.columnModel.isPivotMode();
    this.forEachItem((item) => {
      if (item.isGroup()) {
        return;
      }
      if (!item.isPassesFilter()) {
        return;
      }
      const column = item.getColumn();
      const colDef = column.getColDef();
      let checked;
      if (pivotMode) {
        const noPivotModeOptionsAllowed = !column.isAllowPivot() && !column.isAllowRowGroup() && !column.isAllowValue();
        if (noPivotModeOptionsAllowed) {
          return;
        }
        checked = column.isValueActive() || column.isPivotActive() || column.isRowGroupActive();
      } else {
        if (colDef.lockVisible) {
          return;
        }
        checked = column.isVisible();
      }
      checked ? checkedCount++ : uncheckedCount++;
    });
    if (checkedCount > 0 && uncheckedCount > 0) {
      return void 0;
    }
    return !(checkedCount === 0 || uncheckedCount > 0);
  }
  setFilterText(filterText) {
    this.filterText = _.exists(filterText) ? filterText.toLowerCase() : null;
    this.markFilteredColumns();
    this.flattenAndFilterModel();
  }
  markFilteredColumns() {
    const passesFilter = (item) => {
      if (!_.exists(this.filterText)) {
        return true;
      }
      const displayName = item.getDisplayName();
      return displayName == null || displayName.toLowerCase().indexOf(this.filterText) !== -1;
    };
    const recursivelyCheckFilter = (item, parentPasses) => {
      let atLeastOneChildPassed = false;
      if (item.isGroup()) {
        const groupPasses = passesFilter(item);
        item.getChildren().forEach((child) => {
          const childPasses = recursivelyCheckFilter(child, groupPasses || parentPasses);
          if (childPasses) {
            atLeastOneChildPassed = childPasses;
          }
        });
      }
      const filterPasses = parentPasses || atLeastOneChildPassed ? true : passesFilter(item);
      item.setPassesFilter(filterPasses);
      return filterPasses;
    };
    this.allColsTree.forEach((item) => recursivelyCheckFilter(item, false));
  }
  notifyListeners() {
    this.fireGroupExpandedEvent();
    this.fireSelectionChangedEvent();
  }
  fireGroupExpandedEvent() {
    const expandState = this.getExpandState();
    this.dispatchEvent({ type: "groupExpanded", state: expandState });
  }
  fireSelectionChangedEvent() {
    const selectionState = this.getSelectionState();
    this.dispatchEvent({ type: "selectionChanged", state: selectionState });
  }
};
PrimaryColsListPanel.TEMPLATE = `<div class="${PRIMARY_COLS_LIST_PANEL_CLASS}" role="presentation"></div>`;
__decorate6([
  Autowired("columnModel")
], PrimaryColsListPanel.prototype, "columnModel", void 0);
__decorate6([
  Autowired("toolPanelColDefService")
], PrimaryColsListPanel.prototype, "colDefService", void 0);
__decorate6([
  Autowired("modelItemUtils")
], PrimaryColsListPanel.prototype, "modelItemUtils", void 0);
__decorate6([
  PreDestroy
], PrimaryColsListPanel.prototype, "destroyColumnTree", null);

// ../../node_modules/@ag-grid-enterprise/column-tool-panel/dist/esm/es6/columnToolPanel/pivotModePanel.mjs
var __decorate7 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
  else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var PivotModePanel = class extends Component {
  createTemplate() {
    return (
      /* html */
      `<div class="ag-pivot-mode-panel">
                <ag-toggle-button ref="cbPivotMode" class="ag-pivot-mode-select"></ag-toggle-button>
            </div>`
    );
  }
  init() {
    this.setTemplate(this.createTemplate());
    this.cbPivotMode.setValue(this.columnModel.isPivotMode());
    const localeTextFunc = this.localeService.getLocaleTextFunc();
    this.cbPivotMode.setLabel(localeTextFunc("pivotMode", "Pivot Mode"));
    this.addManagedListener(this.cbPivotMode, Events.EVENT_FIELD_VALUE_CHANGED, this.onBtPivotMode.bind(this));
    this.addManagedListener(this.eventService, Events.EVENT_NEW_COLUMNS_LOADED, this.onPivotModeChanged.bind(this));
    this.addManagedListener(this.eventService, Events.EVENT_COLUMN_PIVOT_MODE_CHANGED, this.onPivotModeChanged.bind(this));
  }
  onBtPivotMode() {
    const newValue = !!this.cbPivotMode.getValue();
    if (newValue !== this.columnModel.isPivotMode()) {
      this.columnModel.setPivotMode(newValue, "toolPanelUi");
      const api = this.gridOptionsService.api;
      if (api) {
        api.refreshHeader();
      }
    }
  }
  onPivotModeChanged() {
    const pivotModeActive = this.columnModel.isPivotMode();
    this.cbPivotMode.setValue(pivotModeActive);
  }
};
__decorate7([
  Autowired("columnModel")
], PivotModePanel.prototype, "columnModel", void 0);
__decorate7([
  RefSelector("cbPivotMode")
], PivotModePanel.prototype, "cbPivotMode", void 0);
__decorate7([
  PreConstruct
], PivotModePanel.prototype, "init", null);

// ../../node_modules/@ag-grid-enterprise/row-grouping/dist/esm/es6/rowGrouping/aggregationStage.mjs
var __decorate8 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
  else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var AggregationStage = class AggregationStage2 extends BeanStub {
  // it's possible to recompute the aggregate without doing the other parts
  // + api.refreshClientSideRowModel('aggregate')
  execute(params) {
    const noValueColumns = _.missingOrEmpty(this.columnModel.getValueColumns());
    const noUserAgg = !this.gridOptionsService.getCallback("getGroupRowAgg");
    const changedPathActive = params.changedPath && params.changedPath.isActive();
    if (noValueColumns && noUserAgg && changedPathActive) {
      return;
    }
    const aggDetails = this.createAggDetails(params);
    this.recursivelyCreateAggData(aggDetails);
  }
  createAggDetails(params) {
    const pivotActive = this.columnModel.isPivotActive();
    const measureColumns = this.columnModel.getValueColumns();
    const pivotColumns = pivotActive ? this.columnModel.getPivotColumns() : [];
    const aggDetails = {
      alwaysAggregateAtRootLevel: this.gridOptionsService.is("alwaysAggregateAtRootLevel"),
      groupIncludeTotalFooter: this.gridOptionsService.is("groupIncludeTotalFooter"),
      changedPath: params.changedPath,
      valueColumns: measureColumns,
      pivotColumns,
      filteredOnly: !this.isSuppressAggFilteredOnly(),
      userAggFunc: this.gridOptionsService.getCallback("getGroupRowAgg")
    };
    return aggDetails;
  }
  isSuppressAggFilteredOnly() {
    const isGroupAggFiltering = this.gridOptionsService.getGroupAggFiltering() !== void 0;
    return isGroupAggFiltering || this.gridOptionsService.is("suppressAggFilteredOnly");
  }
  recursivelyCreateAggData(aggDetails) {
    const callback = (rowNode) => {
      const hasNoChildren = !rowNode.hasChildren();
      if (hasNoChildren) {
        if (rowNode.aggData) {
          rowNode.setAggData(null);
        }
        return;
      }
      const isRootNode = rowNode.level === -1;
      if (isRootNode && !aggDetails.groupIncludeTotalFooter) {
        const notPivoting = !this.columnModel.isPivotMode();
        if (!aggDetails.alwaysAggregateAtRootLevel && notPivoting) {
          return;
        }
      }
      this.aggregateRowNode(rowNode, aggDetails);
    };
    aggDetails.changedPath.forEachChangedNodeDepthFirst(callback, true);
  }
  aggregateRowNode(rowNode, aggDetails) {
    const measureColumnsMissing = aggDetails.valueColumns.length === 0;
    const pivotColumnsMissing = aggDetails.pivotColumns.length === 0;
    let aggResult;
    if (aggDetails.userAggFunc) {
      aggResult = aggDetails.userAggFunc({ nodes: rowNode.childrenAfterFilter });
    } else if (measureColumnsMissing) {
      aggResult = null;
    } else if (pivotColumnsMissing) {
      aggResult = this.aggregateRowNodeUsingValuesOnly(rowNode, aggDetails);
    } else {
      aggResult = this.aggregateRowNodeUsingValuesAndPivot(rowNode);
    }
    rowNode.setAggData(aggResult);
    if (rowNode.sibling) {
      rowNode.sibling.setAggData(aggResult);
    }
  }
  aggregateRowNodeUsingValuesAndPivot(rowNode) {
    var _a;
    const result = {};
    const secondaryColumns = (_a = this.columnModel.getSecondaryColumns()) !== null && _a !== void 0 ? _a : [];
    secondaryColumns.forEach((secondaryCol) => {
      const { pivotValueColumn, pivotTotalColumnIds, colId, pivotKeys } = secondaryCol.getColDef();
      if (_.exists(pivotTotalColumnIds)) {
        return;
      }
      const keys = pivotKeys !== null && pivotKeys !== void 0 ? pivotKeys : [];
      let values;
      if (rowNode.leafGroup) {
        values = this.getValuesFromMappedSet(rowNode.childrenMapped, keys, pivotValueColumn);
      } else {
        values = this.getValuesPivotNonLeaf(rowNode, colId);
      }
      result[colId] = this.aggregateValues(values, pivotValueColumn.getAggFunc(), pivotValueColumn, rowNode, secondaryCol);
    });
    secondaryColumns.forEach((secondaryCol) => {
      const { pivotValueColumn, pivotTotalColumnIds, colId } = secondaryCol.getColDef();
      if (!_.exists(pivotTotalColumnIds)) {
        return;
      }
      const aggResults = [];
      if (!pivotTotalColumnIds || !pivotTotalColumnIds.length) {
        return;
      }
      pivotTotalColumnIds.forEach((currentColId) => {
        aggResults.push(result[currentColId]);
      });
      result[colId] = this.aggregateValues(aggResults, pivotValueColumn.getAggFunc(), pivotValueColumn, rowNode, secondaryCol);
    });
    return result;
  }
  aggregateRowNodeUsingValuesOnly(rowNode, aggDetails) {
    const result = {};
    const changedValueColumns = aggDetails.changedPath.isActive() ? aggDetails.changedPath.getValueColumnsForNode(rowNode, aggDetails.valueColumns) : aggDetails.valueColumns;
    const notChangedValueColumns = aggDetails.changedPath.isActive() ? aggDetails.changedPath.getNotValueColumnsForNode(rowNode, aggDetails.valueColumns) : null;
    const values2d = this.getValuesNormal(rowNode, changedValueColumns, aggDetails.filteredOnly);
    const oldValues = rowNode.aggData;
    changedValueColumns.forEach((valueColumn, index) => {
      result[valueColumn.getId()] = this.aggregateValues(values2d[index], valueColumn.getAggFunc(), valueColumn, rowNode);
    });
    if (notChangedValueColumns && oldValues) {
      notChangedValueColumns.forEach((valueColumn) => {
        result[valueColumn.getId()] = oldValues[valueColumn.getId()];
      });
    }
    return result;
  }
  getValuesPivotNonLeaf(rowNode, colId) {
    const values = [];
    rowNode.childrenAfterFilter.forEach((node) => {
      const value = node.aggData[colId];
      values.push(value);
    });
    return values;
  }
  getValuesFromMappedSet(mappedSet, keys, valueColumn) {
    let mapPointer = mappedSet;
    keys.forEach((key) => mapPointer = mapPointer ? mapPointer[key] : null);
    if (!mapPointer) {
      return [];
    }
    const values = [];
    mapPointer.forEach((rowNode) => {
      const value = this.valueService.getValue(valueColumn, rowNode);
      values.push(value);
    });
    return values;
  }
  getValuesNormal(rowNode, valueColumns, filteredOnly) {
    const values = [];
    valueColumns.forEach(() => values.push([]));
    const valueColumnCount = valueColumns.length;
    const nodeList = filteredOnly ? rowNode.childrenAfterFilter : rowNode.childrenAfterGroup;
    const rowCount = nodeList.length;
    for (let i = 0; i < rowCount; i++) {
      const childNode = nodeList[i];
      for (let j = 0; j < valueColumnCount; j++) {
        const valueColumn = valueColumns[j];
        const value = this.valueService.getValue(valueColumn, childNode);
        values[j].push(value);
      }
    }
    return values;
  }
  aggregateValues(values, aggFuncOrString, column, rowNode, pivotResultColumn) {
    const aggFunc = typeof aggFuncOrString === "string" ? this.aggFuncService.getAggFunc(aggFuncOrString) : aggFuncOrString;
    if (typeof aggFunc !== "function") {
      console.error(`AG Grid: unrecognised aggregation function ${aggFuncOrString}`);
      return null;
    }
    const aggFuncAny = aggFunc;
    const params = {
      values,
      column,
      colDef: column ? column.getColDef() : void 0,
      pivotResultColumn,
      rowNode,
      data: rowNode ? rowNode.data : void 0,
      api: this.gridOptionsService.api,
      columnApi: this.gridOptionsService.columnApi,
      context: this.gridOptionsService.context
    };
    return aggFuncAny(params);
  }
};
__decorate8([
  Autowired("columnModel")
], AggregationStage.prototype, "columnModel", void 0);
__decorate8([
  Autowired("valueService")
], AggregationStage.prototype, "valueService", void 0);
__decorate8([
  Autowired("aggFuncService")
], AggregationStage.prototype, "aggFuncService", void 0);
AggregationStage = __decorate8([
  Bean("aggregationStage")
], AggregationStage);

// ../../node_modules/@ag-grid-enterprise/row-grouping/dist/esm/es6/rowGrouping/batchRemover.mjs
var BatchRemover = class {
  constructor() {
    this.allSets = {};
    this.allParents = [];
  }
  removeFromChildrenAfterGroup(parent, child) {
    const set = this.getSet(parent);
    set.removeFromChildrenAfterGroup[child.id] = true;
  }
  isRemoveFromAllLeafChildren(parent, child) {
    const set = this.getSet(parent);
    return !!set.removeFromAllLeafChildren[child.id];
  }
  preventRemoveFromAllLeafChildren(parent, child) {
    const set = this.getSet(parent);
    delete set.removeFromAllLeafChildren[child.id];
  }
  removeFromAllLeafChildren(parent, child) {
    const set = this.getSet(parent);
    set.removeFromAllLeafChildren[child.id] = true;
  }
  getSet(parent) {
    if (!this.allSets[parent.id]) {
      this.allSets[parent.id] = {
        removeFromAllLeafChildren: {},
        removeFromChildrenAfterGroup: {}
      };
      this.allParents.push(parent);
    }
    return this.allSets[parent.id];
  }
  getAllParents() {
    return this.allParents;
  }
  flush() {
    this.allParents.forEach((parent) => {
      const nodeDetails = this.allSets[parent.id];
      parent.childrenAfterGroup = parent.childrenAfterGroup.filter((child) => !nodeDetails.removeFromChildrenAfterGroup[child.id]);
      parent.allLeafChildren = parent.allLeafChildren.filter((child) => !nodeDetails.removeFromAllLeafChildren[child.id]);
      parent.updateHasChildren();
      if (parent.sibling) {
        parent.sibling.childrenAfterGroup = parent.childrenAfterGroup;
        parent.sibling.allLeafChildren = parent.allLeafChildren;
      }
    });
    this.allSets = {};
    this.allParents.length = 0;
  }
};

// ../../node_modules/@ag-grid-enterprise/row-grouping/dist/esm/es6/rowGrouping/groupStage.mjs
var __decorate9 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
  else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var GroupStage = class GroupStage2 extends BeanStub {
  constructor() {
    super(...arguments);
    this.groupIdSequence = new NumberSequence();
  }
  execute(params) {
    const details = this.createGroupingDetails(params);
    if (details.transactions) {
      this.handleTransaction(details);
    } else {
      const afterColsChanged = params.afterColumnsChanged === true;
      this.shotgunResetEverything(details, afterColsChanged);
    }
    if (!details.usingTreeData) {
      this.positionLeafsAndGroups(params.changedPath);
      this.orderGroups(details);
    }
    this.selectableService.updateSelectableAfterGrouping(details.rootNode);
  }
  positionLeafsAndGroups(changedPath) {
    changedPath.forEachChangedNodeDepthFirst((group) => {
      if (group.childrenAfterGroup) {
        const leafNodes = [];
        const groupNodes = [];
        let unbalancedNode;
        group.childrenAfterGroup.forEach((row) => {
          var _a;
          if (!((_a = row.childrenAfterGroup) === null || _a === void 0 ? void 0 : _a.length)) {
            leafNodes.push(row);
          } else {
            if (row.key === "" && !unbalancedNode) {
              unbalancedNode = row;
            } else {
              groupNodes.push(row);
            }
          }
        });
        if (unbalancedNode) {
          groupNodes.push(unbalancedNode);
        }
        group.childrenAfterGroup = [...leafNodes, ...groupNodes];
      }
    }, false);
  }
  createGroupingDetails(params) {
    const { rowNode, changedPath, rowNodeTransactions, rowNodeOrder } = params;
    const usingTreeData = this.gridOptionsService.is("treeData");
    const groupedCols = usingTreeData ? null : this.columnModel.getRowGroupColumns();
    const details = {
      // someone complained that the parent attribute was causing some change detection
      // to break in an angular add-on.  Taking the parent out breaks a cyclic dependency, hence this flag got introduced.
      includeParents: !this.gridOptionsService.is("suppressParentsInRowNodes"),
      expandByDefault: this.gridOptionsService.getNum("groupDefaultExpanded"),
      groupedCols,
      rootNode: rowNode,
      pivotMode: this.columnModel.isPivotMode(),
      groupedColCount: usingTreeData || !groupedCols ? 0 : groupedCols.length,
      rowNodeOrder,
      transactions: rowNodeTransactions,
      // if no transaction, then it's shotgun, changed path would be 'not active' at this point anyway
      changedPath,
      groupAllowUnbalanced: this.gridOptionsService.is("groupAllowUnbalanced"),
      isGroupOpenByDefault: this.gridOptionsService.getCallback("isGroupOpenByDefault"),
      initialGroupOrderComparator: this.gridOptionsService.getCallback("initialGroupOrderComparator"),
      createGroupFooter: this.gridOptionsService.isGroupIncludeFooterTrueOrCallback(),
      usingTreeData,
      getDataPath: usingTreeData ? this.gridOptionsService.get("getDataPath") : void 0
    };
    return details;
  }
  handleTransaction(details) {
    details.transactions.forEach((tran) => {
      const batchRemover = !details.usingTreeData ? new BatchRemover() : void 0;
      if (_.existsAndNotEmpty(tran.remove)) {
        this.removeNodes(tran.remove, details, batchRemover);
      }
      if (_.existsAndNotEmpty(tran.update)) {
        this.moveNodesInWrongPath(tran.update, details, batchRemover);
      }
      if (_.existsAndNotEmpty(tran.add)) {
        this.insertNodes(tran.add, details, false);
      }
      if (batchRemover) {
        const parentsWithChildrenRemoved = batchRemover.getAllParents().slice();
        batchRemover.flush();
        this.removeEmptyGroups(parentsWithChildrenRemoved, details);
      }
    });
    if (details.rowNodeOrder) {
      this.sortChildren(details);
    }
  }
  // this is used when doing delta updates, eg Redux, keeps nodes in right order
  sortChildren(details) {
    details.changedPath.forEachChangedNodeDepthFirst((node) => {
      if (!node.childrenAfterGroup) {
        return;
      }
      const didSort = _.sortRowNodesByOrder(node.childrenAfterGroup, details.rowNodeOrder);
      if (didSort) {
        details.changedPath.addParentNode(node);
      }
    }, false, true);
  }
  orderGroups(details) {
    const comparator = details.initialGroupOrderComparator;
    if (_.exists(comparator)) {
      recursiveSort(details.rootNode);
    }
    function recursiveSort(rowNode) {
      const doSort = _.exists(rowNode.childrenAfterGroup) && // we only want to sort groups, so we do not sort leafs (a leaf group has leafs as children)
      !rowNode.leafGroup;
      if (doSort) {
        rowNode.childrenAfterGroup.sort((nodeA, nodeB) => comparator({ nodeA, nodeB }));
        rowNode.childrenAfterGroup.forEach((childNode) => recursiveSort(childNode));
      }
    }
  }
  getExistingPathForNode(node, details) {
    const res = [];
    let pointer = details.usingTreeData ? node : node.parent;
    while (pointer && pointer !== details.rootNode) {
      res.push({
        key: pointer.key,
        rowGroupColumn: pointer.rowGroupColumn,
        field: pointer.field
      });
      pointer = pointer.parent;
    }
    res.reverse();
    return res;
  }
  moveNodesInWrongPath(childNodes, details, batchRemover) {
    childNodes.forEach((childNode) => {
      if (details.changedPath.isActive()) {
        details.changedPath.addParentNode(childNode.parent);
      }
      const infoToKeyMapper = (item) => item.key;
      const oldPath = this.getExistingPathForNode(childNode, details).map(infoToKeyMapper);
      const newPath = this.getGroupInfo(childNode, details).map(infoToKeyMapper);
      const nodeInCorrectPath = _.areEqual(oldPath, newPath);
      if (!nodeInCorrectPath) {
        this.moveNode(childNode, details, batchRemover);
      }
    });
  }
  moveNode(childNode, details, batchRemover) {
    this.removeNodesInStages([childNode], details, batchRemover);
    this.insertOneNode(childNode, details, true, batchRemover);
    childNode.setData(childNode.data);
    if (details.changedPath.isActive()) {
      const newParent = childNode.parent;
      details.changedPath.addParentNode(newParent);
    }
  }
  removeNodes(leafRowNodes, details, batchRemover) {
    this.removeNodesInStages(leafRowNodes, details, batchRemover);
    if (details.changedPath.isActive()) {
      leafRowNodes.forEach((rowNode) => details.changedPath.addParentNode(rowNode.parent));
    }
  }
  removeNodesInStages(leafRowNodes, details, batchRemover) {
    this.removeNodesFromParents(leafRowNodes, details, batchRemover);
    if (details.usingTreeData) {
      this.postRemoveCreateFillerNodes(leafRowNodes, details);
      const nodeParents = leafRowNodes.map((n) => n.parent);
      this.removeEmptyGroups(nodeParents, details);
    }
  }
  forEachParentGroup(details, group, callback) {
    let pointer = group;
    while (pointer && pointer !== details.rootNode) {
      callback(pointer);
      pointer = pointer.parent;
    }
  }
  removeNodesFromParents(nodesToRemove, details, provided) {
    const batchRemoverIsLocal = provided == null;
    const batchRemoverToUse = provided ? provided : new BatchRemover();
    nodesToRemove.forEach((nodeToRemove) => {
      this.removeFromParent(nodeToRemove, batchRemoverToUse);
      this.forEachParentGroup(details, nodeToRemove.parent, (parentNode) => {
        batchRemoverToUse.removeFromAllLeafChildren(parentNode, nodeToRemove);
      });
    });
    if (batchRemoverIsLocal) {
      batchRemoverToUse.flush();
    }
  }
  postRemoveCreateFillerNodes(nodesToRemove, details) {
    nodesToRemove.forEach((nodeToRemove) => {
      const replaceWithGroup = nodeToRemove.hasChildren();
      if (replaceWithGroup) {
        const oldPath = this.getExistingPathForNode(nodeToRemove, details);
        const newGroupNode = this.findParentForNode(nodeToRemove, oldPath, details);
        newGroupNode.expanded = nodeToRemove.expanded;
        newGroupNode.allLeafChildren = nodeToRemove.allLeafChildren;
        newGroupNode.childrenAfterGroup = nodeToRemove.childrenAfterGroup;
        newGroupNode.childrenMapped = nodeToRemove.childrenMapped;
        newGroupNode.updateHasChildren();
        newGroupNode.childrenAfterGroup.forEach((rowNode) => rowNode.parent = newGroupNode);
      }
    });
  }
  removeEmptyGroups(possibleEmptyGroups, details) {
    let checkAgain = true;
    const groupShouldBeRemoved = (rowNode) => {
      const mapKey = this.getChildrenMappedKey(rowNode.key, rowNode.rowGroupColumn);
      const parentRowNode = rowNode.parent;
      const groupAlreadyRemoved = parentRowNode && parentRowNode.childrenMapped ? !parentRowNode.childrenMapped[mapKey] : true;
      if (groupAlreadyRemoved) {
        return false;
      }
      return !!rowNode.isEmptyRowGroupNode();
    };
    while (checkAgain) {
      checkAgain = false;
      const batchRemover = new BatchRemover();
      possibleEmptyGroups.forEach((possibleEmptyGroup) => {
        this.forEachParentGroup(details, possibleEmptyGroup, (rowNode) => {
          if (groupShouldBeRemoved(rowNode)) {
            checkAgain = true;
            this.removeFromParent(rowNode, batchRemover);
            rowNode.setSelectedParams({ newValue: false, source: "rowGroupChanged" });
          }
        });
      });
      batchRemover.flush();
    }
  }
  // removes the node from the parent by:
  // a) removing from childrenAfterGroup (using batchRemover if present, otherwise immediately)
  // b) removing from childrenMapped (immediately)
  // c) setRowTop(null) - as the rowRenderer uses this to know the RowNode is no longer needed
  // d) setRowIndex(null) - as the rowNode will no longer be displayed.
  removeFromParent(child, batchRemover) {
    if (child.parent) {
      if (batchRemover) {
        batchRemover.removeFromChildrenAfterGroup(child.parent, child);
      } else {
        _.removeFromArray(child.parent.childrenAfterGroup, child);
        child.parent.updateHasChildren();
      }
    }
    const mapKey = this.getChildrenMappedKey(child.key, child.rowGroupColumn);
    if (child.parent && child.parent.childrenMapped) {
      child.parent.childrenMapped[mapKey] = void 0;
    }
    child.setRowTop(null);
    child.setRowIndex(null);
  }
  addToParent(child, parent) {
    const mapKey = this.getChildrenMappedKey(child.key, child.rowGroupColumn);
    if (parent) {
      const children = parent.childrenMapped != null;
      if (children) {
        parent.childrenMapped[mapKey] = child;
      }
      parent.childrenAfterGroup.push(child);
      parent.updateHasChildren();
    }
  }
  areGroupColsEqual(d1, d2) {
    if (d1 == null || d2 == null || d1.pivotMode !== d2.pivotMode) {
      return false;
    }
    return _.areEqual(d1.groupedCols, d2.groupedCols);
  }
  checkAllGroupDataAfterColsChanged(details) {
    const recurse = (rowNodes) => {
      if (!rowNodes) {
        return;
      }
      rowNodes.forEach((rowNode) => {
        const isLeafNode = !details.usingTreeData && !rowNode.group;
        if (isLeafNode) {
          return;
        }
        const groupInfo = {
          field: rowNode.field,
          key: rowNode.key,
          rowGroupColumn: rowNode.rowGroupColumn
        };
        this.setGroupData(rowNode, groupInfo, details);
        recurse(rowNode.childrenAfterGroup);
      });
    };
    recurse(details.rootNode.childrenAfterGroup);
  }
  shotgunResetEverything(details, afterColumnsChanged) {
    if (this.noChangeInGroupingColumns(details, afterColumnsChanged)) {
      return;
    }
    this.selectionService.filterFromSelection((node) => node && !node.group);
    const { rootNode, groupedCols } = details;
    rootNode.leafGroup = details.usingTreeData ? false : groupedCols.length === 0;
    rootNode.childrenAfterGroup = [];
    rootNode.childrenMapped = {};
    rootNode.updateHasChildren();
    const sibling = rootNode.sibling;
    if (sibling) {
      sibling.childrenAfterGroup = rootNode.childrenAfterGroup;
      sibling.childrenMapped = rootNode.childrenMapped;
    }
    this.insertNodes(rootNode.allLeafChildren, details, false);
  }
  noChangeInGroupingColumns(details, afterColumnsChanged) {
    let noFurtherProcessingNeeded = false;
    const groupDisplayColumns = this.columnModel.getGroupDisplayColumns();
    const newGroupDisplayColIds = groupDisplayColumns ? groupDisplayColumns.map((c) => c.getId()).join("-") : "";
    if (afterColumnsChanged) {
      noFurtherProcessingNeeded = details.usingTreeData || this.areGroupColsEqual(details, this.oldGroupingDetails);
      if (this.oldGroupDisplayColIds !== newGroupDisplayColIds) {
        this.checkAllGroupDataAfterColsChanged(details);
      }
    }
    this.oldGroupingDetails = details;
    this.oldGroupDisplayColIds = newGroupDisplayColIds;
    return noFurtherProcessingNeeded;
  }
  insertNodes(newRowNodes, details, isMove) {
    newRowNodes.forEach((rowNode) => {
      this.insertOneNode(rowNode, details, isMove);
      if (details.changedPath.isActive()) {
        details.changedPath.addParentNode(rowNode.parent);
      }
    });
  }
  insertOneNode(childNode, details, isMove, batchRemover) {
    const path = this.getGroupInfo(childNode, details);
    const parentGroup = this.findParentForNode(childNode, path, details, batchRemover);
    if (!parentGroup.group) {
      console.warn(`AG Grid: duplicate group keys for row data, keys should be unique`, [parentGroup.data, childNode.data]);
    }
    if (details.usingTreeData) {
      this.swapGroupWithUserNode(parentGroup, childNode, isMove);
    } else {
      childNode.parent = parentGroup;
      childNode.level = path.length;
      parentGroup.childrenAfterGroup.push(childNode);
      parentGroup.updateHasChildren();
    }
  }
  findParentForNode(childNode, path, details, batchRemover) {
    let nextNode = details.rootNode;
    path.forEach((groupInfo, level) => {
      nextNode = this.getOrCreateNextNode(nextNode, groupInfo, level, details);
      if (!(batchRemover === null || batchRemover === void 0 ? void 0 : batchRemover.isRemoveFromAllLeafChildren(nextNode, childNode))) {
        nextNode.allLeafChildren.push(childNode);
      } else {
        batchRemover === null || batchRemover === void 0 ? void 0 : batchRemover.preventRemoveFromAllLeafChildren(nextNode, childNode);
      }
    });
    return nextNode;
  }
  swapGroupWithUserNode(fillerGroup, userGroup, isMove) {
    userGroup.parent = fillerGroup.parent;
    userGroup.key = fillerGroup.key;
    userGroup.field = fillerGroup.field;
    userGroup.groupData = fillerGroup.groupData;
    userGroup.level = fillerGroup.level;
    if (!isMove) {
      userGroup.expanded = fillerGroup.expanded;
    }
    userGroup.leafGroup = fillerGroup.leafGroup;
    userGroup.rowGroupIndex = fillerGroup.rowGroupIndex;
    userGroup.allLeafChildren = fillerGroup.allLeafChildren;
    userGroup.childrenAfterGroup = fillerGroup.childrenAfterGroup;
    userGroup.childrenMapped = fillerGroup.childrenMapped;
    userGroup.sibling = fillerGroup.sibling;
    userGroup.updateHasChildren();
    this.removeFromParent(fillerGroup);
    userGroup.childrenAfterGroup.forEach((rowNode) => rowNode.parent = userGroup);
    this.addToParent(userGroup, fillerGroup.parent);
  }
  getOrCreateNextNode(parentGroup, groupInfo, level, details) {
    const key = this.getChildrenMappedKey(groupInfo.key, groupInfo.rowGroupColumn);
    let nextNode = parentGroup.childrenMapped ? parentGroup.childrenMapped[key] : void 0;
    if (!nextNode) {
      nextNode = this.createGroup(groupInfo, parentGroup, level, details);
      this.addToParent(nextNode, parentGroup);
    }
    return nextNode;
  }
  createGroup(groupInfo, parent, level, details) {
    const groupNode = new RowNode(this.beans);
    groupNode.group = true;
    groupNode.field = groupInfo.field;
    groupNode.rowGroupColumn = groupInfo.rowGroupColumn;
    this.setGroupData(groupNode, groupInfo, details);
    groupNode.id = RowNode.ID_PREFIX_ROW_GROUP + this.groupIdSequence.next();
    groupNode.key = groupInfo.key;
    groupNode.level = level;
    groupNode.leafGroup = details.usingTreeData ? false : level === details.groupedColCount - 1;
    groupNode.allLeafChildren = [];
    groupNode.setAllChildrenCount(0);
    groupNode.rowGroupIndex = details.usingTreeData ? null : level;
    groupNode.childrenAfterGroup = [];
    groupNode.childrenMapped = {};
    groupNode.updateHasChildren();
    groupNode.parent = details.includeParents ? parent : null;
    this.setExpandedInitialValue(details, groupNode);
    return groupNode;
  }
  setGroupData(groupNode, groupInfo, details) {
    groupNode.groupData = {};
    const groupDisplayCols = this.columnModel.getGroupDisplayColumns();
    groupDisplayCols.forEach((col) => {
      const displayGroupForCol = details.usingTreeData || (groupNode.rowGroupColumn ? col.isRowGroupDisplayed(groupNode.rowGroupColumn.getId()) : false);
      if (displayGroupForCol) {
        groupNode.groupData[col.getColId()] = groupInfo.key;
      }
    });
  }
  getChildrenMappedKey(key, rowGroupColumn) {
    if (rowGroupColumn) {
      return rowGroupColumn.getId() + "-" + key;
    }
    return key;
  }
  setExpandedInitialValue(details, groupNode) {
    if (details.pivotMode && groupNode.leafGroup) {
      groupNode.expanded = false;
      return;
    }
    const userCallback = details.isGroupOpenByDefault;
    if (userCallback) {
      const params = {
        rowNode: groupNode,
        field: groupNode.field,
        key: groupNode.key,
        level: groupNode.level,
        rowGroupColumn: groupNode.rowGroupColumn
      };
      groupNode.expanded = userCallback(params) == true;
      return;
    }
    const { expandByDefault } = details;
    if (details.expandByDefault === -1) {
      groupNode.expanded = true;
      return;
    }
    groupNode.expanded = groupNode.level < expandByDefault;
  }
  getGroupInfo(rowNode, details) {
    if (details.usingTreeData) {
      return this.getGroupInfoFromCallback(rowNode, details);
    }
    return this.getGroupInfoFromGroupColumns(rowNode, details);
  }
  getGroupInfoFromCallback(rowNode, details) {
    const keys = details.getDataPath ? details.getDataPath(rowNode.data) : null;
    if (keys === null || keys === void 0 || keys.length === 0) {
      _.doOnce(() => console.warn(`AG Grid: getDataPath() should not return an empty path for data`, rowNode.data), "groupStage.getGroupInfoFromCallback");
    }
    const groupInfoMapper = (key) => ({ key, field: null, rowGroupColumn: null });
    return keys ? keys.map(groupInfoMapper) : [];
  }
  getGroupInfoFromGroupColumns(rowNode, details) {
    const res = [];
    details.groupedCols.forEach((groupCol) => {
      let key = this.valueService.getKeyForNode(groupCol, rowNode);
      let keyExists = key !== null && key !== void 0 && key !== "";
      const createGroupForEmpty = details.pivotMode || !details.groupAllowUnbalanced;
      if (createGroupForEmpty && !keyExists) {
        key = "";
        keyExists = true;
      }
      if (keyExists) {
        const item = {
          key,
          field: groupCol.getColDef().field,
          rowGroupColumn: groupCol
        };
        res.push(item);
      }
    });
    return res;
  }
};
__decorate9([
  Autowired("columnModel")
], GroupStage.prototype, "columnModel", void 0);
__decorate9([
  Autowired("selectableService")
], GroupStage.prototype, "selectableService", void 0);
__decorate9([
  Autowired("valueService")
], GroupStage.prototype, "valueService", void 0);
__decorate9([
  Autowired("beans")
], GroupStage.prototype, "beans", void 0);
__decorate9([
  Autowired("selectionService")
], GroupStage.prototype, "selectionService", void 0);
GroupStage = __decorate9([
  Bean("groupStage")
], GroupStage);

// ../../node_modules/@ag-grid-enterprise/row-grouping/dist/esm/es6/rowGrouping/pivotColDefService.mjs
var __decorate10 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
  else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var PivotColDefService_1;
var PivotColDefService = PivotColDefService_1 = class PivotColDefService2 extends BeanStub {
  init() {
    const getFieldSeparator = () => {
      var _a;
      return (_a = this.gos.get("serverSidePivotResultFieldSeparator")) !== null && _a !== void 0 ? _a : "_";
    };
    this.fieldSeparator = getFieldSeparator();
    this.addManagedPropertyListener("serverSidePivotResultFieldSeparator", () => {
      this.fieldSeparator = getFieldSeparator();
    });
    const getPivotDefaultExpanded = () => {
      var _a;
      return (_a = this.gos.getNum("pivotDefaultExpanded")) !== null && _a !== void 0 ? _a : 0;
    };
    this.pivotDefaultExpanded = getPivotDefaultExpanded();
    this.addManagedPropertyListener("pivotDefaultExpanded", () => {
      this.pivotDefaultExpanded = getPivotDefaultExpanded();
    });
  }
  createPivotColumnDefs(uniqueValues) {
    const pivotColumnGroupDefs = this.createPivotColumnsFromUniqueValues(uniqueValues);
    function extractColDefs(input, arr = []) {
      input.forEach((def) => {
        if (def.children !== void 0) {
          extractColDefs(def.children, arr);
        } else {
          arr.push(def);
        }
      });
      return arr;
    }
    const pivotColumnDefs = extractColDefs(pivotColumnGroupDefs);
    this.addRowGroupTotals(pivotColumnGroupDefs, pivotColumnDefs);
    this.addExpandablePivotGroups(pivotColumnGroupDefs, pivotColumnDefs);
    this.addPivotTotalsToGroups(pivotColumnGroupDefs, pivotColumnDefs);
    const pivotColumnDefsClone = pivotColumnDefs.map((colDef) => _.cloneObject(colDef));
    return {
      pivotColumnGroupDefs,
      pivotColumnDefs: pivotColumnDefsClone
    };
  }
  createPivotColumnsFromUniqueValues(uniqueValues) {
    const pivotColumns = this.columnModel.getPivotColumns();
    const maxDepth = pivotColumns.length;
    const pivotColumnGroupDefs = this.recursivelyBuildGroup(0, uniqueValues, [], maxDepth, pivotColumns);
    return pivotColumnGroupDefs;
  }
  recursivelyBuildGroup(index, uniqueValue, pivotKeys, maxDepth, primaryPivotColumns) {
    const measureColumns = this.columnModel.getValueColumns();
    if (index >= maxDepth) {
      return this.buildMeasureCols(pivotKeys);
    }
    const primaryPivotColumnDefs = primaryPivotColumns[index].getColDef();
    const comparator = this.headerNameComparator.bind(this, primaryPivotColumnDefs.pivotComparator);
    if (measureColumns.length === 1 && this.gridOptionsService.is("removePivotHeaderRowWhenSingleValueColumn") && index === maxDepth - 1) {
      const leafCols = [];
      _.iterateObject(uniqueValue, (key) => {
        const newPivotKeys = [...pivotKeys, key];
        const colDef = this.createColDef(measureColumns[0], key, newPivotKeys);
        colDef.columnGroupShow = "open";
        leafCols.push(colDef);
      });
      leafCols.sort(comparator);
      return leafCols;
    }
    const groups = [];
    _.iterateObject(uniqueValue, (key, value) => {
      const openByDefault = this.pivotDefaultExpanded === -1 || index < this.pivotDefaultExpanded;
      const newPivotKeys = [...pivotKeys, key];
      groups.push({
        children: this.recursivelyBuildGroup(index + 1, value, newPivotKeys, maxDepth, primaryPivotColumns),
        headerName: key,
        pivotKeys: newPivotKeys,
        columnGroupShow: "open",
        openByDefault,
        groupId: this.generateColumnGroupId(newPivotKeys)
      });
    });
    groups.sort(comparator);
    return groups;
  }
  buildMeasureCols(pivotKeys) {
    const measureColumns = this.columnModel.getValueColumns();
    if (measureColumns.length === 0) {
      return [this.createColDef(null, "-", pivotKeys)];
    }
    return measureColumns.map((measureCol) => {
      const columnName = this.columnModel.getDisplayNameForColumn(measureCol, "header");
      return Object.assign(Object.assign({}, this.createColDef(measureCol, columnName, pivotKeys)), { columnGroupShow: "open" });
    });
  }
  addExpandablePivotGroups(pivotColumnGroupDefs, pivotColumnDefs) {
    if (this.gridOptionsService.is("suppressExpandablePivotGroups") || this.gridOptionsService.get("pivotColumnGroupTotals")) {
      return;
    }
    const recursivelyAddSubTotals = (groupDef, currentPivotColumnDefs, acc) => {
      const group = groupDef;
      if (group.children) {
        const childAcc = /* @__PURE__ */ new Map();
        group.children.forEach((grp) => {
          recursivelyAddSubTotals(grp, currentPivotColumnDefs, childAcc);
        });
        const firstGroup = !group.children.some((child) => child.children);
        this.columnModel.getValueColumns().forEach((valueColumn) => {
          const columnName = this.columnModel.getDisplayNameForColumn(valueColumn, "header");
          const totalColDef = this.createColDef(valueColumn, columnName, groupDef.pivotKeys);
          totalColDef.pivotTotalColumnIds = childAcc.get(valueColumn.getColId());
          totalColDef.columnGroupShow = "closed";
          totalColDef.aggFunc = valueColumn.getAggFunc();
          if (!firstGroup) {
            const children = groupDef.children;
            children.push(totalColDef);
            currentPivotColumnDefs.push(totalColDef);
          }
        });
        this.merge(acc, childAcc);
      } else {
        const def = groupDef;
        if (!def.pivotValueColumn) {
          return;
        }
        const pivotValueColId = def.pivotValueColumn.getColId();
        const arr = acc.has(pivotValueColId) ? acc.get(pivotValueColId) : [];
        arr.push(def.colId);
        acc.set(pivotValueColId, arr);
      }
    };
    pivotColumnGroupDefs.forEach((groupDef) => {
      recursivelyAddSubTotals(groupDef, pivotColumnDefs, /* @__PURE__ */ new Map());
    });
  }
  addPivotTotalsToGroups(pivotColumnGroupDefs, pivotColumnDefs) {
    if (!this.gridOptionsService.get("pivotColumnGroupTotals")) {
      return;
    }
    const insertAfter = this.gridOptionsService.get("pivotColumnGroupTotals") === "after";
    const valueCols = this.columnModel.getValueColumns();
    const aggFuncs = valueCols.map((valueCol) => valueCol.getAggFunc());
    if (!aggFuncs || aggFuncs.length < 1 || !this.sameAggFuncs(aggFuncs)) {
      return;
    }
    const valueColumn = valueCols[0];
    pivotColumnGroupDefs.forEach((groupDef) => {
      this.recursivelyAddPivotTotal(groupDef, pivotColumnDefs, valueColumn, insertAfter);
    });
  }
  recursivelyAddPivotTotal(groupDef, pivotColumnDefs, valueColumn, insertAfter) {
    const group = groupDef;
    if (!group.children) {
      const def = groupDef;
      return def.colId ? [def.colId] : null;
    }
    let colIds = [];
    group.children.forEach((grp) => {
      const childColIds = this.recursivelyAddPivotTotal(grp, pivotColumnDefs, valueColumn, insertAfter);
      if (childColIds) {
        colIds = colIds.concat(childColIds);
      }
    });
    if (group.children.length > 1) {
      const localeTextFunc = this.localeService.getLocaleTextFunc();
      const headerName = localeTextFunc("pivotColumnGroupTotals", "Total");
      const totalColDef = this.createColDef(valueColumn, headerName, groupDef.pivotKeys, true);
      totalColDef.pivotTotalColumnIds = colIds;
      totalColDef.aggFunc = valueColumn.getAggFunc();
      const children = groupDef.children;
      insertAfter ? children.push(totalColDef) : children.unshift(totalColDef);
      pivotColumnDefs.push(totalColDef);
    }
    return colIds;
  }
  addRowGroupTotals(pivotColumnGroupDefs, pivotColumnDefs) {
    if (!this.gridOptionsService.get("pivotRowTotals")) {
      return;
    }
    const insertAfter = this.gridOptionsService.get("pivotRowTotals") === "after";
    const valueColumns = this.columnModel.getValueColumns();
    const valueCols = insertAfter ? valueColumns.slice() : valueColumns.slice().reverse();
    for (let i = 0; i < valueCols.length; i++) {
      const valueCol = valueCols[i];
      let colIds = [];
      pivotColumnGroupDefs.forEach((groupDef) => {
        colIds = colIds.concat(this.extractColIdsForValueColumn(groupDef, valueCol));
      });
      const withGroup = valueCols.length > 1 || !this.gridOptionsService.is("removePivotHeaderRowWhenSingleValueColumn");
      this.createRowGroupTotal(pivotColumnGroupDefs, pivotColumnDefs, valueCol, colIds, insertAfter, withGroup);
    }
  }
  extractColIdsForValueColumn(groupDef, valueColumn) {
    const group = groupDef;
    if (!group.children) {
      const colDef = group;
      return colDef.pivotValueColumn === valueColumn && colDef.colId ? [colDef.colId] : [];
    }
    let colIds = [];
    group.children.forEach((grp) => {
      this.extractColIdsForValueColumn(grp, valueColumn);
      const childColIds = this.extractColIdsForValueColumn(grp, valueColumn);
      colIds = colIds.concat(childColIds);
    });
    return colIds;
  }
  createRowGroupTotal(parentChildren, pivotColumnDefs, valueColumn, colIds, insertAfter, addGroup) {
    const measureColumns = this.columnModel.getValueColumns();
    let colDef;
    if (measureColumns.length === 0) {
      colDef = this.createColDef(null, "-", []);
    } else {
      const columnName = this.columnModel.getDisplayNameForColumn(valueColumn, "header");
      colDef = this.createColDef(valueColumn, columnName, []);
      colDef.pivotTotalColumnIds = colIds;
    }
    colDef.colId = PivotColDefService_1.PIVOT_ROW_TOTAL_PREFIX + colDef.colId;
    pivotColumnDefs.push(colDef);
    const valueGroup = addGroup ? {
      children: [colDef],
      pivotKeys: [],
      groupId: `${PivotColDefService_1.PIVOT_ROW_TOTAL_PREFIX}_pivotGroup_${valueColumn.getColId()}`
    } : colDef;
    insertAfter ? parentChildren.push(valueGroup) : parentChildren.unshift(valueGroup);
  }
  createColDef(valueColumn, headerName, pivotKeys, totalColumn = false) {
    const colDef = {};
    if (valueColumn) {
      const colDefToCopy = valueColumn.getColDef();
      Object.assign(colDef, colDefToCopy);
      colDef.hide = false;
    }
    colDef.headerName = headerName;
    colDef.colId = this.generateColumnId(pivotKeys || [], valueColumn && !totalColumn ? valueColumn.getColId() : "");
    colDef.field = colDef.colId;
    colDef.valueGetter = (params) => {
      var _a;
      return (_a = params.data) === null || _a === void 0 ? void 0 : _a[params.colDef.field];
    };
    colDef.pivotKeys = pivotKeys;
    colDef.pivotValueColumn = valueColumn;
    if (colDef.filter === true) {
      colDef.filter = "agNumberColumnFilter";
    }
    return colDef;
  }
  sameAggFuncs(aggFuncs) {
    if (aggFuncs.length == 1) {
      return true;
    }
    for (let i = 1; i < aggFuncs.length; i++) {
      if (aggFuncs[i] !== aggFuncs[0]) {
        return false;
      }
    }
    return true;
  }
  headerNameComparator(userComparator, a, b) {
    if (userComparator) {
      return userComparator(a.headerName, b.headerName);
    } else {
      if (a.headerName && !b.headerName) {
        return 1;
      } else if (!a.headerName && b.headerName) {
        return -1;
      }
      if (!a.headerName || !b.headerName) {
        return 0;
      }
      if (a.headerName < b.headerName) {
        return -1;
      }
      if (a.headerName > b.headerName) {
        return 1;
      }
      return 0;
    }
  }
  merge(m1, m2) {
    m2.forEach((value, key, map) => {
      const existingList = m1.has(key) ? m1.get(key) : [];
      const updatedList = [...existingList, ...value];
      m1.set(key, updatedList);
    });
  }
  generateColumnGroupId(pivotKeys) {
    const pivotCols = this.columnModel.getPivotColumns().map((col) => col.getColId());
    return `pivotGroup_${pivotCols.join("-")}_${pivotKeys.join("-")}`;
  }
  generateColumnId(pivotKeys, measureColumnId) {
    const pivotCols = this.columnModel.getPivotColumns().map((col) => col.getColId());
    return `pivot_${pivotCols.join("-")}_${pivotKeys.join("-")}_${measureColumnId}`;
  }
  /**
   * Used by the SSRM to create secondary columns from provided fields
   * @param fields
   */
  createColDefsFromFields(fields) {
    ;
    const uniqueValues = {};
    for (let i = 0; i < fields.length; i++) {
      const field = fields[i];
      const parts = field.split(this.fieldSeparator);
      let level = uniqueValues;
      for (let p = 0; p < parts.length; p++) {
        const part = parts[p];
        if (level[part] == null) {
          level[part] = {};
        }
        level = level[part];
      }
    }
    const uniqueValuesToGroups = (id, key, uniqueValues2, depth) => {
      var _a;
      const children = [];
      for (let key2 in uniqueValues2) {
        const item = uniqueValues2[key2];
        const child = uniqueValuesToGroups(`${id}${this.fieldSeparator}${key2}`, key2, item, depth + 1);
        children.push(child);
      }
      if (children.length === 0) {
        const col = {
          colId: id,
          headerName: key,
          // this is to support using pinned rows, normally the data will be extracted from the aggData object using the colId
          // however pinned rows still access the data object by field, this prevents values with dots from being treated as complex objects
          valueGetter: (params) => {
            var _a2;
            return (_a2 = params.data) === null || _a2 === void 0 ? void 0 : _a2[id];
          }
        };
        const potentialAggCol = this.columnModel.getPrimaryColumn(key);
        if (potentialAggCol) {
          col.headerName = (_a = this.columnModel.getDisplayNameForColumn(potentialAggCol, "header")) !== null && _a !== void 0 ? _a : key;
          col.aggFunc = potentialAggCol.getAggFunc();
          col.pivotValueColumn = potentialAggCol;
        }
        return col;
      }
      const collapseSingleChildren = this.gridOptionsService.is("removePivotHeaderRowWhenSingleValueColumn");
      if (collapseSingleChildren && children.length === 1 && "colId" in children[0]) {
        children[0].headerName = key;
        return children[0];
      }
      const group = {
        openByDefault: this.pivotDefaultExpanded === -1 || depth < this.pivotDefaultExpanded,
        groupId: id,
        headerName: key,
        children
      };
      return group;
    };
    const res = [];
    for (let key in uniqueValues) {
      const item = uniqueValues[key];
      const col = uniqueValuesToGroups(key, key, item, 0);
      res.push(col);
    }
    return res;
  }
};
PivotColDefService.PIVOT_ROW_TOTAL_PREFIX = "PivotRowTotal_";
__decorate10([
  Autowired("columnModel")
], PivotColDefService.prototype, "columnModel", void 0);
__decorate10([
  Autowired("gridOptionsService")
], PivotColDefService.prototype, "gos", void 0);
__decorate10([
  PostConstruct
], PivotColDefService.prototype, "init", null);
PivotColDefService = PivotColDefService_1 = __decorate10([
  Bean("pivotColDefService")
], PivotColDefService);

// ../../node_modules/@ag-grid-enterprise/row-grouping/dist/esm/es6/rowGrouping/pivotStage.mjs
var __decorate11 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
  else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var PivotStage = class PivotStage2 extends BeanStub {
  constructor() {
    super(...arguments);
    this.uniqueValues = {};
  }
  execute(params) {
    const changedPath = params.changedPath;
    if (this.columnModel.isPivotActive()) {
      this.executePivotOn(changedPath);
    } else {
      this.executePivotOff(changedPath);
    }
  }
  executePivotOff(changedPath) {
    this.aggregationColumnsHashLastTime = null;
    this.uniqueValues = {};
    if (this.columnModel.isSecondaryColumnsPresent()) {
      this.columnModel.setSecondaryColumns(null, "rowModelUpdated");
      if (changedPath) {
        changedPath.setInactive();
      }
    }
  }
  executePivotOn(changedPath) {
    const uniqueValues = this.bucketUpRowNodes(changedPath);
    const uniqueValuesChanged = this.setUniqueValues(uniqueValues);
    const aggregationColumns = this.columnModel.getValueColumns();
    const aggregationColumnsHash = aggregationColumns.map((column) => `${column.getId()}-${column.getColDef().headerName}`).join("#");
    const aggregationFuncsHash = aggregationColumns.map((column) => column.getAggFunc().toString()).join("#");
    const aggregationColumnsChanged = this.aggregationColumnsHashLastTime !== aggregationColumnsHash;
    const aggregationFuncsChanged = this.aggregationFuncsHashLastTime !== aggregationFuncsHash;
    this.aggregationColumnsHashLastTime = aggregationColumnsHash;
    this.aggregationFuncsHashLastTime = aggregationFuncsHash;
    const groupColumnsHash = this.columnModel.getRowGroupColumns().map((column) => column.getId()).join("#");
    const groupColumnsChanged = groupColumnsHash !== this.groupColumnsHashLastTime;
    this.groupColumnsHashLastTime = groupColumnsHash;
    if (uniqueValuesChanged || aggregationColumnsChanged || groupColumnsChanged || aggregationFuncsChanged) {
      const { pivotColumnGroupDefs, pivotColumnDefs } = this.pivotColDefService.createPivotColumnDefs(this.uniqueValues);
      this.pivotColumnDefs = pivotColumnDefs;
      this.columnModel.setSecondaryColumns(pivotColumnGroupDefs, "rowModelUpdated");
      if (changedPath) {
        changedPath.setInactive();
      }
    }
  }
  setUniqueValues(newValues) {
    const json1 = JSON.stringify(newValues);
    const json2 = JSON.stringify(this.uniqueValues);
    const uniqueValuesChanged = json1 !== json2;
    if (uniqueValuesChanged) {
      this.uniqueValues = newValues;
      return true;
    } else {
      return false;
    }
  }
  bucketUpRowNodes(changedPath) {
    const uniqueValues = {};
    changedPath.forEachChangedNodeDepthFirst((node) => {
      if (node.leafGroup) {
        node.childrenMapped = null;
      }
    });
    const recursivelyBucketFilteredChildren = (node) => {
      var _a;
      if (node.leafGroup) {
        this.bucketRowNode(node, uniqueValues);
      } else {
        (_a = node.childrenAfterFilter) === null || _a === void 0 ? void 0 : _a.forEach(recursivelyBucketFilteredChildren);
      }
    };
    changedPath.executeFromRootNode(recursivelyBucketFilteredChildren);
    return uniqueValues;
  }
  bucketRowNode(rowNode, uniqueValues) {
    const pivotColumns = this.columnModel.getPivotColumns();
    if (pivotColumns.length === 0) {
      rowNode.childrenMapped = null;
    } else {
      rowNode.childrenMapped = this.bucketChildren(rowNode.childrenAfterFilter, pivotColumns, 0, uniqueValues);
    }
    if (rowNode.sibling) {
      rowNode.sibling.childrenMapped = rowNode.childrenMapped;
    }
  }
  bucketChildren(children, pivotColumns, pivotIndex, uniqueValues) {
    const mappedChildren = {};
    const pivotColumn = pivotColumns[pivotIndex];
    children.forEach((child) => {
      let key = this.valueService.getKeyForNode(pivotColumn, child);
      if (_.missing(key)) {
        key = "";
      }
      if (!uniqueValues[key]) {
        uniqueValues[key] = {};
      }
      if (!mappedChildren[key]) {
        mappedChildren[key] = [];
      }
      mappedChildren[key].push(child);
    });
    if (pivotIndex === pivotColumns.length - 1) {
      return mappedChildren;
    } else {
      const result = {};
      _.iterateObject(mappedChildren, (key, value) => {
        result[key] = this.bucketChildren(value, pivotColumns, pivotIndex + 1, uniqueValues[key]);
      });
      return result;
    }
  }
  getPivotColumnDefs() {
    return this.pivotColumnDefs;
  }
};
__decorate11([
  Autowired("valueService")
], PivotStage.prototype, "valueService", void 0);
__decorate11([
  Autowired("columnModel")
], PivotStage.prototype, "columnModel", void 0);
__decorate11([
  Autowired("pivotColDefService")
], PivotStage.prototype, "pivotColDefService", void 0);
PivotStage = __decorate11([
  Bean("pivotStage")
], PivotStage);

// ../../node_modules/@ag-grid-enterprise/row-grouping/dist/esm/es6/rowGrouping/aggFuncService.mjs
var __decorate12 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
  else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var AggFuncService_1;
var AGBigInt = typeof BigInt === "undefined" ? null : BigInt;
var AggFuncService = AggFuncService_1 = class AggFuncService2 extends BeanStub {
  constructor() {
    super(...arguments);
    this.aggFuncsMap = {};
    this.initialised = false;
  }
  init() {
    if (this.initialised) {
      return;
    }
    this.initialiseWithDefaultAggregations();
    this.addAggFuncs(this.gridOptionsService.get("aggFuncs"));
  }
  initialiseWithDefaultAggregations() {
    this.aggFuncsMap[AggFuncService_1.AGG_SUM] = aggSum;
    this.aggFuncsMap[AggFuncService_1.AGG_FIRST] = aggFirst;
    this.aggFuncsMap[AggFuncService_1.AGG_LAST] = aggLast;
    this.aggFuncsMap[AggFuncService_1.AGG_MIN] = aggMin;
    this.aggFuncsMap[AggFuncService_1.AGG_MAX] = aggMax;
    this.aggFuncsMap[AggFuncService_1.AGG_COUNT] = aggCount;
    this.aggFuncsMap[AggFuncService_1.AGG_AVG] = aggAvg;
    this.initialised = true;
  }
  isAggFuncPossible(column, func) {
    const allKeys = this.getFuncNames(column);
    const allowed = _.includes(allKeys, func);
    const funcExists = _.exists(this.aggFuncsMap[func]);
    return allowed && funcExists;
  }
  getDefaultAggFunc(column) {
    const defaultAgg = column.getColDef().defaultAggFunc;
    if (_.exists(defaultAgg) && this.isAggFuncPossible(column, defaultAgg)) {
      return defaultAgg;
    }
    if (this.isAggFuncPossible(column, AggFuncService_1.AGG_SUM)) {
      return AggFuncService_1.AGG_SUM;
    }
    const allKeys = this.getFuncNames(column);
    return _.existsAndNotEmpty(allKeys) ? allKeys[0] : null;
  }
  addAggFuncs(aggFuncs) {
    _.iterateObject(aggFuncs, this.addAggFunc.bind(this));
  }
  addAggFunc(key, aggFunc) {
    this.init();
    this.aggFuncsMap[key] = aggFunc;
  }
  getAggFunc(name) {
    this.init();
    return this.aggFuncsMap[name];
  }
  getFuncNames(column) {
    const userAllowedFuncs = column.getColDef().allowedAggFuncs;
    return userAllowedFuncs == null ? Object.keys(this.aggFuncsMap).sort() : userAllowedFuncs;
  }
  clear() {
    this.aggFuncsMap = {};
  }
};
AggFuncService.AGG_SUM = "sum";
AggFuncService.AGG_FIRST = "first";
AggFuncService.AGG_LAST = "last";
AggFuncService.AGG_MIN = "min";
AggFuncService.AGG_MAX = "max";
AggFuncService.AGG_COUNT = "count";
AggFuncService.AGG_AVG = "avg";
__decorate12([
  PostConstruct
], AggFuncService.prototype, "init", null);
AggFuncService = AggFuncService_1 = __decorate12([
  Bean("aggFuncService")
], AggFuncService);
function aggSum(params) {
  const { values } = params;
  let result = null;
  for (let i = 0; i < values.length; i++) {
    const value = values[i];
    if (typeof value === "number") {
      if (result === null) {
        result = value;
      } else {
        if (AGBigInt) {
          result += typeof result === "number" ? value : AGBigInt(value);
        } else {
          result += value;
        }
      }
    } else if (typeof value === "bigint") {
      if (result === null) {
        result = value;
      } else {
        result = (typeof result === "bigint" ? result : AGBigInt(result)) + value;
      }
    }
  }
  return result;
}
function aggFirst(params) {
  return params.values.length > 0 ? params.values[0] : null;
}
function aggLast(params) {
  return params.values.length > 0 ? _.last(params.values) : null;
}
function aggMin(params) {
  const { values } = params;
  let result = null;
  for (let i = 0; i < values.length; i++) {
    const value = values[i];
    if ((typeof value === "number" || typeof value === "bigint") && (result === null || result > value)) {
      result = value;
    }
  }
  return result;
}
function aggMax(params) {
  const { values } = params;
  let result = null;
  for (let i = 0; i < values.length; i++) {
    const value = values[i];
    if ((typeof value === "number" || typeof value === "bigint") && (result === null || result < value)) {
      result = value;
    }
  }
  return result;
}
function aggCount(params) {
  var _a, _b;
  const { values } = params;
  let result = 0;
  for (let i = 0; i < values.length; i++) {
    const value = values[i];
    result += value != null && typeof value.value === "number" ? value.value : 1;
  }
  const existingAggData = (_b = (_a = params.rowNode) === null || _a === void 0 ? void 0 : _a.aggData) === null || _b === void 0 ? void 0 : _b[params.column.getColId()];
  if (existingAggData && existingAggData.value === result) {
    return existingAggData;
  }
  return {
    value: result,
    toString: function() {
      return this.value.toString();
    },
    // used for sorting
    toNumber: function() {
      return this.value;
    }
  };
}
function aggAvg(params) {
  var _a, _b, _c;
  const { values } = params;
  let sum = 0;
  let count = 0;
  for (let i = 0; i < values.length; i++) {
    const currentValue = values[i];
    let valueToAdd = null;
    if (typeof currentValue === "number" || typeof currentValue === "bigint") {
      valueToAdd = currentValue;
      count++;
    } else if (currentValue != null && (typeof currentValue.value === "number" || typeof currentValue.value === "bigint") && typeof currentValue.count === "number") {
      if (AGBigInt) {
        valueToAdd = currentValue.value * (typeof currentValue.value === "number" ? currentValue.count : AGBigInt(currentValue.count));
      } else {
        valueToAdd = currentValue.value * currentValue.count;
      }
      count += currentValue.count;
    }
    if (typeof valueToAdd === "number") {
      if (AGBigInt) {
        sum += typeof sum === "number" ? valueToAdd : AGBigInt(valueToAdd);
      } else {
        sum += valueToAdd;
      }
    } else if (typeof valueToAdd === "bigint") {
      sum = (typeof sum === "bigint" ? sum : AGBigInt(sum)) + valueToAdd;
    }
  }
  let value = null;
  if (count > 0) {
    if (AGBigInt) {
      value = sum / (typeof sum === "number" ? count : AGBigInt(count));
    } else {
      value = sum / count;
    }
  }
  const existingAggData = (_b = (_a = params.rowNode) === null || _a === void 0 ? void 0 : _a.aggData) === null || _b === void 0 ? void 0 : _b[(_c = params.column) === null || _c === void 0 ? void 0 : _c.getColId()];
  if (existingAggData && existingAggData.count === count && existingAggData.value === value) {
    return existingAggData;
  }
  return {
    count,
    value,
    // the grid by default uses toString to render values for an object, so this
    // is a trick to get the default cellRenderer to display the avg value
    toString: function() {
      return typeof this.value === "number" || typeof this.value === "bigint" ? this.value.toString() : "";
    },
    // used for sorting
    toNumber: function() {
      return this.value;
    }
  };
}

// ../../node_modules/@ag-grid-enterprise/row-grouping/dist/esm/es6/rowGrouping/columnDropZones/dropZoneColumnComp.mjs
var __decorate13 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
  else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var DropZoneColumnComp = class _DropZoneColumnComp extends Component {
  constructor(column, dragSourceDropTarget, ghost, dropZonePurpose, horizontal) {
    super();
    this.column = column;
    this.dragSourceDropTarget = dragSourceDropTarget;
    this.ghost = ghost;
    this.dropZonePurpose = dropZonePurpose;
    this.horizontal = horizontal;
    this.popupShowing = false;
  }
  init() {
    this.setTemplate(_DropZoneColumnComp.TEMPLATE);
    const eGui = this.getGui();
    const isFunctionsReadOnly = this.gridOptionsService.is("functionsReadOnly");
    this.addElementClasses(eGui);
    this.addElementClasses(this.eDragHandle, "drag-handle");
    this.addElementClasses(this.eText, "text");
    this.addElementClasses(this.eButton, "button");
    this.eDragHandle.appendChild(_.createIconNoSpan("columnDrag", this.gridOptionsService));
    this.eButton.appendChild(_.createIconNoSpan("cancel", this.gridOptionsService));
    this.setupSort();
    this.displayName = this.columnModel.getDisplayNameForColumn(this.column, "columnDrop");
    this.setupComponents();
    if (!this.ghost && !isFunctionsReadOnly) {
      this.addDragSource();
    }
    this.setupAria();
    this.addManagedListener(this.eventService, Column.EVENT_SORT_CHANGED, () => {
      this.setupAria();
    });
    this.setupTooltip();
    this.activateTabIndex();
  }
  setupAria() {
    const translate = this.localeService.getLocaleTextFunc();
    const { name, aggFuncName } = this.getColumnAndAggFuncName();
    const aggSeparator = translate("ariaDropZoneColumnComponentAggFuncSeparator", " of ");
    const sortDirection = {
      asc: translate("ariaDropZoneColumnComponentSortAscending", "ascending"),
      desc: translate("ariaDropZoneColumnComponentSortDescending", "descending")
    };
    const columnSort = this.column.getSort();
    const isSortSuppressed = this.gridOptionsService.is("rowGroupPanelSuppressSort");
    const ariaInstructions = [
      [
        aggFuncName && `${aggFuncName}${aggSeparator}`,
        name,
        this.isGroupingZone() && !isSortSuppressed && columnSort && `, ${sortDirection[columnSort]}`
      ].filter((part) => !!part).join("")
    ];
    const isFunctionsReadOnly = this.gridOptionsService.is("functionsReadOnly");
    if (this.isAggregationZone() && !isFunctionsReadOnly) {
      const aggregationMenuAria = translate("ariaDropZoneColumnValueItemDescription", "Press ENTER to change the aggregation type");
      ariaInstructions.push(aggregationMenuAria);
    }
    if (this.isGroupingZone() && this.column.getColDef().sortable && !isSortSuppressed) {
      const sortProgressAria = translate("ariaDropZoneColumnGroupItemDescription", "Press ENTER to sort");
      ariaInstructions.push(sortProgressAria);
    }
    const deleteAria = translate("ariaDropZoneColumnComponentDescription", "Press DELETE to remove");
    ariaInstructions.push(deleteAria);
    _.setAriaLabel(this.getGui(), ariaInstructions.join(". "));
  }
  setupTooltip() {
    const refresh = () => {
      const newTooltipText = this.column.getColDef().headerTooltip;
      this.setTooltip(newTooltipText);
    };
    refresh();
    this.addManagedListener(this.eventService, Events.EVENT_NEW_COLUMNS_LOADED, refresh);
  }
  setupSort() {
    const canSort = this.column.getColDef().sortable;
    const isGroupingZone = this.isGroupingZone();
    if (!canSort || !isGroupingZone) {
      return;
    }
    if (!this.gridOptionsService.is("rowGroupPanelSuppressSort")) {
      this.eSortIndicator.setupSort(this.column, true);
      const performSort = (event) => {
        event.preventDefault();
        const sortUsingCtrl = this.gridOptionsService.get("multiSortKey") === "ctrl";
        const multiSort = sortUsingCtrl ? event.ctrlKey || event.metaKey : event.shiftKey;
        this.sortController.progressSort(this.column, multiSort, "uiColumnSorted");
      };
      this.addGuiEventListener("click", performSort);
      this.addGuiEventListener("keydown", (e) => {
        const isEnter = e.key === KeyCode.ENTER;
        if (isEnter && this.isGroupingZone()) {
          performSort(e);
        }
      });
    }
  }
  addDragSource() {
    const dragSource = {
      type: DragSourceType.ToolPanel,
      eElement: this.eDragHandle,
      getDefaultIconName: () => DragAndDropService.ICON_HIDE,
      getDragItem: () => this.createDragItem(),
      dragItemName: this.displayName,
      dragSourceDropTarget: this.dragSourceDropTarget
    };
    this.dragAndDropService.addDragSource(dragSource, true);
    this.addDestroyFunc(() => this.dragAndDropService.removeDragSource(dragSource));
  }
  createDragItem() {
    const visibleState = {};
    visibleState[this.column.getId()] = this.column.isVisible();
    return {
      columns: [this.column],
      visibleState
    };
  }
  setupComponents() {
    this.setTextValue();
    this.setupRemove();
    if (this.ghost) {
      this.addCssClass("ag-column-drop-cell-ghost");
    }
    if (this.isAggregationZone() && !this.gridOptionsService.is("functionsReadOnly")) {
      this.addGuiEventListener("click", this.onShowAggFuncSelection.bind(this));
    }
  }
  setupRemove() {
    _.setDisplayed(this.eButton, !this.gridOptionsService.is("functionsReadOnly"));
    const agEvent = { type: _DropZoneColumnComp.EVENT_COLUMN_REMOVE };
    this.addGuiEventListener("keydown", (e) => {
      const isEnter = e.key === KeyCode.ENTER;
      const isDelete = e.key === KeyCode.DELETE;
      if (isDelete) {
        e.preventDefault();
        this.dispatchEvent(agEvent);
      }
      if (isEnter && this.isAggregationZone() && !this.gridOptionsService.is("functionsReadOnly")) {
        e.preventDefault();
        this.onShowAggFuncSelection();
      }
    });
    this.addManagedListener(this.eButton, "click", (mouseEvent) => {
      this.dispatchEvent(agEvent);
      mouseEvent.stopPropagation();
    });
    const touchListener = new TouchListener(this.eButton);
    this.addManagedListener(touchListener, TouchListener.EVENT_TAP, () => {
      this.dispatchEvent(agEvent);
    });
    this.addDestroyFunc(touchListener.destroy.bind(touchListener));
  }
  getColumnAndAggFuncName() {
    const name = this.displayName;
    let aggFuncName = "";
    if (this.isAggregationZone()) {
      const aggFunc = this.column.getAggFunc();
      const aggFuncString = typeof aggFunc === "string" ? aggFunc : "agg";
      const localeTextFunc = this.localeService.getLocaleTextFunc();
      aggFuncName = localeTextFunc(aggFuncString, aggFuncString);
    }
    return { name, aggFuncName };
  }
  setTextValue() {
    const { name, aggFuncName } = this.getColumnAndAggFuncName();
    const displayValue = this.isAggregationZone() ? `${aggFuncName}(${name})` : name;
    const displayValueSanitised = _.escapeString(displayValue);
    this.eText.innerHTML = displayValueSanitised;
  }
  onShowAggFuncSelection() {
    if (this.popupShowing) {
      return;
    }
    this.popupShowing = true;
    const virtualList = new VirtualList({ cssIdentifier: "select-agg-func" });
    const rows = this.aggFuncService.getFuncNames(this.column);
    const eGui = this.getGui();
    const virtualListGui = virtualList.getGui();
    virtualList.setModel({
      getRow: function(index) {
        return rows[index];
      },
      getRowCount: function() {
        return rows.length;
      }
    });
    this.getContext().createBean(virtualList);
    const ePopup = _.loadTemplate(
      /* html*/
      `<div class="ag-select-agg-func-popup"></div>`
    );
    ePopup.style.top = "0px";
    ePopup.style.left = "0px";
    ePopup.appendChild(virtualListGui);
    ePopup.style.width = `${eGui.clientWidth}px`;
    const focusoutListener = this.addManagedListener(ePopup, "focusout", (e) => {
      if (!ePopup.contains(e.relatedTarget) && addPopupRes) {
        addPopupRes.hideFunc();
      }
    });
    const popupHiddenFunc = (callbackEvent) => {
      this.destroyBean(virtualList);
      this.popupShowing = false;
      if ((callbackEvent === null || callbackEvent === void 0 ? void 0 : callbackEvent.key) === "Escape") {
        eGui.focus();
      }
      if (focusoutListener) {
        focusoutListener();
      }
    };
    const translate = this.localeService.getLocaleTextFunc();
    const addPopupRes = this.popupService.addPopup({
      modal: true,
      eChild: ePopup,
      closeOnEsc: true,
      closedCallback: popupHiddenFunc,
      ariaLabel: translate("ariaLabelAggregationFunction", "Aggregation Function")
    });
    if (addPopupRes) {
      virtualList.setComponentCreator(this.createAggSelect.bind(this, addPopupRes.hideFunc));
    }
    virtualList.addGuiEventListener("keydown", (e) => {
      if (e.key === KeyCode.ENTER || e.key === KeyCode.SPACE) {
        const row = virtualList.getLastFocusedRow();
        if (row == null) {
          return;
        }
        const comp = virtualList.getComponentAt(row);
        if (comp) {
          comp.selectItem();
        }
      }
    });
    this.popupService.positionPopupByComponent({
      type: "aggFuncSelect",
      eventSource: eGui,
      ePopup,
      keepWithinBounds: true,
      column: this.column,
      position: "under"
    });
    virtualList.refresh();
    let rowToFocus = rows.findIndex((r) => r === this.column.getAggFunc());
    if (rowToFocus === -1) {
      rowToFocus = 0;
    }
    virtualList.focusRow(rowToFocus);
  }
  createAggSelect(hidePopup, value) {
    const itemSelected = () => {
      hidePopup();
      if (this.gridOptionsService.is("functionsPassive")) {
        const event = {
          type: Events.EVENT_COLUMN_AGG_FUNC_CHANGE_REQUEST,
          columns: [this.column],
          aggFunc: value
        };
        this.eventService.dispatchEvent(event);
      } else {
        this.columnModel.setColumnAggFunc(this.column, value, "toolPanelDragAndDrop");
      }
    };
    const localeTextFunc = this.localeService.getLocaleTextFunc();
    const aggFuncString = value.toString();
    const aggFuncStringTranslated = localeTextFunc(aggFuncString, aggFuncString);
    const comp = new AggItemComp(itemSelected, aggFuncStringTranslated);
    return comp;
  }
  addElementClasses(el, suffix) {
    suffix = suffix ? `-${suffix}` : "";
    const direction = this.horizontal ? "horizontal" : "vertical";
    el.classList.add(`ag-column-drop-cell${suffix}`, `ag-column-drop-${direction}-cell${suffix}`);
  }
  isAggregationZone() {
    return this.dropZonePurpose === "aggregation";
  }
  isGroupingZone() {
    return this.dropZonePurpose === "rowGroup";
  }
};
DropZoneColumnComp.EVENT_COLUMN_REMOVE = "columnRemove";
DropZoneColumnComp.TEMPLATE = `<span role="option">
          <span ref="eDragHandle" class="ag-drag-handle ag-column-drop-cell-drag-handle" role="presentation"></span>
          <span ref="eText" class="ag-column-drop-cell-text" aria-hidden="true"></span>
          <ag-sort-indicator ref="eSortIndicator"></ag-sort-indicator>
          <span ref="eButton" class="ag-column-drop-cell-button" role="presentation"></span>
        </span>`;
__decorate13([
  Autowired("dragAndDropService")
], DropZoneColumnComp.prototype, "dragAndDropService", void 0);
__decorate13([
  Autowired("columnModel")
], DropZoneColumnComp.prototype, "columnModel", void 0);
__decorate13([
  Autowired("popupService")
], DropZoneColumnComp.prototype, "popupService", void 0);
__decorate13([
  Optional("aggFuncService")
], DropZoneColumnComp.prototype, "aggFuncService", void 0);
__decorate13([
  Autowired("sortController")
], DropZoneColumnComp.prototype, "sortController", void 0);
__decorate13([
  RefSelector("eText")
], DropZoneColumnComp.prototype, "eText", void 0);
__decorate13([
  RefSelector("eDragHandle")
], DropZoneColumnComp.prototype, "eDragHandle", void 0);
__decorate13([
  RefSelector("eButton")
], DropZoneColumnComp.prototype, "eButton", void 0);
__decorate13([
  RefSelector("eSortIndicator")
], DropZoneColumnComp.prototype, "eSortIndicator", void 0);
__decorate13([
  PostConstruct
], DropZoneColumnComp.prototype, "init", null);
var AggItemComp = class extends Component {
  constructor(itemSelected, value) {
    super(
      /* html */
      `<div class="ag-select-agg-func-item"/>`
    );
    this.selectItem = itemSelected;
    this.getGui().innerText = value;
    this.addGuiEventListener("click", this.selectItem);
  }
};

// ../../node_modules/@ag-grid-enterprise/row-grouping/dist/esm/es6/rowGrouping/columnDropZones/baseDropZonePanel.mjs
var __decorate14 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
  else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var BaseDropZonePanel = class _BaseDropZonePanel extends Component {
  constructor(horizontal, dropZonePurpose) {
    super(
      /* html */
      `<div class="ag-unselectable" role="presentation"></div>`
    );
    this.horizontal = horizontal;
    this.dropZonePurpose = dropZonePurpose;
    this.state = _BaseDropZonePanel.STATE_NOT_DRAGGING;
    this.guiDestroyFunctions = [];
    this.childColumnComponents = [];
    this.resizeEnabled = false;
    this.addElementClasses(this.getGui());
    this.eColumnDropList = document.createElement("div");
    this.addElementClasses(this.eColumnDropList, "list");
    _.setAriaRole(this.eColumnDropList, "listbox");
  }
  isHorizontal() {
    return this.horizontal;
  }
  toggleResizable(resizable) {
    this.positionableFeature.setResizable(resizable ? { bottom: true } : false);
    this.resizeEnabled = resizable;
  }
  setBeans(beans) {
    this.beans = beans;
  }
  destroy() {
    this.destroyGui();
    super.destroy();
  }
  destroyGui() {
    this.guiDestroyFunctions.forEach((func) => func());
    this.guiDestroyFunctions.length = 0;
    this.childColumnComponents.length = 0;
    _.clearElement(this.getGui());
    _.clearElement(this.eColumnDropList);
  }
  init(params) {
    this.params = params;
    this.createManagedBean(new ManagedFocusFeature(this.getFocusableElement(), {
      handleKeyDown: this.handleKeyDown.bind(this)
    }));
    this.addManagedListener(this.beans.eventService, Events.EVENT_NEW_COLUMNS_LOADED, this.refreshGui.bind(this));
    this.addManagedPropertyListener("functionsReadOnly", this.refreshGui.bind(this));
    this.setupDropTarget();
    this.positionableFeature = new PositionableFeature(this.getGui(), { minHeight: 100 });
    this.createManagedBean(this.positionableFeature);
    this.refreshGui();
    _.setAriaLabel(this.eColumnDropList, this.getAriaLabel());
  }
  handleKeyDown(e) {
    const isVertical = !this.horizontal;
    let isNext = e.key === KeyCode.DOWN;
    let isPrevious = e.key === KeyCode.UP;
    if (!isVertical) {
      const isRtl = this.gridOptionsService.is("enableRtl");
      isNext = !isRtl && e.key === KeyCode.RIGHT || isRtl && e.key === KeyCode.LEFT;
      isPrevious = !isRtl && e.key === KeyCode.LEFT || isRtl && e.key === KeyCode.RIGHT;
    }
    if (!isNext && !isPrevious) {
      return;
    }
    const el = this.focusService.findNextFocusableElement(this.getFocusableElement(), false, isPrevious);
    if (el) {
      e.preventDefault();
      el.focus();
    }
  }
  addElementClasses(el, suffix) {
    suffix = suffix ? `-${suffix}` : "";
    const direction = this.horizontal ? "horizontal" : "vertical";
    el.classList.add(`ag-column-drop${suffix}`, `ag-column-drop-${direction}${suffix}`);
  }
  setupDropTarget() {
    this.dropTarget = {
      getContainer: this.getGui.bind(this),
      getIconName: this.getIconName.bind(this),
      onDragging: this.onDragging.bind(this),
      onDragEnter: this.onDragEnter.bind(this),
      onDragLeave: this.onDragLeave.bind(this),
      onDragStop: this.onDragStop.bind(this),
      isInterestedIn: this.isInterestedIn.bind(this)
    };
    this.beans.dragAndDropService.addDropTarget(this.dropTarget);
  }
  isInterestedIn(type) {
    return type === DragSourceType.HeaderCell || type === DragSourceType.ToolPanel;
  }
  checkInsertIndex(draggingEvent) {
    const newIndex = this.getNewInsertIndex(draggingEvent);
    if (newIndex < 0) {
      return false;
    }
    const changed = newIndex !== this.insertIndex;
    if (changed) {
      this.insertIndex = newIndex;
    }
    return changed;
  }
  getNewInsertIndex(draggingEvent) {
    const mouseEvent = draggingEvent.event;
    const mouseLocation = this.horizontal ? mouseEvent.clientX : mouseEvent.clientY;
    const boundsList = this.childColumnComponents.map((col) => col.getGui().getBoundingClientRect());
    const hoveredIndex = boundsList.findIndex((rect) => this.horizontal ? rect.right > mouseLocation && rect.left < mouseLocation : rect.top < mouseLocation && rect.bottom > mouseLocation);
    if (hoveredIndex === -1) {
      const enableRtl = this.beans.gridOptionsService.is("enableRtl");
      const isLast = boundsList.every((rect) => mouseLocation > (this.horizontal ? rect.right : rect.bottom));
      if (isLast) {
        return enableRtl && this.horizontal ? 0 : this.childColumnComponents.length;
      }
      const isFirst = boundsList.every((rect) => mouseLocation < (this.horizontal ? rect.left : rect.top));
      if (isFirst) {
        return enableRtl && this.horizontal ? this.childColumnComponents.length : 0;
      }
      return this.insertIndex;
    }
    if (this.insertIndex <= hoveredIndex) {
      return hoveredIndex + 1;
    }
    return hoveredIndex;
  }
  checkDragStartedBySelf(draggingEvent) {
    if (this.state !== _BaseDropZonePanel.STATE_NOT_DRAGGING) {
      return;
    }
    this.state = _BaseDropZonePanel.STATE_REARRANGE_COLUMNS;
    this.potentialDndColumns = draggingEvent.dragSource.getDragItem().columns || [];
    this.refreshGui();
    this.checkInsertIndex(draggingEvent);
    this.refreshGui();
  }
  onDragging(draggingEvent) {
    this.checkDragStartedBySelf(draggingEvent);
    if (this.checkInsertIndex(draggingEvent)) {
      this.refreshGui();
    }
  }
  onDragEnter(draggingEvent) {
    const dragColumns = draggingEvent.dragSource.getDragItem().columns || [];
    this.state = _BaseDropZonePanel.STATE_NEW_COLUMNS_IN;
    const goodDragColumns = dragColumns.filter(this.isColumnDroppable.bind(this));
    if (goodDragColumns.length > 0) {
      const hideColumnOnExit = this.isRowGroupPanel() && !this.gridOptionsService.is("suppressRowGroupHidesColumns") && !draggingEvent.fromNudge;
      if (hideColumnOnExit) {
        const dragItem = draggingEvent.dragSource.getDragItem();
        const columns = dragItem.columns;
        this.setColumnsVisible(columns, false, "uiColumnDragged");
      }
      this.potentialDndColumns = goodDragColumns;
      this.checkInsertIndex(draggingEvent);
      this.refreshGui();
    }
  }
  setColumnsVisible(columns, visible, source = "api") {
    if (columns) {
      const allowedCols = columns.filter((c) => !c.getColDef().lockVisible);
      this.colModel.setColumnsVisible(allowedCols, visible, source);
    }
  }
  isPotentialDndColumns() {
    return _.existsAndNotEmpty(this.potentialDndColumns);
  }
  isRowGroupPanel() {
    return this.dropZonePurpose === "rowGroup";
  }
  onDragLeave(draggingEvent) {
    if (this.state === _BaseDropZonePanel.STATE_REARRANGE_COLUMNS) {
      const columns = draggingEvent.dragSource.getDragItem().columns || [];
      this.removeColumns(columns);
    }
    if (this.isPotentialDndColumns()) {
      const showColumnOnExit = this.isRowGroupPanel() && !this.gridOptionsService.is("suppressMakeColumnVisibleAfterUnGroup") && !draggingEvent.fromNudge;
      if (showColumnOnExit) {
        const dragItem = draggingEvent.dragSource.getDragItem();
        this.setColumnsVisible(dragItem.columns, true, "uiColumnDragged");
      }
      this.potentialDndColumns = [];
      this.refreshGui();
    }
    this.state = _BaseDropZonePanel.STATE_NOT_DRAGGING;
  }
  onDragStop() {
    if (this.isPotentialDndColumns()) {
      let success = false;
      if (this.state === _BaseDropZonePanel.STATE_NEW_COLUMNS_IN) {
        this.addColumns(this.potentialDndColumns);
        success = true;
      } else {
        success = this.rearrangeColumns(this.potentialDndColumns);
      }
      this.potentialDndColumns = [];
      if (!this.beans.gridOptionsService.is("functionsPassive") || !success) {
        this.refreshGui();
      }
    }
    this.state = _BaseDropZonePanel.STATE_NOT_DRAGGING;
  }
  removeColumns(columnsToRemove) {
    const newColumnList = this.getExistingColumns().filter((col) => !_.includes(columnsToRemove, col));
    this.updateColumns(newColumnList);
  }
  addColumns(columnsToAdd) {
    if (!columnsToAdd) {
      return;
    }
    const newColumnList = this.getExistingColumns().slice();
    const colsToAddNoDuplicates = columnsToAdd.filter((col) => newColumnList.indexOf(col) < 0);
    _.insertArrayIntoArray(newColumnList, colsToAddNoDuplicates, this.insertIndex);
    this.updateColumns(newColumnList);
  }
  rearrangeColumns(columnsToAdd) {
    const newColumnList = this.getNonGhostColumns().slice();
    _.insertArrayIntoArray(newColumnList, columnsToAdd, this.insertIndex);
    if (_.areEqual(newColumnList, this.getExistingColumns())) {
      return false;
    }
    this.updateColumns(newColumnList);
    return true;
  }
  refreshGui() {
    const scrollTop = this.eColumnDropList.scrollTop;
    const resizeEnabled = this.resizeEnabled;
    const focusedIndex = this.getFocusedItem();
    let alternateElement = this.focusService.findNextFocusableElement();
    if (!alternateElement) {
      alternateElement = this.focusService.findNextFocusableElement(void 0, false, true);
    }
    this.toggleResizable(false);
    this.destroyGui();
    this.addIconAndTitleToGui();
    this.addEmptyMessageToGui();
    this.addColumnsToGui();
    if (!this.isHorizontal()) {
      this.eColumnDropList.scrollTop = scrollTop;
    }
    if (resizeEnabled) {
      this.toggleResizable(resizeEnabled);
    }
    if (this.focusService.isKeyboardMode()) {
      this.restoreFocus(focusedIndex, alternateElement);
    }
  }
  getFocusedItem() {
    const eGui = this.getGui();
    const activeElement = this.gridOptionsService.getDocument().activeElement;
    if (!eGui.contains(activeElement)) {
      return -1;
    }
    const items = Array.from(eGui.querySelectorAll(".ag-column-drop-cell"));
    return items.indexOf(activeElement);
  }
  restoreFocus(index, alternateElement) {
    const eGui = this.getGui();
    const items = Array.from(eGui.querySelectorAll(".ag-column-drop-cell"));
    if (index === -1) {
      return;
    }
    if (items.length === 0) {
      alternateElement.focus();
    }
    const indexToFocus = Math.min(items.length - 1, index);
    const el = items[indexToFocus];
    if (el) {
      el.focus();
    }
  }
  getNonGhostColumns() {
    const existingColumns = this.getExistingColumns();
    if (this.isPotentialDndColumns()) {
      return existingColumns.filter((column) => !_.includes(this.potentialDndColumns, column));
    }
    return existingColumns;
  }
  addColumnsToGui() {
    const nonGhostColumns = this.getNonGhostColumns();
    const itemsToAddToGui = nonGhostColumns.map((column) => this.createColumnComponent(column, false));
    if (this.isPotentialDndColumns()) {
      const dndColumns = this.potentialDndColumns.map((column) => this.createColumnComponent(column, true));
      if (this.insertIndex >= itemsToAddToGui.length) {
        itemsToAddToGui.push(...dndColumns);
      } else {
        itemsToAddToGui.splice(this.insertIndex, 0, ...dndColumns);
      }
    }
    this.appendChild(this.eColumnDropList);
    itemsToAddToGui.forEach((columnComponent, index) => {
      if (index > 0) {
        this.addArrow(this.eColumnDropList);
      }
      this.eColumnDropList.appendChild(columnComponent.getGui());
    });
    this.addAriaLabelsToComponents();
  }
  addAriaLabelsToComponents() {
    this.childColumnComponents.forEach((comp, idx) => {
      const eGui = comp.getGui();
      _.setAriaPosInSet(eGui, idx + 1);
      _.setAriaSetSize(eGui, this.childColumnComponents.length);
    });
  }
  createColumnComponent(column, ghost) {
    const columnComponent = new DropZoneColumnComp(column, this.dropTarget, ghost, this.dropZonePurpose, this.horizontal);
    columnComponent.addEventListener(DropZoneColumnComp.EVENT_COLUMN_REMOVE, this.removeColumns.bind(this, [column]));
    this.beans.context.createBean(columnComponent);
    this.guiDestroyFunctions.push(() => this.destroyBean(columnComponent));
    if (!ghost) {
      this.childColumnComponents.push(columnComponent);
    }
    return columnComponent;
  }
  addIconAndTitleToGui() {
    const eGroupIcon = this.params.icon;
    const eTitleBar = document.createElement("div");
    _.setAriaHidden(eTitleBar, true);
    this.addElementClasses(eTitleBar, "title-bar");
    this.addElementClasses(eGroupIcon, "icon");
    this.addOrRemoveCssClass("ag-column-drop-empty", this.isExistingColumnsEmpty());
    eTitleBar.appendChild(eGroupIcon);
    if (!this.horizontal) {
      const eTitle = document.createElement("span");
      this.addElementClasses(eTitle, "title");
      eTitle.innerHTML = this.params.title;
      eTitleBar.appendChild(eTitle);
    }
    this.appendChild(eTitleBar);
  }
  isExistingColumnsEmpty() {
    return this.getExistingColumns().length === 0;
  }
  addEmptyMessageToGui() {
    if (!this.isExistingColumnsEmpty() || this.isPotentialDndColumns()) {
      return;
    }
    const eMessage = document.createElement("span");
    eMessage.innerHTML = this.params.emptyMessage;
    this.addElementClasses(eMessage, "empty-message");
    this.eColumnDropList.appendChild(eMessage);
  }
  addArrow(eParent) {
    if (this.horizontal) {
      const enableRtl = this.beans.gridOptionsService.is("enableRtl");
      const icon = _.createIconNoSpan(enableRtl ? "smallLeft" : "smallRight", this.beans.gridOptionsService);
      this.addElementClasses(icon, "cell-separator");
      eParent.appendChild(icon);
    }
  }
};
BaseDropZonePanel.STATE_NOT_DRAGGING = "notDragging";
BaseDropZonePanel.STATE_NEW_COLUMNS_IN = "newColumnsIn";
BaseDropZonePanel.STATE_REARRANGE_COLUMNS = "rearrangeColumns";
__decorate14([
  Autowired("columnModel")
], BaseDropZonePanel.prototype, "colModel", void 0);
__decorate14([
  Autowired("focusService")
], BaseDropZonePanel.prototype, "focusService", void 0);

// ../../node_modules/@ag-grid-enterprise/row-grouping/dist/esm/es6/rowGrouping/columnDropZones/rowGroupDropZonePanel.mjs
var __decorate15 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
  else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var RowGroupDropZonePanel = class extends BaseDropZonePanel {
  constructor(horizontal) {
    super(horizontal, "rowGroup");
  }
  passBeansUp() {
    super.setBeans({
      gridOptionsService: this.gridOptionsService,
      eventService: this.eventService,
      context: this.getContext(),
      loggerFactory: this.loggerFactory,
      dragAndDropService: this.dragAndDropService
    });
    const localeTextFunc = this.localeService.getLocaleTextFunc();
    const emptyMessage = localeTextFunc("rowGroupColumnsEmptyMessage", "Drag here to set row groups");
    const title = localeTextFunc("groups", "Row Groups");
    super.init({
      dragAndDropIcon: DragAndDropService.ICON_GROUP,
      icon: _.createIconNoSpan("rowGroupPanel", this.gridOptionsService, null),
      emptyMessage,
      title
    });
    this.addManagedListener(this.eventService, Events.EVENT_COLUMN_ROW_GROUP_CHANGED, this.refreshGui.bind(this));
  }
  getAriaLabel() {
    const translate = this.localeService.getLocaleTextFunc();
    const label = translate("ariaRowGroupDropZonePanelLabel", "Row Groups");
    return label;
  }
  getTooltipParams() {
    const res = super.getTooltipParams();
    res.location = "rowGroupColumnsList";
    return res;
  }
  isColumnDroppable(column) {
    if (this.gridOptionsService.is("functionsReadOnly") || !column.isPrimary()) {
      return false;
    }
    return column.isAllowRowGroup() && !column.isRowGroupActive();
  }
  updateColumns(columns) {
    if (this.gridOptionsService.is("functionsPassive")) {
      const event = {
        type: Events.EVENT_COLUMN_ROW_GROUP_CHANGE_REQUEST,
        columns
      };
      this.eventService.dispatchEvent(event);
    } else {
      this.columnModel.setRowGroupColumns(columns, "toolPanelUi");
    }
  }
  getIconName() {
    return this.isPotentialDndColumns() ? DragAndDropService.ICON_GROUP : DragAndDropService.ICON_NOT_ALLOWED;
  }
  getExistingColumns() {
    return this.columnModel.getRowGroupColumns();
  }
};
__decorate15([
  Autowired("columnModel")
], RowGroupDropZonePanel.prototype, "columnModel", void 0);
__decorate15([
  Autowired("loggerFactory")
], RowGroupDropZonePanel.prototype, "loggerFactory", void 0);
__decorate15([
  Autowired("dragAndDropService")
], RowGroupDropZonePanel.prototype, "dragAndDropService", void 0);
__decorate15([
  PostConstruct
], RowGroupDropZonePanel.prototype, "passBeansUp", null);

// ../../node_modules/@ag-grid-enterprise/row-grouping/dist/esm/es6/rowGrouping/columnDropZones/pivotDropZonePanel.mjs
var __decorate16 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
  else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var PivotDropZonePanel = class extends BaseDropZonePanel {
  constructor(horizontal) {
    super(horizontal, "pivot");
  }
  passBeansUp() {
    super.setBeans({
      gridOptionsService: this.gridOptionsService,
      eventService: this.eventService,
      context: this.getContext(),
      loggerFactory: this.loggerFactory,
      dragAndDropService: this.dragAndDropService
    });
    const localeTextFunc = this.localeService.getLocaleTextFunc();
    const emptyMessage = localeTextFunc("pivotColumnsEmptyMessage", "Drag here to set column labels");
    const title = localeTextFunc("pivots", "Column Labels");
    super.init({
      dragAndDropIcon: DragAndDropService.ICON_GROUP,
      icon: _.createIconNoSpan("pivotPanel", this.gridOptionsService, null),
      emptyMessage,
      title
    });
    this.addManagedListener(this.eventService, Events.EVENT_NEW_COLUMNS_LOADED, this.refresh.bind(this));
    this.addManagedListener(this.eventService, Events.EVENT_COLUMN_PIVOT_CHANGED, this.refresh.bind(this));
    this.addManagedListener(this.eventService, Events.EVENT_COLUMN_PIVOT_MODE_CHANGED, this.checkVisibility.bind(this));
    this.refresh();
  }
  getAriaLabel() {
    const translate = this.localeService.getLocaleTextFunc();
    const label = translate("ariaPivotDropZonePanelLabel", "Column Labels");
    return label;
  }
  getTooltipParams() {
    const res = super.getTooltipParams();
    res.location = "pivotColumnsList";
    return res;
  }
  refresh() {
    this.checkVisibility();
    this.refreshGui();
  }
  checkVisibility() {
    const pivotMode = this.columnModel.isPivotMode();
    if (this.isHorizontal()) {
      switch (this.gridOptionsService.get("pivotPanelShow")) {
        case "always":
          this.setDisplayed(pivotMode);
          break;
        case "onlyWhenPivoting":
          const pivotActive = this.columnModel.isPivotActive();
          this.setDisplayed(pivotMode && pivotActive);
          break;
        default:
          this.setDisplayed(false);
          break;
      }
    } else {
      this.setDisplayed(pivotMode);
    }
  }
  isColumnDroppable(column) {
    if (this.gridOptionsService.is("functionsReadOnly") || !column.isPrimary()) {
      return false;
    }
    return column.isAllowPivot() && !column.isPivotActive();
  }
  updateColumns(columns) {
    if (this.gridOptionsService.is("functionsPassive")) {
      const event = {
        type: Events.EVENT_COLUMN_PIVOT_CHANGE_REQUEST,
        columns
      };
      this.eventService.dispatchEvent(event);
    } else {
      this.columnModel.setPivotColumns(columns, "toolPanelUi");
    }
  }
  getIconName() {
    return this.isPotentialDndColumns() ? DragAndDropService.ICON_PIVOT : DragAndDropService.ICON_NOT_ALLOWED;
  }
  getExistingColumns() {
    return this.columnModel.getPivotColumns();
  }
};
__decorate16([
  Autowired("columnModel")
], PivotDropZonePanel.prototype, "columnModel", void 0);
__decorate16([
  Autowired("loggerFactory")
], PivotDropZonePanel.prototype, "loggerFactory", void 0);
__decorate16([
  Autowired("dragAndDropService")
], PivotDropZonePanel.prototype, "dragAndDropService", void 0);
__decorate16([
  PostConstruct
], PivotDropZonePanel.prototype, "passBeansUp", null);

// ../../node_modules/@ag-grid-enterprise/row-grouping/dist/esm/es6/rowGrouping/columnDropZones/gridHeaderDropZones.mjs
var __decorate17 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
  else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var GridHeaderDropZones = class extends Component {
  constructor() {
    super();
  }
  postConstruct() {
    this.setGui(this.createNorthPanel());
    this.addManagedListener(this.eventService, Events.EVENT_COLUMN_ROW_GROUP_CHANGED, this.onRowGroupChanged.bind(this));
    this.addManagedListener(this.eventService, Events.EVENT_NEW_COLUMNS_LOADED, this.onRowGroupChanged.bind(this));
    this.addManagedPropertyListener("rowGroupPanelShow", this.onRowGroupChanged.bind(this));
    this.onRowGroupChanged();
  }
  createNorthPanel() {
    const topPanelGui = document.createElement("div");
    const dropPanelVisibleListener = this.onDropPanelVisible.bind(this);
    topPanelGui.classList.add("ag-column-drop-wrapper");
    _.setAriaRole(topPanelGui, "presentation");
    this.rowGroupComp = new RowGroupDropZonePanel(true);
    this.createManagedBean(this.rowGroupComp);
    this.pivotComp = new PivotDropZonePanel(true);
    this.createManagedBean(this.pivotComp);
    topPanelGui.appendChild(this.rowGroupComp.getGui());
    topPanelGui.appendChild(this.pivotComp.getGui());
    this.addManagedListener(this.rowGroupComp, Component.EVENT_DISPLAYED_CHANGED, dropPanelVisibleListener);
    this.addManagedListener(this.pivotComp, Component.EVENT_DISPLAYED_CHANGED, dropPanelVisibleListener);
    this.onDropPanelVisible();
    return topPanelGui;
  }
  onDropPanelVisible() {
    const bothDisplayed = this.rowGroupComp.isDisplayed() && this.pivotComp.isDisplayed();
    this.rowGroupComp.addOrRemoveCssClass("ag-column-drop-horizontal-half-width", bothDisplayed);
    this.pivotComp.addOrRemoveCssClass("ag-column-drop-horizontal-half-width", bothDisplayed);
  }
  onRowGroupChanged() {
    if (!this.rowGroupComp) {
      return;
    }
    const rowGroupPanelShow = this.gridOptionsService.get("rowGroupPanelShow");
    if (rowGroupPanelShow === "always") {
      this.rowGroupComp.setDisplayed(true);
    } else if (rowGroupPanelShow === "onlyWhenGrouping") {
      const grouping = !this.columnModel.isRowGroupEmpty();
      this.rowGroupComp.setDisplayed(grouping);
    } else {
      this.rowGroupComp.setDisplayed(false);
    }
  }
};
__decorate17([
  Autowired("columnModel")
], GridHeaderDropZones.prototype, "columnModel", void 0);
__decorate17([
  PostConstruct
], GridHeaderDropZones.prototype, "postConstruct", null);

// ../../node_modules/@ag-grid-enterprise/row-grouping/dist/esm/es6/rowGrouping/filterAggregatesStage.mjs
var __decorate18 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
  else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var FilterAggregatesStage = class FilterAggregatesStage2 extends BeanStub {
  execute(params) {
    const isPivotMode = this.columnModel.isPivotMode();
    const isAggFilterActive = this.filterManager.isAggregateFilterPresent() || this.filterManager.isAggregateQuickFilterPresent();
    const defaultPrimaryColumnPredicate = (params2) => !params2.node.group;
    const defaultSecondaryColumnPredicate = (params2) => params2.node.leafGroup;
    const applyFilterToNode = this.gridOptionsService.getGroupAggFiltering() || (isPivotMode ? defaultSecondaryColumnPredicate : defaultPrimaryColumnPredicate);
    const { changedPath } = params;
    const preserveChildren = (node, recursive = false) => {
      if (node.childrenAfterFilter) {
        node.childrenAfterAggFilter = node.childrenAfterFilter;
        if (recursive) {
          node.childrenAfterAggFilter.forEach((child) => preserveChildren(child, recursive));
        }
        this.setAllChildrenCount(node);
      }
      if (node.sibling) {
        node.sibling.childrenAfterAggFilter = node.childrenAfterAggFilter;
      }
    };
    const filterChildren = (node) => {
      var _a;
      node.childrenAfterAggFilter = ((_a = node.childrenAfterFilter) === null || _a === void 0 ? void 0 : _a.filter((child) => {
        var _a2;
        const shouldFilterRow = applyFilterToNode({ node: child });
        if (shouldFilterRow) {
          const doesNodePassFilter = this.filterManager.doesRowPassAggregateFilters({ rowNode: child });
          if (doesNodePassFilter) {
            preserveChildren(child, true);
            return true;
          }
        }
        const hasChildPassed = (_a2 = child.childrenAfterAggFilter) === null || _a2 === void 0 ? void 0 : _a2.length;
        return hasChildPassed;
      })) || null;
      this.setAllChildrenCount(node);
      if (node.sibling) {
        node.sibling.childrenAfterAggFilter = node.childrenAfterAggFilter;
      }
    };
    changedPath.forEachChangedNodeDepthFirst(isAggFilterActive ? filterChildren : preserveChildren, true);
  }
  setAllChildrenCountTreeData(rowNode) {
    let allChildrenCount = 0;
    rowNode.childrenAfterAggFilter.forEach((child) => {
      allChildrenCount++;
      allChildrenCount += child.allChildrenCount;
    });
    rowNode.setAllChildrenCount(allChildrenCount);
  }
  setAllChildrenCountGridGrouping(rowNode) {
    let allChildrenCount = 0;
    rowNode.childrenAfterAggFilter.forEach((child) => {
      if (child.group) {
        allChildrenCount += child.allChildrenCount;
      } else {
        allChildrenCount++;
      }
    });
    rowNode.setAllChildrenCount(allChildrenCount);
  }
  setAllChildrenCount(rowNode) {
    if (!rowNode.hasChildren()) {
      rowNode.setAllChildrenCount(null);
      return;
    }
    if (this.gridOptionsService.is("treeData")) {
      this.setAllChildrenCountTreeData(rowNode);
    } else {
      this.setAllChildrenCountGridGrouping(rowNode);
    }
  }
};
__decorate18([
  Autowired("filterManager")
], FilterAggregatesStage.prototype, "filterManager", void 0);
__decorate18([
  Autowired("columnModel")
], FilterAggregatesStage.prototype, "columnModel", void 0);
FilterAggregatesStage = __decorate18([
  Bean("filterAggregatesStage")
], FilterAggregatesStage);

// ../../node_modules/@ag-grid-enterprise/row-grouping/dist/esm/es6/version.mjs
var VERSION = "30.2.1";

// ../../node_modules/@ag-grid-enterprise/row-grouping/dist/esm/es6/rowGrouping/groupFilter/groupFilter.mjs
var __decorate19 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
  else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var GroupFilter = class _GroupFilter extends TabGuardComp {
  constructor() {
    super(
      /* html */
      `
            <div class="ag-group-filter">
                <div ref="eGroupField"></div>
                <div ref="eUnderlyingFilter"></div>
            </div>
        `
    );
  }
  postConstruct() {
    this.initialiseTabGuard({});
  }
  init(params) {
    this.params = params;
    this.validateParams();
    return this.updateGroups().then(() => {
      this.addManagedListener(this.eventService, Events.EVENT_COLUMN_ROW_GROUP_CHANGED, () => this.onColumnRowGroupChanged());
    });
  }
  validateParams() {
    const { colDef } = this.params;
    if (colDef.field) {
      _.doOnce(() => console.warn('AG Grid: Group Column Filter does not work with the colDef property "field". This property will be ignored.'), "groupFilterFieldParam");
    }
    if (colDef.filterValueGetter) {
      _.doOnce(() => console.warn('AG Grid: Group Column Filter does not work with the colDef property "filterValueGetter". This property will be ignored.'), "groupFilterFilterValueGetterParam");
    }
    if (colDef.filterParams) {
      _.doOnce(() => console.warn('AG Grid: Group Column Filter does not work with the colDef property "filterParams". This property will be ignored.'), "groupFilterFilterParams");
    }
  }
  updateGroups() {
    const sourceColumns = this.updateGroupField();
    return this.getUnderlyingFilters(sourceColumns);
  }
  getSourceColumns() {
    this.groupColumn = this.params.column;
    if (this.gridOptionsService.is("treeData")) {
      _.doOnce(() => console.warn("AG Grid: Group Column Filter does not work with Tree Data enabled. Please disable Tree Data, or use a different filter."), "groupFilterTreeData");
      return [];
    }
    const sourceColumns = this.columnModel.getSourceColumnsForGroupColumn(this.groupColumn);
    if (!sourceColumns) {
      _.doOnce(() => console.warn("AG Grid: Group Column Filter only works on group columns. Please use a different filter."), "groupFilterNotGroupColumn");
      return [];
    }
    return sourceColumns;
  }
  updateGroupField() {
    _.clearElement(this.eGroupField);
    if (this.eGroupFieldSelect) {
      this.destroyBean(this.eGroupFieldSelect);
    }
    const allSourceColumns = this.getSourceColumns();
    const sourceColumns = allSourceColumns.filter((sourceColumn) => sourceColumn.isFilterAllowed());
    if (!sourceColumns.length) {
      this.selectedColumn = void 0;
      _.setDisplayed(this.eGroupField, false);
      return null;
    }
    if (allSourceColumns.length === 1) {
      this.selectedColumn = sourceColumns[0];
      _.setDisplayed(this.eGroupField, false);
    } else {
      if (!this.selectedColumn || !sourceColumns.some((column) => column.getId() === this.selectedColumn.getId())) {
        this.selectedColumn = sourceColumns[0];
      }
      this.createGroupFieldSelectElement(sourceColumns);
      this.eGroupField.appendChild(this.eGroupFieldSelect.getGui());
      this.eGroupField.appendChild(_.loadTemplate(
        /* html */
        `<div class="ag-filter-separator"></div>`
      ));
      _.setDisplayed(this.eGroupField, true);
    }
    return sourceColumns;
  }
  createGroupFieldSelectElement(sourceColumns) {
    this.eGroupFieldSelect = this.createManagedBean(new AgSelect());
    const localeTextFunc = this.localeService.getLocaleTextFunc();
    this.eGroupFieldSelect.setLabel(localeTextFunc("groupFilterSelect", "Select field:"));
    this.eGroupFieldSelect.setLabelAlignment("top");
    this.eGroupFieldSelect.addOptions(sourceColumns.map((sourceColumn) => {
      var _a;
      return {
        value: sourceColumn.getId(),
        text: (_a = this.columnModel.getDisplayNameForColumn(sourceColumn, "groupFilter", false)) !== null && _a !== void 0 ? _a : void 0
      };
    }));
    this.eGroupFieldSelect.setValue(this.selectedColumn.getId());
    this.eGroupFieldSelect.onValueChange((newValue) => this.updateSelectedColumn(newValue));
    this.eGroupFieldSelect.addCssClass("ag-group-filter-field-select-wrapper");
    if (sourceColumns.length === 1) {
      this.eGroupFieldSelect.setDisabled(true);
    }
  }
  getUnderlyingFilters(sourceColumns) {
    if (!sourceColumns) {
      this.filterColumnPairs = void 0;
      this.selectedFilter = void 0;
      this.groupColumn.setFilterActive(false, "columnRowGroupChanged");
      return AgPromise.resolve();
    }
    const filterPromises = [];
    const filterColumnPairs = [];
    sourceColumns.forEach((column) => {
      const filterWrapper = this.filterManager.getOrCreateFilterWrapper(column, "COLUMN_MENU");
      if (filterWrapper === null || filterWrapper === void 0 ? void 0 : filterWrapper.filterPromise) {
        filterPromises.push(filterWrapper.filterPromise.then((filter) => {
          if (filter) {
            filterColumnPairs.push({
              filter,
              column
            });
          }
          if (column.getId() === this.selectedColumn.getId()) {
            this.selectedFilter = filter !== null && filter !== void 0 ? filter : void 0;
          }
          return filter;
        }));
      }
    });
    return AgPromise.all(filterPromises).then(() => {
      this.filterColumnPairs = filterColumnPairs;
      this.groupColumn.setFilterActive(this.isFilterActive(), "columnRowGroupChanged");
    });
  }
  addUnderlyingFilterElement() {
    _.clearElement(this.eUnderlyingFilter);
    if (!this.selectedColumn) {
      return AgPromise.resolve();
    }
    const filterWrapper = this.filterManager.getOrCreateFilterWrapper(this.selectedColumn, "COLUMN_MENU");
    if (!filterWrapper) {
      return AgPromise.resolve();
    }
    return filterWrapper.guiPromise.then((gui) => {
      var _a;
      this.eUnderlyingFilter.appendChild(gui);
      (_a = filterWrapper.filterPromise) === null || _a === void 0 ? void 0 : _a.then((filter) => {
        var _a2, _b;
        (_a2 = filter === null || filter === void 0 ? void 0 : filter.afterGuiAttached) === null || _a2 === void 0 ? void 0 : _a2.call(filter, this.afterGuiAttachedParams);
        if (!((_b = this.afterGuiAttachedParams) === null || _b === void 0 ? void 0 : _b.suppressFocus) && this.eGroupFieldSelect && !this.eGroupFieldSelect.isDisabled()) {
          this.eGroupFieldSelect.getFocusableElement().focus();
        }
      });
    });
  }
  updateSelectedColumn(columnId) {
    var _a, _b;
    if (!columnId) {
      return;
    }
    (_b = (_a = this.selectedFilter) === null || _a === void 0 ? void 0 : _a.afterGuiDetached) === null || _b === void 0 ? void 0 : _b.call(_a);
    const selectedFilterColumnPair = this.getFilterColumnPair(columnId);
    this.selectedColumn = selectedFilterColumnPair === null || selectedFilterColumnPair === void 0 ? void 0 : selectedFilterColumnPair.column;
    this.selectedFilter = selectedFilterColumnPair === null || selectedFilterColumnPair === void 0 ? void 0 : selectedFilterColumnPair.filter;
    this.dispatchEvent({
      type: _GroupFilter.EVENT_SELECTED_COLUMN_CHANGED
    });
    this.addUnderlyingFilterElement();
  }
  isFilterActive() {
    var _a;
    return !!((_a = this.filterColumnPairs) === null || _a === void 0 ? void 0 : _a.some(({ filter }) => filter.isFilterActive()));
  }
  doesFilterPass() {
    return true;
  }
  getModel() {
    return null;
  }
  setModel() {
    return AgPromise.resolve();
  }
  afterGuiAttached(params) {
    this.afterGuiAttachedParams = params;
    this.addUnderlyingFilterElement();
  }
  afterGuiDetached() {
    var _a, _b;
    _.clearElement(this.eUnderlyingFilter);
    (_b = (_a = this.selectedFilter) === null || _a === void 0 ? void 0 : _a.afterGuiDetached) === null || _b === void 0 ? void 0 : _b.call(_a);
  }
  onColumnRowGroupChanged() {
    this.updateGroups().then(() => {
      this.dispatchEvent({
        type: _GroupFilter.EVENT_COLUMN_ROW_GROUP_CHANGED
      });
      this.eventService.dispatchEvent({
        type: "filterAllowedUpdated"
      });
    });
  }
  getFilterColumnPair(columnId) {
    var _a;
    if (!columnId) {
      return void 0;
    }
    return (_a = this.filterColumnPairs) === null || _a === void 0 ? void 0 : _a.find(({ column }) => column.getId() === columnId);
  }
  getSelectedFilter() {
    return this.selectedFilter;
  }
  getSelectedColumn() {
    return this.selectedColumn;
  }
  isFilterAllowed() {
    return !!this.selectedColumn;
  }
  destroy() {
    super.destroy();
  }
};
GroupFilter.EVENT_COLUMN_ROW_GROUP_CHANGED = "columnRowGroupChanged";
GroupFilter.EVENT_SELECTED_COLUMN_CHANGED = "selectedColumnChanged";
__decorate19([
  Autowired("filterManager")
], GroupFilter.prototype, "filterManager", void 0);
__decorate19([
  Autowired("columnModel")
], GroupFilter.prototype, "columnModel", void 0);
__decorate19([
  RefSelector("eGroupField")
], GroupFilter.prototype, "eGroupField", void 0);
__decorate19([
  RefSelector("eUnderlyingFilter")
], GroupFilter.prototype, "eUnderlyingFilter", void 0);
__decorate19([
  PostConstruct
], GroupFilter.prototype, "postConstruct", null);

// ../../node_modules/@ag-grid-enterprise/row-grouping/dist/esm/es6/rowGrouping/groupFilter/groupFloatingFilter.mjs
var __decorate20 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
  else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var GroupFloatingFilterComp = class extends Component {
  constructor() {
    super(
      /* html */
      `
            <div ref="eFloatingFilter" class="ag-group-floating-filter ag-floating-filter-input" role="presentation"></div>
        `
    );
    this.haveAddedColumnListeners = false;
  }
  init(params) {
    this.params = params;
    const canShowUnderlyingFloatingFilter = this.gridOptionsService.get("groupDisplayType") === "multipleColumns";
    return new AgPromise((resolve) => {
      this.params.parentFilterInstance((parentFilterInstance) => {
        this.parentFilterInstance = parentFilterInstance;
        if (canShowUnderlyingFloatingFilter) {
          this.setupUnderlyingFloatingFilterElement().then(() => resolve());
        } else {
          this.setupReadOnlyFloatingFilterElement();
          resolve();
        }
      });
    }).then(() => {
      this.addManagedListener(this.parentFilterInstance, GroupFilter.EVENT_SELECTED_COLUMN_CHANGED, () => this.onSelectedColumnChanged());
      this.addManagedListener(this.parentFilterInstance, GroupFilter.EVENT_COLUMN_ROW_GROUP_CHANGED, () => this.onColumnRowGroupChanged());
    });
  }
  onParamsUpdated(params) {
    this.params = params;
    this.setParams();
  }
  setParams() {
    var _a;
    const displayName = this.columnModel.getDisplayNameForColumn(this.params.column, "header", true);
    const translate = this.localeService.getLocaleTextFunc();
    (_a = this.eFloatingFilterText) === null || _a === void 0 ? void 0 : _a.setInputAriaLabel(`${displayName} ${translate("ariaFilterInput", "Filter Input")}`);
  }
  setupReadOnlyFloatingFilterElement() {
    if (!this.eFloatingFilterText) {
      this.eFloatingFilterText = this.createManagedBean(new AgInputTextField());
      this.eFloatingFilterText.setDisabled(true).addGuiEventListener("click", () => this.params.showParentFilter());
      this.setParams();
    }
    this.updateDisplayedValue();
    this.eFloatingFilter.appendChild(this.eFloatingFilterText.getGui());
  }
  setupUnderlyingFloatingFilterElement() {
    this.showingUnderlyingFloatingFilter = false;
    this.underlyingFloatingFilter = void 0;
    _.clearElement(this.eFloatingFilter);
    const column = this.parentFilterInstance.getSelectedColumn();
    if (column && !column.isVisible()) {
      const compDetails = this.filterManager.getFloatingFilterCompDetails(column, this.params.showParentFilter);
      if (compDetails) {
        this.compDetails = compDetails;
        if (!this.haveAddedColumnListeners) {
          this.haveAddedColumnListeners = true;
          this.addManagedListener(column, Column.EVENT_VISIBLE_CHANGED, this.onColumnVisibleChanged.bind(this));
          this.addManagedListener(column, Column.EVENT_COL_DEF_CHANGED, this.onColDefChanged.bind(this));
        }
        return compDetails.newAgStackInstance().then((floatingFilter) => {
          var _a, _b;
          this.underlyingFloatingFilter = floatingFilter;
          (_a = this.underlyingFloatingFilter) === null || _a === void 0 ? void 0 : _a.onParentModelChanged((_b = this.parentFilterInstance.getSelectedFilter()) === null || _b === void 0 ? void 0 : _b.getModel());
          this.appendChild(floatingFilter.getGui());
          this.showingUnderlyingFloatingFilter = true;
        });
      }
    }
    this.setupReadOnlyFloatingFilterElement();
    return AgPromise.resolve();
  }
  onColumnVisibleChanged() {
    this.setupUnderlyingFloatingFilterElement();
  }
  onColDefChanged(event) {
    var _a, _b;
    if (!event.column) {
      return;
    }
    const compDetails = this.filterManager.getFloatingFilterCompDetails(event.column, this.params.showParentFilter);
    if (compDetails) {
      (_b = (_a = this.underlyingFloatingFilter) === null || _a === void 0 ? void 0 : _a.onParamsUpdated) === null || _b === void 0 ? void 0 : _b.call(_a, compDetails.params);
    }
  }
  onParentModelChanged(_model, event) {
    var _a, _b;
    if (this.showingUnderlyingFloatingFilter) {
      (_a = this.underlyingFloatingFilter) === null || _a === void 0 ? void 0 : _a.onParentModelChanged((_b = this.parentFilterInstance.getSelectedFilter()) === null || _b === void 0 ? void 0 : _b.getModel(), event);
    } else {
      this.updateDisplayedValue();
    }
  }
  updateDisplayedValue() {
    if (!this.parentFilterInstance || !this.eFloatingFilterText) {
      return;
    }
    const selectedFilter = this.parentFilterInstance.getSelectedFilter();
    if (!selectedFilter) {
      this.eFloatingFilterText.setValue("");
      this.eFloatingFilterText.setDisplayed(false);
      return;
    }
    this.eFloatingFilterText.setDisplayed(true);
    if (selectedFilter.getModelAsString) {
      const filterModel = selectedFilter.getModel();
      this.eFloatingFilterText.setValue(filterModel == null ? "" : selectedFilter.getModelAsString(filterModel));
    } else {
      this.eFloatingFilterText.setValue("");
    }
  }
  onSelectedColumnChanged() {
    if (!this.showingUnderlyingFloatingFilter) {
      this.updateDisplayedValue();
    }
  }
  onColumnRowGroupChanged() {
    if (!this.showingUnderlyingFloatingFilter) {
      this.updateDisplayedValue();
    }
  }
  destroy() {
    super.destroy();
  }
};
__decorate20([
  Autowired("columnModel")
], GroupFloatingFilterComp.prototype, "columnModel", void 0);
__decorate20([
  Autowired("filterManager")
], GroupFloatingFilterComp.prototype, "filterManager", void 0);
__decorate20([
  RefSelector("eFloatingFilter")
], GroupFloatingFilterComp.prototype, "eFloatingFilter", void 0);

// ../../node_modules/@ag-grid-enterprise/row-grouping/dist/esm/es6/rowGroupingModule.mjs
var RowGroupingModule = {
  version: VERSION,
  moduleName: ModuleNames.RowGroupingModule,
  beans: [AggregationStage, FilterAggregatesStage, GroupStage, PivotColDefService, PivotStage, AggFuncService],
  agStackComponents: [
    { componentName: "AgGridHeaderDropZones", componentClass: GridHeaderDropZones }
  ],
  userComponents: [
    { componentName: "agGroupColumnFilter", componentClass: GroupFilter },
    { componentName: "agGroupColumnFloatingFilter", componentClass: GroupFloatingFilterComp }
  ],
  dependantModules: [
    EnterpriseCoreModule
  ]
};

// ../../node_modules/@ag-grid-enterprise/row-grouping/dist/esm/es6/rowGrouping/columnDropZones/valueDropZonePanel.mjs
var __decorate21 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
  else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var ValuesDropZonePanel = class extends BaseDropZonePanel {
  constructor(horizontal) {
    super(horizontal, "aggregation");
  }
  passBeansUp() {
    super.setBeans({
      gridOptionsService: this.gridOptionsService,
      eventService: this.eventService,
      context: this.getContext(),
      loggerFactory: this.loggerFactory,
      dragAndDropService: this.dragAndDropService
    });
    const localeTextFunc = this.localeService.getLocaleTextFunc();
    const emptyMessage = localeTextFunc("valueColumnsEmptyMessage", "Drag here to aggregate");
    const title = localeTextFunc("values", "Values");
    super.init({
      dragAndDropIcon: DragAndDropService.ICON_AGGREGATE,
      icon: _.createIconNoSpan("valuePanel", this.gridOptionsService, null),
      emptyMessage,
      title
    });
    this.addManagedListener(this.eventService, Events.EVENT_COLUMN_VALUE_CHANGED, this.refreshGui.bind(this));
  }
  getAriaLabel() {
    const translate = this.localeService.getLocaleTextFunc();
    const label = translate("ariaValuesDropZonePanelLabel", "Values");
    return label;
  }
  getTooltipParams() {
    const res = super.getTooltipParams();
    res.location = "valueColumnsList";
    return res;
  }
  getIconName() {
    return this.isPotentialDndColumns() ? DragAndDropService.ICON_AGGREGATE : DragAndDropService.ICON_NOT_ALLOWED;
  }
  isColumnDroppable(column) {
    if (this.gridOptionsService.is("functionsReadOnly") || !column.isPrimary()) {
      return false;
    }
    return column.isAllowValue() && !column.isValueActive();
  }
  updateColumns(columns) {
    if (this.gridOptionsService.is("functionsPassive")) {
      const event = {
        type: Events.EVENT_COLUMN_VALUE_CHANGE_REQUEST,
        columns
      };
      this.eventService.dispatchEvent(event);
    } else {
      this.columnModel.setValueColumns(columns, "toolPanelUi");
    }
  }
  getExistingColumns() {
    return this.columnModel.getValueColumns();
  }
};
__decorate21([
  Autowired("columnModel")
], ValuesDropZonePanel.prototype, "columnModel", void 0);
__decorate21([
  Autowired("loggerFactory")
], ValuesDropZonePanel.prototype, "loggerFactory", void 0);
__decorate21([
  Autowired("dragAndDropService")
], ValuesDropZonePanel.prototype, "dragAndDropService", void 0);
__decorate21([
  PostConstruct
], ValuesDropZonePanel.prototype, "passBeansUp", null);

// ../../node_modules/@ag-grid-enterprise/column-tool-panel/dist/esm/es6/columnToolPanel/primaryColsPanel.mjs
var __decorate22 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
  else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var PrimaryColsPanel = class _PrimaryColsPanel extends Component {
  constructor() {
    super(_PrimaryColsPanel.TEMPLATE);
  }
  // we allow dragging in the toolPanel, but not when this component appears in the column menu
  init(allowDragging, params, eventType) {
    this.allowDragging = allowDragging;
    this.params = params;
    this.eventType = eventType;
    this.primaryColsHeaderPanel.init(this.params);
    const hideFilter = this.params.suppressColumnFilter;
    const hideSelect = this.params.suppressColumnSelectAll;
    const hideExpand = this.params.suppressColumnExpandAll;
    if (hideExpand && hideFilter && hideSelect) {
      this.primaryColsHeaderPanel.setDisplayed(false);
    }
    this.addManagedListener(this.primaryColsListPanel, "groupExpanded", this.onGroupExpanded.bind(this));
    this.addManagedListener(this.primaryColsListPanel, "selectionChanged", this.onSelectionChange.bind(this));
    this.primaryColsListPanel.init(this.params, this.allowDragging, this.eventType);
    this.addManagedListener(this.primaryColsHeaderPanel, "expandAll", this.onExpandAll.bind(this));
    this.addManagedListener(this.primaryColsHeaderPanel, "collapseAll", this.onCollapseAll.bind(this));
    this.addManagedListener(this.primaryColsHeaderPanel, "selectAll", this.onSelectAll.bind(this));
    this.addManagedListener(this.primaryColsHeaderPanel, "unselectAll", this.onUnselectAll.bind(this));
    this.addManagedListener(this.primaryColsHeaderPanel, "filterChanged", this.onFilterChanged.bind(this));
    this.positionableFeature = new PositionableFeature(this.getGui(), { minHeight: 100 });
    this.createManagedBean(this.positionableFeature);
  }
  toggleResizable(resizable) {
    this.positionableFeature.setResizable(resizable ? { bottom: true } : false);
  }
  onExpandAll() {
    this.primaryColsListPanel.doSetExpandedAll(true);
  }
  onCollapseAll() {
    this.primaryColsListPanel.doSetExpandedAll(false);
  }
  expandGroups(groupIds) {
    this.primaryColsListPanel.setGroupsExpanded(true, groupIds);
  }
  collapseGroups(groupIds) {
    this.primaryColsListPanel.setGroupsExpanded(false, groupIds);
  }
  setColumnLayout(colDefs) {
    this.primaryColsListPanel.setColumnLayout(colDefs);
  }
  onFilterChanged(event) {
    this.primaryColsListPanel.setFilterText(event.filterText);
  }
  syncLayoutWithGrid() {
    this.primaryColsListPanel.onColumnsChanged();
  }
  onSelectAll() {
    this.primaryColsListPanel.doSetSelectedAll(true);
  }
  onUnselectAll() {
    this.primaryColsListPanel.doSetSelectedAll(false);
  }
  onGroupExpanded(event) {
    this.primaryColsHeaderPanel.setExpandState(event.state);
  }
  onSelectionChange(event) {
    this.primaryColsHeaderPanel.setSelectionState(event.state);
  }
};
PrimaryColsPanel.TEMPLATE = `<div class="ag-column-select">
            <ag-primary-cols-header ref="primaryColsHeaderPanel"></ag-primary-cols-header>
            <ag-primary-cols-list ref="primaryColsListPanel"></ag-primary-cols-list>
        </div>`;
__decorate22([
  RefSelector("primaryColsHeaderPanel")
], PrimaryColsPanel.prototype, "primaryColsHeaderPanel", void 0);
__decorate22([
  RefSelector("primaryColsListPanel")
], PrimaryColsPanel.prototype, "primaryColsListPanel", void 0);

// ../../node_modules/@ag-grid-enterprise/column-tool-panel/dist/esm/es6/columnToolPanel/columnToolPanel.mjs
var __decorate23 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
  else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var ColumnToolPanel = class _ColumnToolPanel extends Component {
  constructor() {
    super(_ColumnToolPanel.TEMPLATE);
    this.initialised = false;
    this.childDestroyFuncs = [];
  }
  // lazy initialise the panel
  setVisible(visible) {
    super.setDisplayed(visible);
    if (visible && !this.initialised) {
      this.init(this.params);
    }
  }
  init(params) {
    const defaultParams = {
      suppressColumnMove: false,
      suppressColumnSelectAll: false,
      suppressColumnFilter: false,
      suppressColumnExpandAll: false,
      contractColumnSelection: false,
      suppressPivotMode: false,
      suppressRowGroups: false,
      suppressValues: false,
      suppressPivots: false,
      suppressSyncLayoutWithGrid: false,
      api: this.gridApi,
      columnApi: this.columnApi
    };
    this.params = Object.assign(Object.assign(Object.assign({}, defaultParams), params), { context: this.gridOptionsService.context });
    if (this.isRowGroupingModuleLoaded() && !this.params.suppressPivotMode) {
      this.pivotModePanel = this.createBean(new PivotModePanel());
      this.childDestroyFuncs.push(() => this.destroyBean(this.pivotModePanel));
      this.appendChild(this.pivotModePanel);
    }
    this.primaryColsPanel = this.createBean(new PrimaryColsPanel());
    this.childDestroyFuncs.push(() => this.destroyBean(this.primaryColsPanel));
    this.primaryColsPanel.init(true, this.params, "toolPanelUi");
    this.primaryColsPanel.addCssClass("ag-column-panel-column-select");
    this.appendChild(this.primaryColsPanel);
    if (this.isRowGroupingModuleLoaded()) {
      if (!this.params.suppressRowGroups) {
        this.rowGroupDropZonePanel = this.createBean(new RowGroupDropZonePanel(false));
        this.childDestroyFuncs.push(() => this.destroyBean(this.rowGroupDropZonePanel));
        this.appendChild(this.rowGroupDropZonePanel);
      }
      if (!this.params.suppressValues) {
        this.valuesDropZonePanel = this.createBean(new ValuesDropZonePanel(false));
        this.childDestroyFuncs.push(() => this.destroyBean(this.valuesDropZonePanel));
        this.appendChild(this.valuesDropZonePanel);
      }
      if (!this.params.suppressPivots) {
        this.pivotDropZonePanel = this.createBean(new PivotDropZonePanel(false));
        this.childDestroyFuncs.push(() => this.destroyBean(this.pivotDropZonePanel));
        this.appendChild(this.pivotDropZonePanel);
      }
      this.setLastVisible();
      const pivotModeListener = this.addManagedListener(this.eventService, Events.EVENT_COLUMN_PIVOT_MODE_CHANGED, () => {
        this.resetChildrenHeight();
        this.setLastVisible();
      });
      this.childDestroyFuncs.push(() => pivotModeListener());
    }
    this.initialised = true;
  }
  setPivotModeSectionVisible(visible) {
    if (!this.isRowGroupingModuleLoaded()) {
      return;
    }
    if (this.pivotModePanel) {
      this.pivotModePanel.setDisplayed(visible);
    } else if (visible) {
      this.pivotModePanel = this.createBean(new PivotModePanel());
      this.getGui().insertBefore(this.pivotModePanel.getGui(), this.getGui().firstChild);
      this.childDestroyFuncs.push(() => this.destroyBean(this.pivotModePanel));
    }
    this.setLastVisible();
  }
  setRowGroupsSectionVisible(visible) {
    if (!this.isRowGroupingModuleLoaded()) {
      return;
    }
    if (this.rowGroupDropZonePanel) {
      this.rowGroupDropZonePanel.setDisplayed(visible);
    } else if (visible) {
      this.rowGroupDropZonePanel = this.createManagedBean(new RowGroupDropZonePanel(false));
      this.appendChild(this.rowGroupDropZonePanel);
    }
    this.setLastVisible();
  }
  setValuesSectionVisible(visible) {
    if (!this.isRowGroupingModuleLoaded()) {
      return;
    }
    if (this.valuesDropZonePanel) {
      this.valuesDropZonePanel.setDisplayed(visible);
    } else if (visible) {
      this.valuesDropZonePanel = this.createManagedBean(new ValuesDropZonePanel(false));
      this.appendChild(this.valuesDropZonePanel);
    }
    this.setLastVisible();
  }
  setPivotSectionVisible(visible) {
    if (!this.isRowGroupingModuleLoaded()) {
      return;
    }
    if (this.pivotDropZonePanel) {
      this.pivotDropZonePanel.setDisplayed(visible);
    } else if (visible) {
      this.pivotDropZonePanel = this.createManagedBean(new PivotDropZonePanel(false));
      this.appendChild(this.pivotDropZonePanel);
      this.pivotDropZonePanel.setDisplayed(visible);
    }
    this.setLastVisible();
  }
  setResizers() {
    [
      this.primaryColsPanel,
      this.rowGroupDropZonePanel,
      this.valuesDropZonePanel,
      this.pivotDropZonePanel
    ].forEach((panel) => {
      if (!panel) {
        return;
      }
      const eGui = panel.getGui();
      panel.toggleResizable(!eGui.classList.contains("ag-last-column-drop") && !eGui.classList.contains("ag-hidden"));
    });
  }
  setLastVisible() {
    const eGui = this.getGui();
    const columnDrops = Array.prototype.slice.call(eGui.querySelectorAll(".ag-column-drop"));
    columnDrops.forEach((columnDrop) => columnDrop.classList.remove("ag-last-column-drop"));
    const columnDropEls = eGui.querySelectorAll(".ag-column-drop:not(.ag-hidden)");
    const lastVisible = _.last(columnDropEls);
    if (lastVisible) {
      lastVisible.classList.add("ag-last-column-drop");
    }
    this.setResizers();
  }
  resetChildrenHeight() {
    const eGui = this.getGui();
    const children = eGui.children;
    for (let i = 0; i < children.length; i++) {
      const child = children[i];
      child.style.removeProperty("height");
      child.style.removeProperty("flex");
    }
  }
  isRowGroupingModuleLoaded() {
    return ModuleRegistry.__assertRegistered(ModuleNames.RowGroupingModule, "Row Grouping", this.context.getGridId());
  }
  expandColumnGroups(groupIds) {
    this.primaryColsPanel.expandGroups(groupIds);
  }
  collapseColumnGroups(groupIds) {
    this.primaryColsPanel.collapseGroups(groupIds);
  }
  setColumnLayout(colDefs) {
    this.primaryColsPanel.setColumnLayout(colDefs);
  }
  syncLayoutWithGrid() {
    this.primaryColsPanel.syncLayoutWithGrid();
  }
  destroyChildren() {
    this.childDestroyFuncs.forEach((func) => func());
    this.childDestroyFuncs.length = 0;
    _.clearElement(this.getGui());
  }
  refresh() {
    this.destroyChildren();
    this.init(this.params);
  }
  // this is a user component, and IComponent has "public destroy()" as part of the interface.
  // so this must be public.
  destroy() {
    this.destroyChildren();
    super.destroy();
  }
};
ColumnToolPanel.TEMPLATE = `<div class="ag-column-panel"></div>`;
__decorate23([
  Autowired("gridApi")
], ColumnToolPanel.prototype, "gridApi", void 0);
__decorate23([
  Autowired("columnApi")
], ColumnToolPanel.prototype, "columnApi", void 0);

// ../../node_modules/@ag-grid-enterprise/column-tool-panel/dist/esm/es6/columnToolPanel/modelItemUtils.mjs
var __decorate24 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
  else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var ModelItemUtils = class ModelItemUtils2 {
  selectAllChildren(colTree, selectAllChecked, eventType) {
    const cols = this.extractAllLeafColumns(colTree);
    this.setAllColumns(cols, selectAllChecked, eventType);
  }
  setColumn(col, selectAllChecked, eventType) {
    this.setAllColumns([col], selectAllChecked, eventType);
  }
  setAllColumns(cols, selectAllChecked, eventType) {
    if (this.columnModel.isPivotMode()) {
      this.setAllPivot(cols, selectAllChecked, eventType);
    } else {
      this.setAllVisible(cols, selectAllChecked, eventType);
    }
  }
  extractAllLeafColumns(allItems) {
    const res = [];
    const recursiveFunc = (items) => {
      items.forEach((item) => {
        if (!item.isPassesFilter()) {
          return;
        }
        if (item.isGroup()) {
          recursiveFunc(item.getChildren());
        } else {
          res.push(item.getColumn());
        }
      });
    };
    recursiveFunc(allItems);
    return res;
  }
  setAllVisible(columns, visible, eventType) {
    const colStateItems = [];
    columns.forEach((col) => {
      if (col.getColDef().lockVisible) {
        return;
      }
      if (col.isVisible() != visible) {
        colStateItems.push({
          colId: col.getId(),
          hide: !visible
        });
      }
    });
    if (colStateItems.length > 0) {
      this.columnModel.applyColumnState({ state: colStateItems }, eventType);
    }
  }
  setAllPivot(columns, value, eventType) {
    if (this.gridOptionsService.is("functionsPassive")) {
      this.setAllPivotPassive(columns, value);
    } else {
      this.setAllPivotActive(columns, value, eventType);
    }
  }
  setAllPivotPassive(columns, value) {
    const copyOfPivotColumns = this.columnModel.getPivotColumns().slice();
    const copyOfValueColumns = this.columnModel.getValueColumns().slice();
    const copyOfRowGroupColumns = this.columnModel.getRowGroupColumns().slice();
    let pivotChanged = false;
    let valueChanged = false;
    let rowGroupChanged = false;
    const turnOnAction = (col) => {
      if (col.isAnyFunctionActive()) {
        return;
      }
      if (col.isAllowValue()) {
        copyOfValueColumns.push(col);
        valueChanged = true;
      } else if (col.isAllowRowGroup()) {
        copyOfRowGroupColumns.push(col);
        pivotChanged = true;
      } else if (col.isAllowPivot()) {
        copyOfPivotColumns.push(col);
        rowGroupChanged = true;
      }
    };
    const turnOffAction = (col) => {
      if (!col.isAnyFunctionActive()) {
        return;
      }
      if (copyOfPivotColumns.indexOf(col) >= 0) {
        _.removeFromArray(copyOfPivotColumns, col);
        pivotChanged = true;
      }
      if (copyOfValueColumns.indexOf(col) >= 0) {
        _.removeFromArray(copyOfValueColumns, col);
        valueChanged = true;
      }
      if (copyOfRowGroupColumns.indexOf(col) >= 0) {
        _.removeFromArray(copyOfRowGroupColumns, col);
        rowGroupChanged = true;
      }
    };
    const action = value ? turnOnAction : turnOffAction;
    columns.forEach(action);
    if (pivotChanged) {
      const event = {
        type: Events.EVENT_COLUMN_PIVOT_CHANGE_REQUEST,
        columns: copyOfPivotColumns
      };
      this.eventService.dispatchEvent(event);
    }
    if (rowGroupChanged) {
      const event = {
        type: Events.EVENT_COLUMN_ROW_GROUP_CHANGE_REQUEST,
        columns: copyOfRowGroupColumns
      };
      this.eventService.dispatchEvent(event);
    }
    if (valueChanged) {
      const event = {
        type: Events.EVENT_COLUMN_VALUE_CHANGE_REQUEST,
        columns: copyOfRowGroupColumns
      };
      this.eventService.dispatchEvent(event);
    }
  }
  setAllPivotActive(columns, value, eventType) {
    const colStateItems = [];
    const turnOnAction = (col) => {
      if (col.isAnyFunctionActive()) {
        return;
      }
      if (col.isAllowValue()) {
        const aggFunc = typeof col.getAggFunc() === "string" ? col.getAggFunc() : this.aggFuncService.getDefaultAggFunc(col);
        colStateItems.push({
          colId: col.getId(),
          aggFunc
        });
      } else if (col.isAllowRowGroup()) {
        colStateItems.push({
          colId: col.getId(),
          rowGroup: true
        });
      } else if (col.isAllowPivot()) {
        colStateItems.push({
          colId: col.getId(),
          pivot: true
        });
      }
    };
    const turnOffAction = (col) => {
      const isActive = col.isPivotActive() || col.isRowGroupActive() || col.isValueActive();
      if (isActive) {
        colStateItems.push({
          colId: col.getId(),
          pivot: false,
          rowGroup: false,
          aggFunc: null
        });
      }
    };
    const action = value ? turnOnAction : turnOffAction;
    columns.forEach(action);
    if (colStateItems.length > 0) {
      this.columnModel.applyColumnState({ state: colStateItems }, eventType);
    }
  }
  updateColumns(params) {
    const { columns, visibleState, pivotState, eventType } = params;
    const state = columns.map((column) => {
      const colId = column.getColId();
      if (this.columnModel.isPivotMode()) {
        const pivotStateForColumn = pivotState === null || pivotState === void 0 ? void 0 : pivotState[colId];
        return {
          colId,
          pivot: pivotStateForColumn === null || pivotStateForColumn === void 0 ? void 0 : pivotStateForColumn.pivot,
          rowGroup: pivotStateForColumn === null || pivotStateForColumn === void 0 ? void 0 : pivotStateForColumn.rowGroup,
          aggFunc: pivotStateForColumn === null || pivotStateForColumn === void 0 ? void 0 : pivotStateForColumn.aggFunc
        };
      } else {
        return {
          colId,
          hide: !(visibleState === null || visibleState === void 0 ? void 0 : visibleState[colId])
        };
      }
    });
    this.columnModel.applyColumnState({ state }, eventType);
  }
  createPivotState(column) {
    return {
      pivot: column.isPivotActive(),
      rowGroup: column.isRowGroupActive(),
      aggFunc: column.isValueActive() ? column.getAggFunc() : void 0
    };
  }
};
__decorate24([
  Autowired("aggFuncService")
], ModelItemUtils.prototype, "aggFuncService", void 0);
__decorate24([
  Autowired("columnModel")
], ModelItemUtils.prototype, "columnModel", void 0);
__decorate24([
  Autowired("gridOptionsService")
], ModelItemUtils.prototype, "gridOptionsService", void 0);
__decorate24([
  Autowired("eventService")
], ModelItemUtils.prototype, "eventService", void 0);
ModelItemUtils = __decorate24([
  Bean("modelItemUtils")
], ModelItemUtils);

// ../../node_modules/@ag-grid-enterprise/column-tool-panel/dist/esm/es6/version.mjs
var VERSION2 = "30.2.1";

// ../../node_modules/@ag-grid-enterprise/column-tool-panel/dist/esm/es6/columnsToolPanelModule.mjs
var ColumnsToolPanelModule = {
  version: VERSION2,
  moduleName: ModuleNames.ColumnsToolPanelModule,
  beans: [ModelItemUtils],
  agStackComponents: [
    { componentName: "AgPrimaryColsHeader", componentClass: PrimaryColsHeaderPanel },
    { componentName: "AgPrimaryColsList", componentClass: PrimaryColsListPanel },
    { componentName: "AgPrimaryCols", componentClass: PrimaryColsPanel }
  ],
  userComponents: [
    { componentName: "agColumnsToolPanel", componentClass: ColumnToolPanel }
  ],
  dependantModules: [
    EnterpriseCoreModule,
    RowGroupingModule,
    SideBarModule
  ]
};

export {
  PrimaryColsPanel,
  ColumnsToolPanelModule
};
//# sourceMappingURL=chunk-QZ7522SQ.js.map
