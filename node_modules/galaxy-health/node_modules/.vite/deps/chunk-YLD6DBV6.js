import {
  Autowired,
  Bean,
  BeanStub,
  Component,
  ModuleNames,
  PostConstruct,
  PreConstruct,
  RefSelector
} from "./chunk-H2INHEN3.js";

// ../../node_modules/@ag-grid-enterprise/core/dist/esm/es6/license/shared/md5.mjs
var MD5 = class {
  constructor() {
    this.ieCompatibility = false;
  }
  init() {
    this.ieCompatibility = this.md5("hello") != "5d41402abc4b2a76b9719d911017c592";
  }
  md5cycle(x, k) {
    let a = x[0], b = x[1], c = x[2], d = x[3];
    a = this.ff(a, b, c, d, k[0], 7, -680876936);
    d = this.ff(d, a, b, c, k[1], 12, -389564586);
    c = this.ff(c, d, a, b, k[2], 17, 606105819);
    b = this.ff(b, c, d, a, k[3], 22, -1044525330);
    a = this.ff(a, b, c, d, k[4], 7, -176418897);
    d = this.ff(d, a, b, c, k[5], 12, 1200080426);
    c = this.ff(c, d, a, b, k[6], 17, -1473231341);
    b = this.ff(b, c, d, a, k[7], 22, -45705983);
    a = this.ff(a, b, c, d, k[8], 7, 1770035416);
    d = this.ff(d, a, b, c, k[9], 12, -1958414417);
    c = this.ff(c, d, a, b, k[10], 17, -42063);
    b = this.ff(b, c, d, a, k[11], 22, -1990404162);
    a = this.ff(a, b, c, d, k[12], 7, 1804603682);
    d = this.ff(d, a, b, c, k[13], 12, -40341101);
    c = this.ff(c, d, a, b, k[14], 17, -1502002290);
    b = this.ff(b, c, d, a, k[15], 22, 1236535329);
    a = this.gg(a, b, c, d, k[1], 5, -165796510);
    d = this.gg(d, a, b, c, k[6], 9, -1069501632);
    c = this.gg(c, d, a, b, k[11], 14, 643717713);
    b = this.gg(b, c, d, a, k[0], 20, -373897302);
    a = this.gg(a, b, c, d, k[5], 5, -701558691);
    d = this.gg(d, a, b, c, k[10], 9, 38016083);
    c = this.gg(c, d, a, b, k[15], 14, -660478335);
    b = this.gg(b, c, d, a, k[4], 20, -405537848);
    a = this.gg(a, b, c, d, k[9], 5, 568446438);
    d = this.gg(d, a, b, c, k[14], 9, -1019803690);
    c = this.gg(c, d, a, b, k[3], 14, -187363961);
    b = this.gg(b, c, d, a, k[8], 20, 1163531501);
    a = this.gg(a, b, c, d, k[13], 5, -1444681467);
    d = this.gg(d, a, b, c, k[2], 9, -51403784);
    c = this.gg(c, d, a, b, k[7], 14, 1735328473);
    b = this.gg(b, c, d, a, k[12], 20, -1926607734);
    a = this.hh(a, b, c, d, k[5], 4, -378558);
    d = this.hh(d, a, b, c, k[8], 11, -2022574463);
    c = this.hh(c, d, a, b, k[11], 16, 1839030562);
    b = this.hh(b, c, d, a, k[14], 23, -35309556);
    a = this.hh(a, b, c, d, k[1], 4, -1530992060);
    d = this.hh(d, a, b, c, k[4], 11, 1272893353);
    c = this.hh(c, d, a, b, k[7], 16, -155497632);
    b = this.hh(b, c, d, a, k[10], 23, -1094730640);
    a = this.hh(a, b, c, d, k[13], 4, 681279174);
    d = this.hh(d, a, b, c, k[0], 11, -358537222);
    c = this.hh(c, d, a, b, k[3], 16, -722521979);
    b = this.hh(b, c, d, a, k[6], 23, 76029189);
    a = this.hh(a, b, c, d, k[9], 4, -640364487);
    d = this.hh(d, a, b, c, k[12], 11, -421815835);
    c = this.hh(c, d, a, b, k[15], 16, 530742520);
    b = this.hh(b, c, d, a, k[2], 23, -995338651);
    a = this.ii(a, b, c, d, k[0], 6, -198630844);
    d = this.ii(d, a, b, c, k[7], 10, 1126891415);
    c = this.ii(c, d, a, b, k[14], 15, -1416354905);
    b = this.ii(b, c, d, a, k[5], 21, -57434055);
    a = this.ii(a, b, c, d, k[12], 6, 1700485571);
    d = this.ii(d, a, b, c, k[3], 10, -1894986606);
    c = this.ii(c, d, a, b, k[10], 15, -1051523);
    b = this.ii(b, c, d, a, k[1], 21, -2054922799);
    a = this.ii(a, b, c, d, k[8], 6, 1873313359);
    d = this.ii(d, a, b, c, k[15], 10, -30611744);
    c = this.ii(c, d, a, b, k[6], 15, -1560198380);
    b = this.ii(b, c, d, a, k[13], 21, 1309151649);
    a = this.ii(a, b, c, d, k[4], 6, -145523070);
    d = this.ii(d, a, b, c, k[11], 10, -1120210379);
    c = this.ii(c, d, a, b, k[2], 15, 718787259);
    b = this.ii(b, c, d, a, k[9], 21, -343485551);
    x[0] = this.add32(a, x[0]);
    x[1] = this.add32(b, x[1]);
    x[2] = this.add32(c, x[2]);
    x[3] = this.add32(d, x[3]);
  }
  cmn(q, a, b, x, s, t) {
    a = this.add32(this.add32(a, q), this.add32(x, t));
    return this.add32(a << s | a >>> 32 - s, b);
  }
  ff(a, b, c, d, x, s, t) {
    return this.cmn(b & c | ~b & d, a, b, x, s, t);
  }
  gg(a, b, c, d, x, s, t) {
    return this.cmn(b & d | c & ~d, a, b, x, s, t);
  }
  hh(a, b, c, d, x, s, t) {
    return this.cmn(b ^ c ^ d, a, b, x, s, t);
  }
  ii(a, b, c, d, x, s, t) {
    return this.cmn(c ^ (b | ~d), a, b, x, s, t);
  }
  md51(s) {
    const n = s.length;
    const state = [1732584193, -271733879, -1732584194, 271733878];
    let i;
    for (i = 64; i <= s.length; i += 64) {
      this.md5cycle(state, this.md5blk(s.substring(i - 64, i)));
    }
    s = s.substring(i - 64);
    const tail = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
    for (i = 0; i < s.length; i++) {
      tail[i >> 2] |= s.charCodeAt(i) << (i % 4 << 3);
    }
    tail[i >> 2] |= 128 << (i % 4 << 3);
    if (i > 55) {
      this.md5cycle(state, tail);
      for (i = 0; i < 16; i++) {
        tail[i] = 0;
      }
    }
    tail[14] = n * 8;
    this.md5cycle(state, tail);
    return state;
  }
  /* there needs to be support for Unicode here, * unless we pretend that we can redefine the MD-5
   * algorithm for multi-byte characters (perhaps by adding every four 16-bit characters and
   * shortening the sum to 32 bits). Otherwise I suthis.ggest performing MD-5 as if every character
   * was two bytes--e.g., 0040 0025 = @%--but then how will an ordinary MD-5 sum be matched?
   * There is no way to standardize text to something like UTF-8 before transformation; speed cost is
   * utterly prohibitive. The JavaScript standard itself needs to look at this: it should start
   * providing access to strings as preformed UTF-8 8-bit unsigned value arrays.
   */
  md5blk(s) {
    const md5blks = [];
    for (let i = 0; i < 64; i += 4) {
      md5blks[i >> 2] = s.charCodeAt(i) + (s.charCodeAt(i + 1) << 8) + (s.charCodeAt(i + 2) << 16) + (s.charCodeAt(i + 3) << 24);
    }
    return md5blks;
  }
  rhex(n) {
    const hex_chr = "0123456789abcdef".split("");
    let s = "", j = 0;
    for (; j < 4; j++) {
      s += hex_chr[n >> j * 8 + 4 & 15] + hex_chr[n >> j * 8 & 15];
    }
    return s;
  }
  hex(x) {
    for (let i = 0; i < x.length; i++) {
      x[i] = this.rhex(x[i]);
    }
    return x.join("");
  }
  md5(s) {
    return this.hex(this.md51(s));
  }
  add32(a, b) {
    return this.ieCompatibility ? this.add32Compat(a, b) : this.add32Std(a, b);
  }
  /* this function is much faster, so if possible we use it. Some IEs are the only ones I know of that
   need the idiotic second function, generated by an if clause.  */
  add32Std(a, b) {
    return a + b & 4294967295;
  }
  add32Compat(x, y) {
    const lsw = (x & 65535) + (y & 65535), msw = (x >> 16) + (y >> 16) + (lsw >> 16);
    return msw << 16 | lsw & 65535;
  }
};

// ../../node_modules/@ag-grid-enterprise/core/dist/esm/es6/license/shared/licenseManager.mjs
function missingOrEmpty(value) {
  return value == null || value.length === 0;
}
function exists(value, allowEmptyString = false) {
  return value != null && (value !== "" || allowEmptyString);
}
var LicenseManager = class _LicenseManager {
  constructor(document) {
    this.watermarkMessage = void 0;
    this.document = document;
    this.md5 = new MD5();
    this.md5.init();
  }
  validateLicense() {
    if (missingOrEmpty(_LicenseManager.licenseKey)) {
      if (!this.isWebsiteUrl() || this.isForceWatermark()) {
        this.outputMissingLicenseKey();
      }
    } else if (_LicenseManager.licenseKey.length > 32) {
      if (_LicenseManager.licenseKey.indexOf("For_Trialing_ag-Grid_Only") !== -1) {
        this.outputInvalidLicenseKey();
      } else {
        const { md5, license, version, isTrial } = _LicenseManager.extractLicenseComponents(_LicenseManager.licenseKey);
        if (md5 === this.md5.md5(license)) {
          if (exists(version) && version) {
            this.validateLicenseKeyForVersion(version, !!isTrial, license);
          } else {
            this.validateLegacyKey(license);
          }
        } else {
          this.outputInvalidLicenseKey();
        }
      }
    } else {
      this.outputInvalidLicenseKey();
    }
  }
  static extractExpiry(license) {
    const restrictionHashed = license.substring(license.lastIndexOf("_") + 1, license.length);
    return new Date(parseInt(_LicenseManager.decode(restrictionHashed), 10));
  }
  static extractLicenseComponents(licenseKey) {
    let cleanedLicenseKey = licenseKey.replace(/[\u200B-\u200D\uFEFF]/g, "");
    cleanedLicenseKey = cleanedLicenseKey.replace(/\r?\n|\r/g, "");
    const hashStart = cleanedLicenseKey.length - 32;
    const md5 = cleanedLicenseKey.substring(hashStart);
    const license = cleanedLicenseKey.substring(0, hashStart);
    const [version, isTrial] = _LicenseManager.extractBracketedInformation(cleanedLicenseKey);
    return { md5, license, version, isTrial };
  }
  getLicenseDetails(licenseKey) {
    const { md5, license, version, isTrial } = _LicenseManager.extractLicenseComponents(licenseKey);
    let valid = md5 === this.md5.md5(license) && licenseKey.indexOf("For_Trialing_ag-Grid_Only") === -1;
    let trialExpired = null;
    let expiry = null;
    if (valid) {
      expiry = _LicenseManager.extractExpiry(license);
      valid = !isNaN(expiry.getTime());
      if (isTrial) {
        const now = /* @__PURE__ */ new Date();
        trialExpired = expiry < now;
      }
    }
    return {
      licenseKey,
      valid,
      expiry: valid ? _LicenseManager.formatDate(expiry) : null,
      version: version ? version : "legacy",
      isTrial,
      trialExpired
    };
  }
  isDisplayWatermark() {
    return this.isForceWatermark() || !this.isLocalhost() && !this.isWebsiteUrl() && !missingOrEmpty(this.watermarkMessage);
  }
  getWatermarkMessage() {
    return this.watermarkMessage || "";
  }
  getHostname() {
    const win = this.document.defaultView || window;
    const loc = win.location;
    const { hostname = "" } = loc;
    return hostname;
  }
  isForceWatermark() {
    const win = this.document.defaultView || window;
    const loc = win.location;
    const { pathname } = loc;
    return pathname ? pathname.indexOf("forceWatermark") !== -1 : false;
  }
  isWebsiteUrl() {
    const hostname = this.getHostname();
    return hostname.match(/^((?:\w+\.)?ag-grid\.com)$/) !== null;
  }
  isLocalhost() {
    const hostname = this.getHostname();
    return hostname.match(/^(?:127\.0\.0\.1|localhost)$/) !== null;
  }
  static formatDate(date) {
    const monthNames = [
      "January",
      "February",
      "March",
      "April",
      "May",
      "June",
      "July",
      "August",
      "September",
      "October",
      "November",
      "December"
    ];
    const day = date.getDate();
    const monthIndex = date.getMonth();
    const year = date.getFullYear();
    return day + " " + monthNames[monthIndex] + " " + year;
  }
  static getGridReleaseDate() {
    return new Date(parseInt(_LicenseManager.decode(_LicenseManager.RELEASE_INFORMATION), 10));
  }
  static decode(input) {
    const keystr = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
    let t = "";
    let n, r, i;
    let s, o, u, a;
    let f = 0;
    const e = input.replace(/[^A-Za-z0-9+/=]/g, "");
    while (f < e.length) {
      s = keystr.indexOf(e.charAt(f++));
      o = keystr.indexOf(e.charAt(f++));
      u = keystr.indexOf(e.charAt(f++));
      a = keystr.indexOf(e.charAt(f++));
      n = s << 2 | o >> 4;
      r = (o & 15) << 4 | u >> 2;
      i = (u & 3) << 6 | a;
      t = t + String.fromCharCode(n);
      if (u != 64) {
        t = t + String.fromCharCode(r);
      }
      if (a != 64) {
        t = t + String.fromCharCode(i);
      }
    }
    t = _LicenseManager.utf8_decode(t);
    return t;
  }
  static utf8_decode(input) {
    input = input.replace(/rn/g, "n");
    let t = "";
    for (let n = 0; n < input.length; n++) {
      const r = input.charCodeAt(n);
      if (r < 128) {
        t += String.fromCharCode(r);
      } else if (r > 127 && r < 2048) {
        t += String.fromCharCode(r >> 6 | 192);
        t += String.fromCharCode(r & 63 | 128);
      } else {
        t += String.fromCharCode(r >> 12 | 224);
        t += String.fromCharCode(r >> 6 & 63 | 128);
        t += String.fromCharCode(r & 63 | 128);
      }
    }
    return t;
  }
  static setLicenseKey(licenseKey) {
    this.licenseKey = licenseKey;
  }
  static extractBracketedInformation(licenseKey) {
    const matches = licenseKey.split("[").filter(function(v) {
      return v.indexOf("]") > -1;
    }).map(function(value) {
      return value.split("]")[0];
    });
    if (!matches || matches.length === 0) {
      return [null, null];
    }
    const isTrial = matches.filter((match) => match === "TRIAL").length === 1;
    const version = matches.filter((match) => match.indexOf("v") === 0).map((match) => match.replace(/^v/, ""))[0];
    return [version, isTrial];
  }
  validateLicenseKeyForVersion(version, isTrial, license) {
    if (version !== "2") {
      return;
    }
    if (isTrial) {
      this.validateForTrial(license);
    } else {
      this.validateLegacyKey(license);
    }
  }
  validateLegacyKey(license) {
    const gridReleaseDate = _LicenseManager.getGridReleaseDate();
    const expiry = _LicenseManager.extractExpiry(license);
    let valid = false;
    let current = false;
    if (!isNaN(expiry.getTime())) {
      valid = true;
      current = gridReleaseDate < expiry;
    }
    if (!valid) {
      this.outputInvalidLicenseKey();
    } else if (!current) {
      const formattedExpiryDate = _LicenseManager.formatDate(expiry);
      const formattedReleaseDate = _LicenseManager.formatDate(gridReleaseDate);
      this.outputIncompatibleVersion(formattedExpiryDate, formattedReleaseDate);
    }
  }
  validateForTrial(license) {
    const expiry = _LicenseManager.extractExpiry(license);
    const now = /* @__PURE__ */ new Date();
    let valid = false;
    let current = false;
    if (!isNaN(expiry.getTime())) {
      valid = true;
      current = expiry > now;
    }
    if (!valid) {
      this.outputInvalidLicenseKey();
    } else if (!current) {
      const formattedExpiryDate = _LicenseManager.formatDate(expiry);
      this.outputExpiredTrialKey(formattedExpiryDate);
    }
  }
  outputInvalidLicenseKey() {
    console.error("*****************************************************************************************************************");
    console.error("***************************************** AG Grid Enterprise License ********************************************");
    console.error("********************************************* Invalid License ***************************************************");
    console.error("* Your license for AG Grid Enterprise is not valid - please contact info@ag-grid.com to obtain a valid license. *");
    console.error("*****************************************************************************************************************");
    console.error("*****************************************************************************************************************");
    this.watermarkMessage = "Invalid License";
  }
  outputExpiredTrialKey(formattedExpiryDate) {
    console.error("****************************************************************************************************************");
    console.error("***************************************** AG Grid Enterprise License *******************************************");
    console.error("*****************************************   Trial Period Expired.    *******************************************");
    console.error(`* Your license for AG Grid Enterprise expired on ${formattedExpiryDate}.                                                *`);
    console.error("* Please email info@ag-grid.com to purchase a license.                                                         *");
    console.error("****************************************************************************************************************");
    console.error("****************************************************************************************************************");
    this.watermarkMessage = "Trial Period Expired";
  }
  outputMissingLicenseKey() {
    console.error("****************************************************************************************************************");
    console.error("***************************************** AG Grid Enterprise License *******************************************");
    console.error("****************************************** License Key Not Found ***********************************************");
    console.error("* All AG Grid Enterprise features are unlocked.                                                                *");
    console.error("* This is an evaluation only version, it is not licensed for development projects intended for production.     *");
    console.error("* If you want to hide the watermark, please email info@ag-grid.com for a trial license.                        *");
    console.error("****************************************************************************************************************");
    console.error("****************************************************************************************************************");
    this.watermarkMessage = "For Trial Use Only";
  }
  outputIncompatibleVersion(formattedExpiryDate, formattedReleaseDate) {
    console.error("****************************************************************************************************************************");
    console.error("****************************************************************************************************************************");
    console.error("*                                             AG Grid Enterprise License                                                   *");
    console.error("*                           License not compatible with installed version of AG Grid Enterprise.                           *");
    console.error("*                                                                                                                          *");
    console.error(`* Your AG Grid License entitles you to all versions of AG Grid that we release within the time covered by your license     *`);
    console.error(`* - typically we provide one year licenses which entitles you to all releases / updates of AG Grid within that year.       *`);
    console.error(`* Your license has an end (expiry) date which stops the license key working with versions of AG Grid released after the    *`);
    console.error(`* license end date. The license key that you have expires on ${formattedExpiryDate}, however the version of AG Grid you    *`);
    console.error(`* are trying to use was released on ${formattedReleaseDate}.                                                               *`);
    console.error("*                                                                                                                          *");
    console.error("* Please contact info@ag-grid.com to renew your subscription to new versions and get a new license key to work with this   *");
    console.error("* version of AG Grid.                                                                                                      *");
    console.error("****************************************************************************************************************************");
    console.error("****************************************************************************************************************************");
    this.watermarkMessage = "License Expired";
  }
};
LicenseManager.RELEASE_INFORMATION = "MTY5ODkxNzc1MzgxNA==";

// ../../node_modules/@ag-grid-enterprise/core/dist/esm/es6/license/gridLicenseManager.mjs
var __decorate = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
  else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var GridLicenseManager = class GridLicenseManager2 extends BeanStub {
  validateLicense() {
    this.licenseManager = new LicenseManager(this.gridOptionsService.getDocument());
    this.licenseManager.validateLicense();
  }
  static getLicenseDetails(licenseKey) {
    return new LicenseManager(null).getLicenseDetails(licenseKey);
  }
  isDisplayWatermark() {
    return this.licenseManager.isDisplayWatermark();
  }
  getWatermarkMessage() {
    return this.licenseManager.getWatermarkMessage();
  }
  static setLicenseKey(licenseKey) {
    LicenseManager.setLicenseKey(licenseKey);
  }
};
__decorate([
  PreConstruct
], GridLicenseManager.prototype, "validateLicense", null);
GridLicenseManager = __decorate([
  Bean("licenseManager")
], GridLicenseManager);

// ../../node_modules/@ag-grid-enterprise/core/dist/esm/es6/license/watermark.mjs
var __decorate2 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
  else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var WatermarkComp = class extends Component {
  constructor() {
    super(
      /* html*/
      `<div class="ag-watermark">
                <div ref="eLicenseTextRef" class="ag-watermark-text"></div>
            </div>`
    );
  }
  postConstruct() {
    const show = this.shouldDisplayWatermark();
    this.setDisplayed(show);
    if (show) {
      this.eLicenseTextRef.innerText = this.licenseManager.getWatermarkMessage();
      window.setTimeout(() => this.addCssClass("ag-opacity-zero"), 0);
      window.setTimeout(() => this.setDisplayed(false), 5e3);
    }
  }
  shouldDisplayWatermark() {
    return this.licenseManager.isDisplayWatermark();
  }
};
__decorate2([
  Autowired("licenseManager")
], WatermarkComp.prototype, "licenseManager", void 0);
__decorate2([
  RefSelector("eLicenseTextRef")
], WatermarkComp.prototype, "eLicenseTextRef", void 0);
__decorate2([
  PostConstruct
], WatermarkComp.prototype, "postConstruct", null);

// ../../node_modules/@ag-grid-enterprise/core/dist/esm/es6/version.mjs
var VERSION = "30.2.1";

// ../../node_modules/@ag-grid-enterprise/core/dist/esm/es6/agGridEnterpriseModule.mjs
var EnterpriseCoreModule = {
  version: VERSION,
  moduleName: ModuleNames.EnterpriseCoreModule,
  beans: [GridLicenseManager],
  agStackComponents: [
    { componentName: "AgWatermark", componentClass: WatermarkComp }
  ]
};

export {
  EnterpriseCoreModule
};
//# sourceMappingURL=chunk-YLD6DBV6.js.map
