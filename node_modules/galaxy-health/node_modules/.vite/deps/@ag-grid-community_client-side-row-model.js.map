{
  "version": 3,
  "sources": ["../../../../../node_modules/@ag-grid-community/client-side-row-model/dist/esm/es6/clientSideRowModel/clientSideNodeManager.mjs", "../../../../../node_modules/@ag-grid-community/client-side-row-model/dist/esm/es6/clientSideRowModel/clientSideRowModel.mjs", "../../../../../node_modules/@ag-grid-community/client-side-row-model/dist/esm/es6/clientSideRowModel/filterStage.mjs", "../../../../../node_modules/@ag-grid-community/client-side-row-model/dist/esm/es6/clientSideRowModel/sortStage.mjs", "../../../../../node_modules/@ag-grid-community/client-side-row-model/dist/esm/es6/clientSideRowModel/flattenStage.mjs", "../../../../../node_modules/@ag-grid-community/client-side-row-model/dist/esm/es6/clientSideRowModel/sortService.mjs", "../../../../../node_modules/@ag-grid-community/client-side-row-model/dist/esm/es6/clientSideRowModel/filterService.mjs", "../../../../../node_modules/@ag-grid-community/client-side-row-model/dist/esm/es6/clientSideRowModel/immutableService.mjs", "../../../../../node_modules/@ag-grid-community/client-side-row-model/dist/esm/es6/version.mjs", "../../../../../node_modules/@ag-grid-community/client-side-row-model/dist/esm/es6/clientSideRowModelModule.mjs"],
  "sourcesContent": ["import { Events, RowNode, _ } from \"@ag-grid-community/core\";\nexport class ClientSideNodeManager {\n    constructor(rootNode, gridOptionsService, eventService, columnModel, selectionService, beans) {\n        this.nextId = 0;\n        // when user is provide the id's, we also keep a map of ids to row nodes for convenience\n        this.allNodesMap = {};\n        this.rootNode = rootNode;\n        this.gridOptionsService = gridOptionsService;\n        this.eventService = eventService;\n        this.columnModel = columnModel;\n        this.beans = beans;\n        this.selectionService = selectionService;\n        this.rootNode.group = true;\n        this.rootNode.level = -1;\n        this.rootNode.id = ClientSideNodeManager.ROOT_NODE_ID;\n        this.rootNode.allLeafChildren = [];\n        this.rootNode.childrenAfterGroup = [];\n        this.rootNode.childrenAfterSort = [];\n        this.rootNode.childrenAfterAggFilter = [];\n        this.rootNode.childrenAfterFilter = [];\n        // if we make this class a bean, then can annotate postConstruct\n        this.postConstruct();\n    }\n    // @PostConstruct - this is not a bean, so postConstruct called by constructor\n    postConstruct() {\n        // func below doesn't have 'this' pointer, so need to pull out these bits\n        this.suppressParentsInRowNodes = this.gridOptionsService.is('suppressParentsInRowNodes');\n        this.isRowMasterFunc = this.gridOptionsService.get('isRowMaster');\n        this.doingMasterDetail = this.gridOptionsService.is('masterDetail');\n    }\n    getCopyOfNodesMap() {\n        return _.cloneObject(this.allNodesMap);\n    }\n    getRowNode(id) {\n        return this.allNodesMap[id];\n    }\n    setRowData(rowData) {\n        if (typeof rowData === 'string') {\n            console.warn('AG Grid: rowData must be an array, however you passed in a string. If you are loading JSON, make sure you convert the JSON string to JavaScript objects first');\n            return;\n        }\n        this.dispatchRowDataUpdateStartedEvent(rowData);\n        const rootNode = this.rootNode;\n        const sibling = this.rootNode.sibling;\n        rootNode.childrenAfterFilter = null;\n        rootNode.childrenAfterGroup = null;\n        rootNode.childrenAfterAggFilter = null;\n        rootNode.childrenAfterSort = null;\n        rootNode.childrenMapped = null;\n        rootNode.updateHasChildren();\n        this.nextId = 0;\n        this.allNodesMap = {};\n        if (rowData) {\n            // we use rootNode as the parent, however if using ag-grid-enterprise, the grouping stage\n            // sets the parent node on each row (even if we are not grouping). so setting parent node\n            // here is for benefit of ag-grid-community users\n            rootNode.allLeafChildren = rowData.map(dataItem => this.createNode(dataItem, this.rootNode, ClientSideNodeManager.TOP_LEVEL));\n        }\n        else {\n            rootNode.allLeafChildren = [];\n            rootNode.childrenAfterGroup = [];\n        }\n        if (sibling) {\n            sibling.childrenAfterFilter = rootNode.childrenAfterFilter;\n            sibling.childrenAfterGroup = rootNode.childrenAfterGroup;\n            sibling.childrenAfterAggFilter = rootNode.childrenAfterAggFilter;\n            sibling.childrenAfterSort = rootNode.childrenAfterSort;\n            sibling.childrenMapped = rootNode.childrenMapped;\n            sibling.allLeafChildren = rootNode.allLeafChildren;\n        }\n    }\n    updateRowData(rowDataTran, rowNodeOrder) {\n        this.dispatchRowDataUpdateStartedEvent(rowDataTran.add);\n        const rowNodeTransaction = {\n            remove: [],\n            update: [],\n            add: []\n        };\n        const nodesToUnselect = [];\n        this.executeRemove(rowDataTran, rowNodeTransaction, nodesToUnselect);\n        this.executeUpdate(rowDataTran, rowNodeTransaction, nodesToUnselect);\n        this.executeAdd(rowDataTran, rowNodeTransaction);\n        this.updateSelection(nodesToUnselect, 'rowDataChanged');\n        if (rowNodeOrder) {\n            _.sortRowNodesByOrder(this.rootNode.allLeafChildren, rowNodeOrder);\n        }\n        return rowNodeTransaction;\n    }\n    dispatchRowDataUpdateStartedEvent(rowData) {\n        const event = {\n            type: Events.EVENT_ROW_DATA_UPDATE_STARTED,\n            firstRowData: (rowData === null || rowData === void 0 ? void 0 : rowData.length) ? rowData[0] : null\n        };\n        this.eventService.dispatchEvent(event);\n    }\n    updateSelection(nodesToUnselect, source) {\n        const selectionChanged = nodesToUnselect.length > 0;\n        if (selectionChanged) {\n            this.selectionService.setNodesSelected({\n                newValue: false,\n                nodes: nodesToUnselect,\n                suppressFinishActions: true,\n                source,\n            });\n        }\n        // we do this regardless of nodes to unselect or not, as it's possible\n        // a new node was inserted, so a parent that was previously selected (as all\n        // children were selected) should not be tri-state (as new one unselected against\n        // all other selected children).\n        this.selectionService.updateGroupsFromChildrenSelections(source);\n        if (selectionChanged) {\n            const event = {\n                type: Events.EVENT_SELECTION_CHANGED,\n                source: source\n            };\n            this.eventService.dispatchEvent(event);\n        }\n    }\n    executeAdd(rowDataTran, rowNodeTransaction) {\n        var _a;\n        const { add, addIndex } = rowDataTran;\n        if (_.missingOrEmpty(add)) {\n            return;\n        }\n        // create new row nodes for each data item\n        const newNodes = add.map(item => this.createNode(item, this.rootNode, ClientSideNodeManager.TOP_LEVEL));\n        if (typeof addIndex === 'number' && addIndex >= 0) {\n            // new rows are inserted in one go by concatenating them in between the existing rows at the desired index.\n            // this is much faster than splicing them individually into 'allLeafChildren' when there are large inserts.\n            const { allLeafChildren } = this.rootNode;\n            const len = allLeafChildren.length;\n            let normalisedAddIndex = addIndex;\n            const isTreeData = this.gridOptionsService.is('treeData');\n            if (isTreeData && addIndex > 0 && len > 0) {\n                for (let i = 0; i < len; i++) {\n                    if (((_a = allLeafChildren[i]) === null || _a === void 0 ? void 0 : _a.rowIndex) == addIndex - 1) {\n                        normalisedAddIndex = i + 1;\n                        break;\n                    }\n                }\n            }\n            const nodesBeforeIndex = allLeafChildren.slice(0, normalisedAddIndex);\n            const nodesAfterIndex = allLeafChildren.slice(normalisedAddIndex, allLeafChildren.length);\n            this.rootNode.allLeafChildren = [...nodesBeforeIndex, ...newNodes, ...nodesAfterIndex];\n        }\n        else {\n            this.rootNode.allLeafChildren = [...this.rootNode.allLeafChildren, ...newNodes];\n        }\n        if (this.rootNode.sibling) {\n            this.rootNode.sibling.allLeafChildren = this.rootNode.allLeafChildren;\n        }\n        // add new row nodes to the transaction add items\n        rowNodeTransaction.add = newNodes;\n    }\n    executeRemove(rowDataTran, rowNodeTransaction, nodesToUnselect) {\n        const { remove } = rowDataTran;\n        if (_.missingOrEmpty(remove)) {\n            return;\n        }\n        const rowIdsRemoved = {};\n        remove.forEach(item => {\n            const rowNode = this.lookupRowNode(item);\n            if (!rowNode) {\n                return;\n            }\n            // do delete - setting 'suppressFinishActions = true' to ensure EVENT_SELECTION_CHANGED is not raised for\n            // each row node updated, instead it is raised once by the calling code if any selected nodes exist.\n            if (rowNode.isSelected()) {\n                nodesToUnselect.push(rowNode);\n            }\n            // so row renderer knows to fade row out (and not reposition it)\n            rowNode.clearRowTopAndRowIndex();\n            // NOTE: were we could remove from allLeaveChildren, however _.removeFromArray() is expensive, especially\n            // if called multiple times (eg deleting lots of rows) and if allLeafChildren is a large list\n            rowIdsRemoved[rowNode.id] = true;\n            // _.removeFromArray(this.rootNode.allLeafChildren, rowNode);\n            delete this.allNodesMap[rowNode.id];\n            rowNodeTransaction.remove.push(rowNode);\n        });\n        this.rootNode.allLeafChildren = this.rootNode.allLeafChildren.filter(rowNode => !rowIdsRemoved[rowNode.id]);\n        if (this.rootNode.sibling) {\n            this.rootNode.sibling.allLeafChildren = this.rootNode.allLeafChildren;\n        }\n    }\n    executeUpdate(rowDataTran, rowNodeTransaction, nodesToUnselect) {\n        const { update } = rowDataTran;\n        if (_.missingOrEmpty(update)) {\n            return;\n        }\n        update.forEach(item => {\n            const rowNode = this.lookupRowNode(item);\n            if (!rowNode) {\n                return;\n            }\n            rowNode.updateData(item);\n            if (!rowNode.selectable && rowNode.isSelected()) {\n                nodesToUnselect.push(rowNode);\n            }\n            this.setMasterForRow(rowNode, item, ClientSideNodeManager.TOP_LEVEL, false);\n            rowNodeTransaction.update.push(rowNode);\n        });\n    }\n    lookupRowNode(data) {\n        const getRowIdFunc = this.gridOptionsService.getCallback('getRowId');\n        let rowNode;\n        if (getRowIdFunc) {\n            // find rowNode using id\n            const id = getRowIdFunc({ data, level: 0 });\n            rowNode = this.allNodesMap[id];\n            if (!rowNode) {\n                console.error(`AG Grid: could not find row id=${id}, data item was not found for this id`);\n                return null;\n            }\n        }\n        else {\n            // find rowNode using object references\n            rowNode = this.rootNode.allLeafChildren.find(node => node.data === data);\n            if (!rowNode) {\n                console.error(`AG Grid: could not find data item as object was not found`, data);\n                console.error(`Consider using getRowId to help the Grid find matching row data`);\n                return null;\n            }\n        }\n        return rowNode || null;\n    }\n    createNode(dataItem, parent, level) {\n        const node = new RowNode(this.beans);\n        node.group = false;\n        this.setMasterForRow(node, dataItem, level, true);\n        if (parent && !this.suppressParentsInRowNodes) {\n            node.parent = parent;\n        }\n        node.level = level;\n        node.setDataAndId(dataItem, this.nextId.toString());\n        if (this.allNodesMap[node.id]) {\n            console.warn(`AG Grid: duplicate node id '${node.id}' detected from getRowId callback, this could cause issues in your grid.`);\n        }\n        this.allNodesMap[node.id] = node;\n        this.nextId++;\n        return node;\n    }\n    setMasterForRow(rowNode, data, level, setExpanded) {\n        const isTreeData = this.gridOptionsService.is('treeData');\n        if (isTreeData) {\n            rowNode.setMaster(false);\n            if (setExpanded) {\n                rowNode.expanded = false;\n            }\n        }\n        else {\n            // this is the default, for when doing grid data\n            if (this.doingMasterDetail) {\n                // if we are doing master detail, then the\n                // default is that everything can be a Master Row.\n                if (this.isRowMasterFunc) {\n                    rowNode.setMaster(this.isRowMasterFunc(data));\n                }\n                else {\n                    rowNode.setMaster(true);\n                }\n            }\n            else {\n                rowNode.setMaster(false);\n            }\n            if (setExpanded) {\n                const rowGroupColumns = this.columnModel.getRowGroupColumns();\n                const numRowGroupColumns = rowGroupColumns ? rowGroupColumns.length : 0;\n                // need to take row group into account when determining level\n                const masterRowLevel = level + numRowGroupColumns;\n                rowNode.expanded = rowNode.master ? this.isExpanded(masterRowLevel) : false;\n            }\n        }\n    }\n    isExpanded(level) {\n        const expandByDefault = this.gridOptionsService.getNum('groupDefaultExpanded');\n        if (expandByDefault === -1) {\n            return true;\n        }\n        return level < expandByDefault;\n    }\n}\nClientSideNodeManager.TOP_LEVEL = 0;\nClientSideNodeManager.ROOT_NODE_ID = 'ROOT_NODE_ID';\n", "var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nimport { _, Autowired, Bean, BeanStub, ChangedPath, Events, Optional, PostConstruct, ClientSideRowModelSteps, RowNode, RowHighlightPosition, } from \"@ag-grid-community/core\";\nimport { ClientSideNodeManager } from \"./clientSideNodeManager.mjs\";\nvar RecursionType;\n(function (RecursionType) {\n    RecursionType[RecursionType[\"Normal\"] = 0] = \"Normal\";\n    RecursionType[RecursionType[\"AfterFilter\"] = 1] = \"AfterFilter\";\n    RecursionType[RecursionType[\"AfterFilterAndSort\"] = 2] = \"AfterFilterAndSort\";\n    RecursionType[RecursionType[\"PivotNodes\"] = 3] = \"PivotNodes\";\n})(RecursionType || (RecursionType = {}));\nlet ClientSideRowModel = class ClientSideRowModel extends BeanStub {\n    constructor() {\n        super(...arguments);\n        this.onRowHeightChanged_debounced = _.debounce(this.onRowHeightChanged.bind(this), 100);\n        this.rowsToDisplay = []; // the rows mapped to rows to display\n    }\n    init() {\n        const refreshEverythingFunc = this.refreshModel.bind(this, { step: ClientSideRowModelSteps.EVERYTHING });\n        const animate = !this.gridOptionsService.is('suppressAnimationFrame');\n        const refreshEverythingAfterColsChangedFunc = this.refreshModel.bind(this, {\n            step: ClientSideRowModelSteps.EVERYTHING,\n            afterColumnsChanged: true,\n            keepRenderedRows: true,\n            animate\n        });\n        this.addManagedListener(this.eventService, Events.EVENT_NEW_COLUMNS_LOADED, refreshEverythingAfterColsChangedFunc);\n        this.addManagedListener(this.eventService, Events.EVENT_COLUMN_ROW_GROUP_CHANGED, refreshEverythingFunc);\n        this.addManagedListener(this.eventService, Events.EVENT_COLUMN_VALUE_CHANGED, this.onValueChanged.bind(this));\n        this.addManagedListener(this.eventService, Events.EVENT_COLUMN_PIVOT_CHANGED, this.refreshModel.bind(this, { step: ClientSideRowModelSteps.PIVOT }));\n        this.addManagedListener(this.eventService, Events.EVENT_FILTER_CHANGED, this.onFilterChanged.bind(this));\n        this.addManagedListener(this.eventService, Events.EVENT_SORT_CHANGED, this.onSortChanged.bind(this));\n        this.addManagedListener(this.eventService, Events.EVENT_COLUMN_PIVOT_MODE_CHANGED, refreshEverythingFunc);\n        this.addManagedListener(this.eventService, Events.EVENT_GRID_STYLES_CHANGED, this.onGridStylesChanges.bind(this));\n        const refreshMapListener = this.refreshModel.bind(this, {\n            step: ClientSideRowModelSteps.MAP,\n            keepRenderedRows: true,\n            animate\n        });\n        this.addManagedPropertyListeners([\n            'groupRemoveSingleChildren', 'groupRemoveLowestSingleChildren',\n            'groupIncludeFooter',\n        ], refreshMapListener);\n        const refreshAggListener = this.refreshModel.bind(this, {\n            step: ClientSideRowModelSteps.AGGREGATE,\n            keepRenderedRows: true,\n            animate\n        });\n        this.addManagedPropertyListeners([\n            'groupIncludeTotalFooter',\n        ], refreshAggListener);\n        this.rootNode = new RowNode(this.beans);\n        this.nodeManager = new ClientSideNodeManager(this.rootNode, this.gridOptionsService, this.eventService, this.columnModel, this.selectionService, this.beans);\n        this.addManagedPropertyListener('treeData', () => {\n            // Shotgun reset all node state. This is used by treeData reactivity to ensure nodes don't include any group state\n            this.setRowData(this.rootNode.allLeafChildren.map(child => child.data));\n        });\n    }\n    start() {\n        const rowData = this.gridOptionsService.get('rowData');\n        if (rowData) {\n            this.setRowData(rowData);\n        }\n    }\n    ensureRowHeightsValid(startPixel, endPixel, startLimitIndex, endLimitIndex) {\n        let atLeastOneChange;\n        let res = false;\n        // we do this multiple times as changing the row heights can also change the first and last rows,\n        // so the first pass can make lots of rows smaller, which means the second pass we end up changing\n        // more rows.\n        do {\n            atLeastOneChange = false;\n            const rowAtStartPixel = this.getRowIndexAtPixel(startPixel);\n            const rowAtEndPixel = this.getRowIndexAtPixel(endPixel);\n            // keep check to current page if doing pagination\n            const firstRow = Math.max(rowAtStartPixel, startLimitIndex);\n            const lastRow = Math.min(rowAtEndPixel, endLimitIndex);\n            for (let rowIndex = firstRow; rowIndex <= lastRow; rowIndex++) {\n                const rowNode = this.getRow(rowIndex);\n                if (rowNode.rowHeightEstimated) {\n                    const rowHeight = this.gridOptionsService.getRowHeightForNode(rowNode);\n                    rowNode.setRowHeight(rowHeight.height);\n                    atLeastOneChange = true;\n                    res = true;\n                }\n            }\n            if (atLeastOneChange) {\n                this.setRowTopAndRowIndex();\n            }\n        } while (atLeastOneChange);\n        return res;\n    }\n    setRowTopAndRowIndex() {\n        const defaultRowHeight = this.environment.getDefaultRowHeight();\n        let nextRowTop = 0;\n        // mapping displayed rows is not needed for this method, however it's used in\n        // clearRowTopAndRowIndex(), and given we are looping through this.rowsToDisplay here,\n        // we create the map here for performance reasons, so we don't loop a second time\n        // in clearRowTopAndRowIndex()\n        const displayedRowsMapped = new Set();\n        // we don't estimate if doing fullHeight or autoHeight, as all rows get rendered all the time\n        // with these two layouts.\n        const allowEstimate = this.gridOptionsService.isDomLayout('normal');\n        for (let i = 0; i < this.rowsToDisplay.length; i++) {\n            const rowNode = this.rowsToDisplay[i];\n            if (rowNode.id != null) {\n                displayedRowsMapped.add(rowNode.id);\n            }\n            if (rowNode.rowHeight == null) {\n                const rowHeight = this.gridOptionsService.getRowHeightForNode(rowNode, allowEstimate, defaultRowHeight);\n                rowNode.setRowHeight(rowHeight.height, rowHeight.estimated);\n            }\n            rowNode.setRowTop(nextRowTop);\n            rowNode.setRowIndex(i);\n            nextRowTop += rowNode.rowHeight;\n        }\n        return displayedRowsMapped;\n    }\n    clearRowTopAndRowIndex(changedPath, displayedRowsMapped) {\n        const changedPathActive = changedPath.isActive();\n        const clearIfNotDisplayed = (rowNode) => {\n            if (rowNode && rowNode.id != null && !displayedRowsMapped.has(rowNode.id)) {\n                rowNode.clearRowTopAndRowIndex();\n            }\n        };\n        const recurse = (rowNode) => {\n            clearIfNotDisplayed(rowNode);\n            clearIfNotDisplayed(rowNode.detailNode);\n            clearIfNotDisplayed(rowNode.sibling);\n            if (rowNode.hasChildren()) {\n                if (rowNode.childrenAfterGroup) {\n                    // if a changedPath is active, it means we are here because of a transaction update or\n                    // a change detection. neither of these impacts the open/closed state of groups. so if\n                    // a group is not open this time, it was not open last time. so we know all closed groups\n                    // already have their top positions cleared. so there is no need to traverse all the way\n                    // when changedPath is active and the rowNode is not expanded.\n                    const isRootNode = rowNode.level == -1; // we need to give special consideration for root node,\n                    // as expanded=undefined for root node\n                    const skipChildren = changedPathActive && !isRootNode && !rowNode.expanded;\n                    if (!skipChildren) {\n                        rowNode.childrenAfterGroup.forEach(recurse);\n                    }\n                }\n            }\n        };\n        recurse(this.rootNode);\n    }\n    // returns false if row was moved, otherwise true\n    ensureRowsAtPixel(rowNodes, pixel, increment = 0) {\n        const indexAtPixelNow = this.getRowIndexAtPixel(pixel);\n        const rowNodeAtPixelNow = this.getRow(indexAtPixelNow);\n        const animate = !this.gridOptionsService.is('suppressAnimationFrame');\n        if (rowNodeAtPixelNow === rowNodes[0]) {\n            return false;\n        }\n        rowNodes.forEach(rowNode => {\n            _.removeFromArray(this.rootNode.allLeafChildren, rowNode);\n        });\n        rowNodes.forEach((rowNode, idx) => {\n            _.insertIntoArray(this.rootNode.allLeafChildren, rowNode, Math.max(indexAtPixelNow + increment, 0) + idx);\n        });\n        this.refreshModel({\n            step: ClientSideRowModelSteps.EVERYTHING,\n            keepRenderedRows: true,\n            keepEditingRows: true,\n            animate\n        });\n        return true;\n    }\n    highlightRowAtPixel(rowNode, pixel) {\n        const indexAtPixelNow = pixel != null ? this.getRowIndexAtPixel(pixel) : null;\n        const rowNodeAtPixelNow = indexAtPixelNow != null ? this.getRow(indexAtPixelNow) : null;\n        if (!rowNodeAtPixelNow || !rowNode || rowNodeAtPixelNow === rowNode || pixel == null) {\n            if (this.lastHighlightedRow) {\n                this.lastHighlightedRow.setHighlighted(null);\n                this.lastHighlightedRow = null;\n            }\n            return;\n        }\n        const highlight = this.getHighlightPosition(pixel, rowNodeAtPixelNow);\n        if (this.lastHighlightedRow && this.lastHighlightedRow !== rowNodeAtPixelNow) {\n            this.lastHighlightedRow.setHighlighted(null);\n            this.lastHighlightedRow = null;\n        }\n        rowNodeAtPixelNow.setHighlighted(highlight);\n        this.lastHighlightedRow = rowNodeAtPixelNow;\n    }\n    getHighlightPosition(pixel, rowNode) {\n        if (!rowNode) {\n            const index = this.getRowIndexAtPixel(pixel);\n            rowNode = this.getRow(index || 0);\n            if (!rowNode) {\n                return RowHighlightPosition.Below;\n            }\n        }\n        const { rowTop, rowHeight } = rowNode;\n        return pixel - rowTop < rowHeight / 2 ? RowHighlightPosition.Above : RowHighlightPosition.Below;\n    }\n    getLastHighlightedRowNode() {\n        return this.lastHighlightedRow;\n    }\n    isLastRowIndexKnown() {\n        return true;\n    }\n    getRowCount() {\n        if (this.rowsToDisplay) {\n            return this.rowsToDisplay.length;\n        }\n        return 0;\n    }\n    getTopLevelRowCount() {\n        const showingRootNode = this.rowsToDisplay && this.rowsToDisplay[0] === this.rootNode;\n        if (showingRootNode) {\n            return 1;\n        }\n        const filteredChildren = this.rootNode.childrenAfterAggFilter;\n        return filteredChildren ? filteredChildren.length : 0;\n    }\n    getTopLevelRowDisplayedIndex(topLevelIndex) {\n        const showingRootNode = this.rowsToDisplay && this.rowsToDisplay[0] === this.rootNode;\n        if (showingRootNode) {\n            return topLevelIndex;\n        }\n        let rowNode = this.rootNode.childrenAfterSort[topLevelIndex];\n        if (this.gridOptionsService.is('groupHideOpenParents')) {\n            // if hideOpenParents, and this row open, then this row is now displayed at this index, first child is\n            while (rowNode.expanded && rowNode.childrenAfterSort && rowNode.childrenAfterSort.length > 0) {\n                rowNode = rowNode.childrenAfterSort[0];\n            }\n        }\n        return rowNode.rowIndex;\n    }\n    getRowBounds(index) {\n        if (_.missing(this.rowsToDisplay)) {\n            return null;\n        }\n        const rowNode = this.rowsToDisplay[index];\n        if (rowNode) {\n            return {\n                rowTop: rowNode.rowTop,\n                rowHeight: rowNode.rowHeight\n            };\n        }\n        return null;\n    }\n    onRowGroupOpened() {\n        const animate = this.gridOptionsService.isAnimateRows();\n        this.refreshModel({ step: ClientSideRowModelSteps.MAP, keepRenderedRows: true, animate: animate });\n    }\n    onFilterChanged(event) {\n        if (event.afterDataChange) {\n            return;\n        }\n        const animate = this.gridOptionsService.isAnimateRows();\n        const primaryOrQuickFilterChanged = event.columns.length === 0 || event.columns.some(col => col.isPrimary());\n        const step = primaryOrQuickFilterChanged ? ClientSideRowModelSteps.FILTER : ClientSideRowModelSteps.FILTER_AGGREGATES;\n        this.refreshModel({ step: step, keepRenderedRows: true, animate: animate });\n    }\n    onSortChanged() {\n        const animate = this.gridOptionsService.isAnimateRows();\n        this.refreshModel({ step: ClientSideRowModelSteps.SORT, keepRenderedRows: true, animate: animate, keepEditingRows: true });\n    }\n    getType() {\n        return 'clientSide';\n    }\n    onValueChanged() {\n        if (this.columnModel.isPivotActive()) {\n            this.refreshModel({ step: ClientSideRowModelSteps.PIVOT });\n        }\n        else {\n            this.refreshModel({ step: ClientSideRowModelSteps.AGGREGATE });\n        }\n    }\n    createChangePath(rowNodeTransactions) {\n        // for updates, if the row is updated at all, then we re-calc all the values\n        // in that row. we could compare each value to each old value, however if we\n        // did this, we would be calling the valueService twice, once on the old value\n        // and once on the new value. so it's less valueGetter calls if we just assume\n        // each column is different. that way the changedPath is used so that only\n        // the impacted parent rows are recalculated, parents who's children have\n        // not changed are not impacted.\n        const noTransactions = _.missingOrEmpty(rowNodeTransactions);\n        const changedPath = new ChangedPath(false, this.rootNode);\n        if (noTransactions || this.gridOptionsService.is('treeData')) {\n            changedPath.setInactive();\n        }\n        return changedPath;\n    }\n    isSuppressModelUpdateAfterUpdateTransaction(params) {\n        if (!this.gridOptionsService.is('suppressModelUpdateAfterUpdateTransaction')) {\n            return false;\n        }\n        // return true if we are only doing update transactions\n        if (params.rowNodeTransactions == null) {\n            return false;\n        }\n        const transWithAddsOrDeletes = params.rowNodeTransactions.filter(tx => (tx.add != null && tx.add.length > 0) || (tx.remove != null && tx.remove.length > 0));\n        const transactionsContainUpdatesOnly = transWithAddsOrDeletes == null || transWithAddsOrDeletes.length == 0;\n        return transactionsContainUpdatesOnly;\n    }\n    buildRefreshModelParams(step) {\n        let paramsStep = ClientSideRowModelSteps.EVERYTHING;\n        const stepsMapped = {\n            everything: ClientSideRowModelSteps.EVERYTHING,\n            group: ClientSideRowModelSteps.EVERYTHING,\n            filter: ClientSideRowModelSteps.FILTER,\n            map: ClientSideRowModelSteps.MAP,\n            aggregate: ClientSideRowModelSteps.AGGREGATE,\n            sort: ClientSideRowModelSteps.SORT,\n            pivot: ClientSideRowModelSteps.PIVOT\n        };\n        if (_.exists(step)) {\n            paramsStep = stepsMapped[step];\n        }\n        if (_.missing(paramsStep)) {\n            console.error(`AG Grid: invalid step ${step}, available steps are ${Object.keys(stepsMapped).join(', ')}`);\n            return undefined;\n        }\n        const animate = !this.gridOptionsService.is('suppressAnimationFrame');\n        const modelParams = {\n            step: paramsStep,\n            keepRenderedRows: true,\n            keepEditingRows: true,\n            animate\n        };\n        return modelParams;\n    }\n    refreshModel(paramsOrStep) {\n        let params = typeof paramsOrStep === 'object' && \"step\" in paramsOrStep ? paramsOrStep : this.buildRefreshModelParams(paramsOrStep);\n        if (!params) {\n            return;\n        }\n        if (this.isSuppressModelUpdateAfterUpdateTransaction(params)) {\n            return;\n        }\n        // this goes through the pipeline of stages. what's in my head is similar\n        // to the diagram on this page:\n        // http://commons.apache.org/sandbox/commons-pipeline/pipeline_basics.html\n        // however we want to keep the results of each stage, hence we manually call\n        // each step rather than have them chain each other.\n        // fallthrough in below switch is on purpose,\n        // eg if STEP_FILTER, then all steps below this\n        // step get done\n        // let start: number;\n        // console.log('======= start =======');\n        const changedPath = this.createChangePath(params.rowNodeTransactions);\n        switch (params.step) {\n            case ClientSideRowModelSteps.EVERYTHING:\n                this.doRowGrouping(params.groupState, params.rowNodeTransactions, params.rowNodeOrder, changedPath, !!params.afterColumnsChanged);\n            case ClientSideRowModelSteps.FILTER:\n                this.doFilter(changedPath);\n            case ClientSideRowModelSteps.PIVOT:\n                this.doPivot(changedPath);\n            case ClientSideRowModelSteps.AGGREGATE: // depends on agg fields\n                this.doAggregate(changedPath);\n            case ClientSideRowModelSteps.FILTER_AGGREGATES:\n                this.doFilterAggregates(changedPath);\n            case ClientSideRowModelSteps.SORT:\n                this.doSort(params.rowNodeTransactions, changedPath);\n            case ClientSideRowModelSteps.MAP:\n                this.doRowsToDisplay();\n        }\n        // set all row tops to null, then set row tops on all visible rows. if we don't\n        // do this, then the algorithm below only sets row tops, old row tops from old rows\n        // will still lie around\n        const displayedNodesMapped = this.setRowTopAndRowIndex();\n        this.clearRowTopAndRowIndex(changedPath, displayedNodesMapped);\n        const event = {\n            type: Events.EVENT_MODEL_UPDATED,\n            animate: params.animate,\n            keepRenderedRows: params.keepRenderedRows,\n            newData: params.newData,\n            newPage: false,\n            keepUndoRedoStack: params.keepUndoRedoStack\n        };\n        this.eventService.dispatchEvent(event);\n    }\n    isEmpty() {\n        const rowsMissing = _.missing(this.rootNode.allLeafChildren) || this.rootNode.allLeafChildren.length === 0;\n        return _.missing(this.rootNode) || rowsMissing || !this.columnModel.isReady();\n    }\n    isRowsToRender() {\n        return _.exists(this.rowsToDisplay) && this.rowsToDisplay.length > 0;\n    }\n    getNodesInRangeForSelection(firstInRange, lastInRange) {\n        // if lastSelectedNode is missing, we start at the first row\n        let started = !lastInRange;\n        let finished = false;\n        const result = [];\n        const groupsSelectChildren = this.gridOptionsService.is('groupSelectsChildren');\n        this.forEachNodeAfterFilterAndSort(rowNode => {\n            // range has been closed, skip till end\n            if (finished) {\n                return;\n            }\n            if (started) {\n                if (rowNode === lastInRange || rowNode === firstInRange) {\n                    // check if this is the last node we're going to be adding\n                    finished = true;\n                    // if the final node was a group node, and we're doing groupSelectsChildren\n                    // make the exception to select all of it's descendants too\n                    if (rowNode.group && groupsSelectChildren) {\n                        result.push(...rowNode.allLeafChildren);\n                        return;\n                    }\n                }\n            }\n            if (!started) {\n                if (rowNode !== lastInRange && rowNode !== firstInRange) {\n                    // still haven't hit a boundary node, keep searching\n                    return;\n                }\n                started = true;\n            }\n            // only select leaf nodes if groupsSelectChildren\n            const includeThisNode = !rowNode.group || !groupsSelectChildren;\n            if (includeThisNode) {\n                result.push(rowNode);\n                return;\n            }\n        });\n        return result;\n    }\n    setDatasource(datasource) {\n        console.error('AG Grid: should never call setDatasource on clientSideRowController');\n    }\n    getTopLevelNodes() {\n        return this.rootNode ? this.rootNode.childrenAfterGroup : null;\n    }\n    getRootNode() {\n        return this.rootNode;\n    }\n    getRow(index) {\n        return this.rowsToDisplay[index];\n    }\n    isRowPresent(rowNode) {\n        return this.rowsToDisplay.indexOf(rowNode) >= 0;\n    }\n    getRowIndexAtPixel(pixelToMatch) {\n        if (this.isEmpty() || this.rowsToDisplay.length === 0) {\n            return -1;\n        }\n        // do binary search of tree\n        // http://oli.me.uk/2013/06/08/searching-javascript-arrays-with-a-binary-search/\n        let bottomPointer = 0;\n        let topPointer = this.rowsToDisplay.length - 1;\n        // quick check, if the pixel is out of bounds, then return last row\n        if (pixelToMatch <= 0) {\n            // if pixel is less than or equal zero, it's always the first row\n            return 0;\n        }\n        const lastNode = _.last(this.rowsToDisplay);\n        if (lastNode.rowTop <= pixelToMatch) {\n            return this.rowsToDisplay.length - 1;\n        }\n        let oldBottomPointer = -1;\n        let oldTopPointer = -1;\n        while (true) {\n            const midPointer = Math.floor((bottomPointer + topPointer) / 2);\n            const currentRowNode = this.rowsToDisplay[midPointer];\n            if (this.isRowInPixel(currentRowNode, pixelToMatch)) {\n                return midPointer;\n            }\n            if (currentRowNode.rowTop < pixelToMatch) {\n                bottomPointer = midPointer + 1;\n            }\n            else if (currentRowNode.rowTop > pixelToMatch) {\n                topPointer = midPointer - 1;\n            }\n            // infinite loops happen when there is space between rows. this can happen\n            // when Auto Height is active, cos we re-calculate row tops asyncronously\n            // when row heights change, which can temporarly result in gaps between rows.\n            const caughtInInfiniteLoop = oldBottomPointer === bottomPointer\n                && oldTopPointer === topPointer;\n            if (caughtInInfiniteLoop) {\n                return midPointer;\n            }\n            oldBottomPointer = bottomPointer;\n            oldTopPointer = topPointer;\n        }\n    }\n    isRowInPixel(rowNode, pixelToMatch) {\n        const topPixel = rowNode.rowTop;\n        const bottomPixel = rowNode.rowTop + rowNode.rowHeight;\n        const pixelInRow = topPixel <= pixelToMatch && bottomPixel > pixelToMatch;\n        return pixelInRow;\n    }\n    forEachLeafNode(callback) {\n        if (this.rootNode.allLeafChildren) {\n            this.rootNode.allLeafChildren.forEach((rowNode, index) => callback(rowNode, index));\n        }\n    }\n    forEachNode(callback, includeFooterNodes = false) {\n        this.recursivelyWalkNodesAndCallback({\n            nodes: [...(this.rootNode.childrenAfterGroup || [])],\n            callback,\n            recursionType: RecursionType.Normal,\n            index: 0,\n            includeFooterNodes\n        });\n    }\n    forEachNodeAfterFilter(callback, includeFooterNodes = false) {\n        this.recursivelyWalkNodesAndCallback({\n            nodes: [...(this.rootNode.childrenAfterAggFilter || [])],\n            callback,\n            recursionType: RecursionType.AfterFilter,\n            index: 0,\n            includeFooterNodes\n        });\n    }\n    forEachNodeAfterFilterAndSort(callback, includeFooterNodes = false) {\n        this.recursivelyWalkNodesAndCallback({\n            nodes: [...(this.rootNode.childrenAfterSort || [])],\n            callback,\n            recursionType: RecursionType.AfterFilterAndSort,\n            index: 0,\n            includeFooterNodes\n        });\n    }\n    forEachPivotNode(callback, includeFooterNodes = false) {\n        this.recursivelyWalkNodesAndCallback({\n            nodes: [this.rootNode],\n            callback,\n            recursionType: RecursionType.PivotNodes,\n            index: 0,\n            includeFooterNodes\n        });\n    }\n    // iterates through each item in memory, and calls the callback function\n    // nodes - the rowNodes to traverse\n    // callback - the user provided callback\n    // recursion type - need this to know what child nodes to recurse, eg if looking at all nodes, or filtered notes etc\n    // index - works similar to the index in forEach in javascript's array function\n    recursivelyWalkNodesAndCallback(params) {\n        var _a;\n        const { nodes, callback, recursionType, includeFooterNodes } = params;\n        let { index } = params;\n        for (let i = 0; i < nodes.length; i++) {\n            const node = nodes[i];\n            callback(node, index++);\n            // go to the next level if it is a group\n            if (node.hasChildren() && !node.footer) {\n                // depending on the recursion type, we pick a difference set of children\n                let nodeChildren = null;\n                switch (recursionType) {\n                    case RecursionType.Normal:\n                        nodeChildren = node.childrenAfterGroup;\n                        break;\n                    case RecursionType.AfterFilter:\n                        nodeChildren = node.childrenAfterAggFilter;\n                        break;\n                    case RecursionType.AfterFilterAndSort:\n                        nodeChildren = node.childrenAfterSort;\n                        break;\n                    case RecursionType.PivotNodes:\n                        // for pivot, we don't go below leafGroup levels\n                        nodeChildren = !node.leafGroup ? node.childrenAfterSort : null;\n                        break;\n                }\n                if (nodeChildren) {\n                    index = this.recursivelyWalkNodesAndCallback({\n                        nodes: [...nodeChildren],\n                        callback,\n                        recursionType,\n                        index,\n                        includeFooterNodes\n                    });\n                }\n            }\n        }\n        const parentNode = (_a = nodes[0]) === null || _a === void 0 ? void 0 : _a.parent;\n        if (!includeFooterNodes || !parentNode)\n            return index;\n        const isRootNode = parentNode === this.rootNode;\n        if (isRootNode) {\n            const totalFooters = this.gridOptionsService.is('groupIncludeTotalFooter');\n            if (!totalFooters)\n                return index;\n        }\n        else {\n            const isGroupIncludeFooter = this.gridOptionsService.getGroupIncludeFooter();\n            if (!isGroupIncludeFooter({ node: parentNode }))\n                return index;\n        }\n        parentNode.createFooter();\n        callback(parentNode.sibling, index++);\n        return index;\n    }\n    // it's possible to recompute the aggregate without doing the other parts\n    // + api.refreshClientSideRowModel('aggregate')\n    doAggregate(changedPath) {\n        if (this.aggregationStage) {\n            this.aggregationStage.execute({ rowNode: this.rootNode, changedPath: changedPath });\n        }\n    }\n    doFilterAggregates(changedPath) {\n        if (this.filterAggregatesStage) {\n            this.filterAggregatesStage.execute({ rowNode: this.rootNode, changedPath: changedPath });\n        }\n        else {\n            // If filterAggregatesStage is undefined, then so is the grouping stage, so all children should be on the rootNode.\n            this.rootNode.childrenAfterAggFilter = this.rootNode.childrenAfterFilter;\n        }\n    }\n    // + gridApi.expandAll()\n    // + gridApi.collapseAll()\n    expandOrCollapseAll(expand) {\n        const usingTreeData = this.gridOptionsService.is('treeData');\n        const usingPivotMode = this.columnModel.isPivotActive();\n        const recursiveExpandOrCollapse = (rowNodes) => {\n            if (!rowNodes) {\n                return;\n            }\n            rowNodes.forEach(rowNode => {\n                const actionRow = () => {\n                    rowNode.expanded = expand;\n                    recursiveExpandOrCollapse(rowNode.childrenAfterGroup);\n                };\n                if (usingTreeData) {\n                    const hasChildren = _.exists(rowNode.childrenAfterGroup);\n                    if (hasChildren) {\n                        actionRow();\n                    }\n                    return;\n                }\n                if (usingPivotMode) {\n                    const notLeafGroup = !rowNode.leafGroup;\n                    if (notLeafGroup) {\n                        actionRow();\n                    }\n                    return;\n                }\n                const isRowGroup = rowNode.group;\n                if (isRowGroup) {\n                    actionRow();\n                }\n            });\n        };\n        if (this.rootNode) {\n            recursiveExpandOrCollapse(this.rootNode.childrenAfterGroup);\n        }\n        this.refreshModel({ step: ClientSideRowModelSteps.MAP });\n        const eventSource = expand ? 'expandAll' : 'collapseAll';\n        const event = {\n            type: Events.EVENT_EXPAND_COLLAPSE_ALL,\n            source: eventSource\n        };\n        this.eventService.dispatchEvent(event);\n    }\n    doSort(rowNodeTransactions, changedPath) {\n        this.sortStage.execute({\n            rowNode: this.rootNode,\n            rowNodeTransactions: rowNodeTransactions,\n            changedPath: changedPath\n        });\n    }\n    doRowGrouping(groupState, rowNodeTransactions, rowNodeOrder, changedPath, afterColumnsChanged) {\n        if (this.groupStage) {\n            if (rowNodeTransactions) {\n                this.groupStage.execute({\n                    rowNode: this.rootNode,\n                    rowNodeTransactions: rowNodeTransactions,\n                    rowNodeOrder: rowNodeOrder,\n                    changedPath: changedPath\n                });\n            }\n            else {\n                this.groupStage.execute({\n                    rowNode: this.rootNode,\n                    changedPath: changedPath,\n                    afterColumnsChanged: afterColumnsChanged\n                });\n                // set open/closed state on groups\n                this.restoreGroupState(groupState);\n            }\n            if (this.gridOptionsService.is('groupSelectsChildren')) {\n                const selectionChanged = this.selectionService.updateGroupsFromChildrenSelections('rowGroupChanged', changedPath);\n                if (selectionChanged) {\n                    const event = {\n                        type: Events.EVENT_SELECTION_CHANGED,\n                        source: 'rowGroupChanged'\n                    };\n                    this.eventService.dispatchEvent(event);\n                }\n            }\n        }\n        else {\n            this.rootNode.childrenAfterGroup = this.rootNode.allLeafChildren;\n            if (this.rootNode.sibling) {\n                this.rootNode.sibling.childrenAfterGroup = this.rootNode.childrenAfterGroup;\n            }\n            this.rootNode.updateHasChildren();\n        }\n    }\n    restoreGroupState(groupState) {\n        if (!groupState) {\n            return;\n        }\n        _.traverseNodesWithKey(this.rootNode.childrenAfterGroup, (node, key) => {\n            // if the group was open last time, then open it this time. however\n            // if was not open last time, then don't touch the group, so the 'groupDefaultExpanded'\n            // setting will take effect.\n            if (typeof groupState[key] === 'boolean') {\n                node.expanded = groupState[key];\n            }\n        });\n    }\n    doFilter(changedPath) {\n        this.filterStage.execute({ rowNode: this.rootNode, changedPath: changedPath });\n    }\n    doPivot(changedPath) {\n        if (this.pivotStage) {\n            this.pivotStage.execute({ rowNode: this.rootNode, changedPath: changedPath });\n        }\n    }\n    getGroupState() {\n        if (!this.rootNode.childrenAfterGroup || !this.gridOptionsService.is('rememberGroupStateWhenNewData')) {\n            return null;\n        }\n        const result = {};\n        _.traverseNodesWithKey(this.rootNode.childrenAfterGroup, (node, key) => result[key] = node.expanded);\n        return result;\n    }\n    getCopyOfNodesMap() {\n        return this.nodeManager.getCopyOfNodesMap();\n    }\n    getRowNode(id) {\n        // although id is typed a string, this could be called by the user, and they could have passed a number\n        const idIsGroup = typeof id == 'string' && id.indexOf(RowNode.ID_PREFIX_ROW_GROUP) == 0;\n        if (idIsGroup) {\n            // only one users complained about getRowNode not working for groups, after years of\n            // this working for normal rows. so have done quick implementation. if users complain\n            // about performance, then GroupStage should store / manage created groups in a map,\n            // which is a chunk of work.\n            let res = undefined;\n            this.forEachNode(node => {\n                if (node.id === id) {\n                    res = node;\n                }\n            });\n            return res;\n        }\n        return this.nodeManager.getRowNode(id);\n    }\n    // rows: the rows to put into the model\n    setRowData(rowData) {\n        // no need to invalidate cache, as the cache is stored on the rowNode,\n        // so new rowNodes means the cache is wiped anyway.\n        // remember group state, so we can expand groups that should be expanded\n        const groupState = this.getGroupState();\n        this.nodeManager.setRowData(rowData);\n        // - clears selection\n        this.selectionService.reset();\n        // - updates filters\n        this.filterManager.onNewRowsLoaded('rowDataUpdated');\n        // this event kicks off:\n        // - shows 'no rows' overlay if needed\n        const rowDataUpdatedEvent = {\n            type: Events.EVENT_ROW_DATA_UPDATED\n        };\n        this.eventService.dispatchEvent(rowDataUpdatedEvent);\n        this.refreshModel({\n            step: ClientSideRowModelSteps.EVERYTHING,\n            groupState: groupState,\n            newData: true\n        });\n    }\n    batchUpdateRowData(rowDataTransaction, callback) {\n        if (this.applyAsyncTransactionsTimeout == null) {\n            this.rowDataTransactionBatch = [];\n            const waitMillis = this.gridOptionsService.getAsyncTransactionWaitMillis();\n            this.applyAsyncTransactionsTimeout = window.setTimeout(() => {\n                this.executeBatchUpdateRowData();\n            }, waitMillis);\n        }\n        this.rowDataTransactionBatch.push({ rowDataTransaction: rowDataTransaction, callback: callback });\n    }\n    flushAsyncTransactions() {\n        if (this.applyAsyncTransactionsTimeout != null) {\n            clearTimeout(this.applyAsyncTransactionsTimeout);\n            this.executeBatchUpdateRowData();\n        }\n    }\n    executeBatchUpdateRowData() {\n        this.valueCache.onDataChanged();\n        const callbackFuncsBound = [];\n        const rowNodeTrans = [];\n        // The rowGroup stage uses rowNodeOrder if order was provided. if we didn't pass 'true' to\n        // commonUpdateRowData, using addIndex would have no effect when grouping.\n        let forceRowNodeOrder = false;\n        if (this.rowDataTransactionBatch) {\n            this.rowDataTransactionBatch.forEach(tranItem => {\n                const rowNodeTran = this.nodeManager.updateRowData(tranItem.rowDataTransaction, undefined);\n                rowNodeTrans.push(rowNodeTran);\n                if (tranItem.callback) {\n                    callbackFuncsBound.push(tranItem.callback.bind(null, rowNodeTran));\n                }\n                if (typeof tranItem.rowDataTransaction.addIndex === 'number') {\n                    forceRowNodeOrder = true;\n                }\n            });\n        }\n        this.commonUpdateRowData(rowNodeTrans, undefined, forceRowNodeOrder);\n        // do callbacks in next VM turn so it's async\n        if (callbackFuncsBound.length > 0) {\n            window.setTimeout(() => {\n                callbackFuncsBound.forEach(func => func());\n            }, 0);\n        }\n        if (rowNodeTrans.length > 0) {\n            const event = {\n                type: Events.EVENT_ASYNC_TRANSACTIONS_FLUSHED,\n                results: rowNodeTrans\n            };\n            this.eventService.dispatchEvent(event);\n        }\n        this.rowDataTransactionBatch = null;\n        this.applyAsyncTransactionsTimeout = undefined;\n    }\n    updateRowData(rowDataTran, rowNodeOrder) {\n        this.valueCache.onDataChanged();\n        const rowNodeTran = this.nodeManager.updateRowData(rowDataTran, rowNodeOrder);\n        // if doing immutableData, addIndex is never present. however if doing standard transaction, and user\n        // provided addIndex, then this is used in updateRowData. However if doing Enterprise, then the rowGroup\n        // stage also uses the\n        const forceRowNodeOrder = typeof rowDataTran.addIndex === 'number';\n        this.commonUpdateRowData([rowNodeTran], rowNodeOrder, forceRowNodeOrder);\n        return rowNodeTran;\n    }\n    createRowNodeOrder() {\n        const suppressSortOrder = this.gridOptionsService.is('suppressMaintainUnsortedOrder');\n        if (suppressSortOrder) {\n            return;\n        }\n        const orderMap = {};\n        if (this.rootNode && this.rootNode.allLeafChildren) {\n            for (let index = 0; index < this.rootNode.allLeafChildren.length; index++) {\n                const node = this.rootNode.allLeafChildren[index];\n                orderMap[node.id] = index;\n            }\n        }\n        return orderMap;\n    }\n    // common to updateRowData and batchUpdateRowData\n    commonUpdateRowData(rowNodeTrans, rowNodeOrder, forceRowNodeOrder) {\n        const animate = !this.gridOptionsService.is('suppressAnimationFrame');\n        if (forceRowNodeOrder) {\n            rowNodeOrder = this.createRowNodeOrder();\n        }\n        this.refreshModel({\n            step: ClientSideRowModelSteps.EVERYTHING,\n            rowNodeTransactions: rowNodeTrans,\n            rowNodeOrder: rowNodeOrder,\n            keepRenderedRows: true,\n            keepEditingRows: true,\n            animate\n        });\n        // - updates filters\n        this.filterManager.onNewRowsLoaded('rowDataUpdated');\n        const event = {\n            type: Events.EVENT_ROW_DATA_UPDATED\n        };\n        this.eventService.dispatchEvent(event);\n    }\n    doRowsToDisplay() {\n        this.rowsToDisplay = this.flattenStage.execute({ rowNode: this.rootNode });\n    }\n    onRowHeightChanged() {\n        this.refreshModel({ step: ClientSideRowModelSteps.MAP, keepRenderedRows: true, keepEditingRows: true, keepUndoRedoStack: true });\n    }\n    /** This method is debounced. It is used for row auto-height. If we don't debounce,\n     * then the Row Models will end up recalculating each row position\n     * for each row height change and result in the Row Renderer laying out rows.\n     * This is particularly bad if using print layout, and showing eg 1,000 rows,\n     * each row will change it's height, causing Row Model to update 1,000 times.\n     */\n    onRowHeightChangedDebounced() {\n        this.onRowHeightChanged_debounced();\n    }\n    resetRowHeights() {\n        const atLeastOne = this.resetRowHeightsForAllRowNodes();\n        this.rootNode.setRowHeight(this.rootNode.rowHeight, true);\n        if (this.rootNode.sibling) {\n            this.rootNode.sibling.setRowHeight(this.rootNode.sibling.rowHeight, true);\n        }\n        // when pivotMode but pivot not active, root node is displayed on its own\n        // because it's only ever displayed alone, refreshing the model (onRowHeightChanged) is not required\n        if (atLeastOne) {\n            this.onRowHeightChanged();\n        }\n    }\n    resetRowHeightsForAllRowNodes() {\n        let atLeastOne = false;\n        this.forEachNode(rowNode => {\n            rowNode.setRowHeight(rowNode.rowHeight, true);\n            // we keep the height each row is at, however we set estimated=true rather than clear the height.\n            // this means the grid will not reset the row heights back to defaults, rather it will re-calc\n            // the height for each row as the row is displayed. otherwise the scroll will jump when heights are reset.\n            const detailNode = rowNode.detailNode;\n            if (detailNode) {\n                detailNode.setRowHeight(detailNode.rowHeight, true);\n            }\n            if (rowNode.sibling) {\n                rowNode.sibling.setRowHeight(rowNode.sibling.rowHeight, true);\n            }\n            atLeastOne = true;\n        });\n        return atLeastOne;\n    }\n    onGridStylesChanges() {\n        if (this.columnModel.isAutoRowHeightActive()) {\n            return;\n        }\n        this.resetRowHeights();\n    }\n};\n__decorate([\n    Autowired('columnModel')\n], ClientSideRowModel.prototype, \"columnModel\", void 0);\n__decorate([\n    Autowired('selectionService')\n], ClientSideRowModel.prototype, \"selectionService\", void 0);\n__decorate([\n    Autowired('filterManager')\n], ClientSideRowModel.prototype, \"filterManager\", void 0);\n__decorate([\n    Autowired('valueCache')\n], ClientSideRowModel.prototype, \"valueCache\", void 0);\n__decorate([\n    Autowired('beans')\n], ClientSideRowModel.prototype, \"beans\", void 0);\n__decorate([\n    Autowired('filterStage')\n], ClientSideRowModel.prototype, \"filterStage\", void 0);\n__decorate([\n    Autowired('sortStage')\n], ClientSideRowModel.prototype, \"sortStage\", void 0);\n__decorate([\n    Autowired('flattenStage')\n], ClientSideRowModel.prototype, \"flattenStage\", void 0);\n__decorate([\n    Optional('groupStage')\n], ClientSideRowModel.prototype, \"groupStage\", void 0);\n__decorate([\n    Optional('aggregationStage')\n], ClientSideRowModel.prototype, \"aggregationStage\", void 0);\n__decorate([\n    Optional('pivotStage')\n], ClientSideRowModel.prototype, \"pivotStage\", void 0);\n__decorate([\n    Optional('filterAggregatesStage')\n], ClientSideRowModel.prototype, \"filterAggregatesStage\", void 0);\n__decorate([\n    PostConstruct\n], ClientSideRowModel.prototype, \"init\", null);\nClientSideRowModel = __decorate([\n    Bean('rowModel')\n], ClientSideRowModel);\nexport { ClientSideRowModel };\n", "var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nimport { Autowired, Bean, BeanStub } from \"@ag-grid-community/core\";\nlet FilterStage = class FilterStage extends BeanStub {\n    execute(params) {\n        const { changedPath } = params;\n        this.filterService.filter(changedPath);\n    }\n};\n__decorate([\n    Autowired('filterService')\n], FilterStage.prototype, \"filterService\", void 0);\nFilterStage = __decorate([\n    Bean('filterStage')\n], FilterStage);\nexport { FilterStage };\n", "var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nimport { _, Autowired, Bean, BeanStub } from \"@ag-grid-community/core\";\nlet SortStage = class SortStage extends BeanStub {\n    execute(params) {\n        const sortOptions = this.sortController.getSortOptions();\n        const sortActive = _.exists(sortOptions) && sortOptions.length > 0;\n        const deltaSort = sortActive\n            && _.exists(params.rowNodeTransactions)\n            // in time we can remove this check, so that delta sort is always\n            // on if transactions are present. it's off for now so that we can\n            // selectively turn it on and test it with some select users before\n            // rolling out to everyone.\n            && this.gridOptionsService.is('deltaSort');\n        const sortContainsGroupColumns = sortOptions.some(opt => {\n            const isSortingCoupled = this.gridOptionsService.isColumnsSortingCoupledToGroup();\n            if (isSortingCoupled) {\n                return opt.column.isPrimary() && opt.column.isRowGroupActive();\n            }\n            return !!opt.column.getColDef().showRowGroup;\n        });\n        this.sortService.sort(sortOptions, sortActive, deltaSort, params.rowNodeTransactions, params.changedPath, sortContainsGroupColumns);\n    }\n};\n__decorate([\n    Autowired('sortService')\n], SortStage.prototype, \"sortService\", void 0);\n__decorate([\n    Autowired('sortController')\n], SortStage.prototype, \"sortController\", void 0);\n__decorate([\n    Autowired('columnModel')\n], SortStage.prototype, \"columnModel\", void 0);\nSortStage = __decorate([\n    Bean('sortStage')\n], SortStage);\nexport { SortStage };\n", "var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nimport { _, Autowired, Bean, BeanStub, RowNode } from \"@ag-grid-community/core\";\nlet FlattenStage = class FlattenStage extends BeanStub {\n    execute(params) {\n        const rootNode = params.rowNode;\n        // even if not doing grouping, we do the mapping, as the client might\n        // of passed in data that already has a grouping in it somewhere\n        const result = [];\n        const skipLeafNodes = this.columnModel.isPivotMode();\n        // if we are reducing, and not grouping, then we want to show the root node, as that\n        // is where the pivot values are\n        const showRootNode = skipLeafNodes && rootNode.leafGroup;\n        const topList = showRootNode ? [rootNode] : rootNode.childrenAfterSort;\n        const details = this.getFlattenDetails();\n        this.recursivelyAddToRowsToDisplay(details, topList, result, skipLeafNodes, 0);\n        // we do not want the footer total if the gris is empty\n        const atLeastOneRowPresent = result.length > 0;\n        const includeGroupTotalFooter = !showRootNode\n            // don't show total footer when showRootNode is true (i.e. in pivot mode and no groups)\n            && atLeastOneRowPresent\n            && details.groupIncludeTotalFooter;\n        if (includeGroupTotalFooter) {\n            rootNode.createFooter();\n            this.addRowNodeToRowsToDisplay(details, rootNode.sibling, result, 0);\n        }\n        return result;\n    }\n    getFlattenDetails() {\n        // these two are mutually exclusive, so if first set, we don't set the second\n        const groupRemoveSingleChildren = this.gridOptionsService.is('groupRemoveSingleChildren');\n        const groupRemoveLowestSingleChildren = !groupRemoveSingleChildren && this.gridOptionsService.is('groupRemoveLowestSingleChildren');\n        return {\n            groupRemoveLowestSingleChildren,\n            groupRemoveSingleChildren,\n            isGroupMultiAutoColumn: this.gridOptionsService.isGroupMultiAutoColumn(),\n            hideOpenParents: this.gridOptionsService.is('groupHideOpenParents'),\n            groupIncludeTotalFooter: this.gridOptionsService.is('groupIncludeTotalFooter'),\n            getGroupIncludeFooter: this.gridOptionsService.getGroupIncludeFooter(),\n        };\n    }\n    recursivelyAddToRowsToDisplay(details, rowsToFlatten, result, skipLeafNodes, uiLevel) {\n        if (_.missingOrEmpty(rowsToFlatten)) {\n            return;\n        }\n        for (let i = 0; i < rowsToFlatten.length; i++) {\n            const rowNode = rowsToFlatten[i];\n            // check all these cases, for working out if this row should be included in the final mapped list\n            const isParent = rowNode.hasChildren();\n            const isSkippedLeafNode = skipLeafNodes && !isParent;\n            const isRemovedSingleChildrenGroup = details.groupRemoveSingleChildren && isParent && rowNode.childrenAfterGroup.length === 1;\n            const isRemovedLowestSingleChildrenGroup = details.groupRemoveLowestSingleChildren &&\n                isParent &&\n                rowNode.leafGroup &&\n                rowNode.childrenAfterGroup.length === 1;\n            // hide open parents means when group is open, we don't show it. we also need to make sure the\n            // group is expandable in the first place (as leaf groups are not expandable if pivot mode is on).\n            // the UI will never allow expanding leaf  groups, however the user might via the API (or menu option 'expand all row groups')\n            const neverAllowToExpand = skipLeafNodes && rowNode.leafGroup;\n            const isHiddenOpenParent = details.hideOpenParents && rowNode.expanded && !rowNode.master && !neverAllowToExpand;\n            const thisRowShouldBeRendered = !isSkippedLeafNode && !isHiddenOpenParent &&\n                !isRemovedSingleChildrenGroup && !isRemovedLowestSingleChildrenGroup;\n            if (thisRowShouldBeRendered) {\n                this.addRowNodeToRowsToDisplay(details, rowNode, result, uiLevel);\n            }\n            // if we are pivoting, we never map below the leaf group\n            if (skipLeafNodes && rowNode.leafGroup) {\n                continue;\n            }\n            if (isParent) {\n                const excludedParent = isRemovedSingleChildrenGroup || isRemovedLowestSingleChildrenGroup;\n                // we traverse the group if it is expended, however we always traverse if the parent node\n                // was removed (as the group will never be opened if it is not displayed, we show the children instead)\n                if (rowNode.expanded || excludedParent) {\n                    // if the parent was excluded, then ui level is that of the parent\n                    const uiLevelForChildren = excludedParent ? uiLevel : uiLevel + 1;\n                    this.recursivelyAddToRowsToDisplay(details, rowNode.childrenAfterSort, result, skipLeafNodes, uiLevelForChildren);\n                    // put a footer in if user is looking for it\n                    const doesRowShowFooter = details.getGroupIncludeFooter({ node: rowNode });\n                    if (doesRowShowFooter) {\n                        // ensure node is available.\n                        rowNode.createFooter();\n                        this.addRowNodeToRowsToDisplay(details, rowNode.sibling, result, uiLevelForChildren);\n                    }\n                    else {\n                        // remove node if it's unnecessary.\n                        rowNode.destroyFooter();\n                    }\n                }\n            }\n            else if (rowNode.master && rowNode.expanded) {\n                const detailNode = this.createDetailNode(rowNode);\n                this.addRowNodeToRowsToDisplay(details, detailNode, result, uiLevel);\n            }\n        }\n    }\n    // duplicated method, it's also in floatingRowModel\n    addRowNodeToRowsToDisplay(details, rowNode, result, uiLevel) {\n        result.push(rowNode);\n        rowNode.setUiLevel(details.isGroupMultiAutoColumn ? 0 : uiLevel);\n    }\n    createDetailNode(masterNode) {\n        if (_.exists(masterNode.detailNode)) {\n            return masterNode.detailNode;\n        }\n        const detailNode = new RowNode(this.beans);\n        detailNode.detail = true;\n        detailNode.selectable = false;\n        detailNode.parent = masterNode;\n        if (_.exists(masterNode.id)) {\n            detailNode.id = 'detail_' + masterNode.id;\n        }\n        detailNode.data = masterNode.data;\n        detailNode.level = masterNode.level + 1;\n        masterNode.detailNode = detailNode;\n        return detailNode;\n    }\n};\n__decorate([\n    Autowired('columnModel')\n], FlattenStage.prototype, \"columnModel\", void 0);\n__decorate([\n    Autowired('beans')\n], FlattenStage.prototype, \"beans\", void 0);\nFlattenStage = __decorate([\n    Bean('flattenStage')\n], FlattenStage);\nexport { FlattenStage };\n", "var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nimport { _, Autowired, Bean, PostConstruct, BeanStub } from \"@ag-grid-community/core\";\nlet SortService = class SortService extends BeanStub {\n    init() {\n        this.postSortFunc = this.gridOptionsService.getCallback('postSortRows');\n    }\n    sort(sortOptions, sortActive, useDeltaSort, rowNodeTransactions, changedPath, sortContainsGroupColumns) {\n        const groupMaintainOrder = this.gridOptionsService.is('groupMaintainOrder');\n        const groupColumnsPresent = this.columnModel.getAllGridColumns().some(c => c.isRowGroupActive());\n        let allDirtyNodes = {};\n        if (useDeltaSort && rowNodeTransactions) {\n            allDirtyNodes = this.calculateDirtyNodes(rowNodeTransactions);\n        }\n        const isPivotMode = this.columnModel.isPivotMode();\n        const callback = (rowNode) => {\n            // we clear out the 'pull down open parents' first, as the values mix up the sorting\n            this.pullDownGroupDataForHideOpenParents(rowNode.childrenAfterAggFilter, true);\n            // It's pointless to sort rows which aren't being displayed. in pivot mode we don't need to sort the leaf group children.\n            const skipSortingPivotLeafs = isPivotMode && rowNode.leafGroup;\n            // Javascript sort is non deterministic when all the array items are equals, ie Comparator always returns 0,\n            // so to ensure the array keeps its order, add an additional sorting condition manually, in this case we\n            // are going to inspect the original array position. This is what sortedRowNodes is for.\n            let skipSortingGroups = groupMaintainOrder && groupColumnsPresent && !rowNode.leafGroup && !sortContainsGroupColumns;\n            if (skipSortingGroups) {\n                const childrenToBeSorted = rowNode.childrenAfterAggFilter.slice(0);\n                if (rowNode.childrenAfterSort) {\n                    const indexedOrders = {};\n                    rowNode.childrenAfterSort.forEach((node, idx) => {\n                        indexedOrders[node.id] = idx;\n                    });\n                    childrenToBeSorted.sort((row1, row2) => { var _a, _b; return ((_a = indexedOrders[row1.id]) !== null && _a !== void 0 ? _a : 0) - ((_b = indexedOrders[row2.id]) !== null && _b !== void 0 ? _b : 0); });\n                }\n                rowNode.childrenAfterSort = childrenToBeSorted;\n            }\n            else if (!sortActive || skipSortingPivotLeafs) {\n                // if there's no sort to make, skip this step\n                rowNode.childrenAfterSort = rowNode.childrenAfterAggFilter.slice(0);\n            }\n            else if (useDeltaSort) {\n                rowNode.childrenAfterSort = this.doDeltaSort(rowNode, allDirtyNodes, changedPath, sortOptions);\n            }\n            else {\n                rowNode.childrenAfterSort = this.rowNodeSorter.doFullSort(rowNode.childrenAfterAggFilter, sortOptions);\n            }\n            if (rowNode.sibling) {\n                rowNode.sibling.childrenAfterSort = rowNode.childrenAfterSort;\n            }\n            this.updateChildIndexes(rowNode);\n            if (this.postSortFunc) {\n                const params = { nodes: rowNode.childrenAfterSort };\n                this.postSortFunc(params);\n            }\n        };\n        if (changedPath) {\n            changedPath.forEachChangedNodeDepthFirst(callback);\n        }\n        this.updateGroupDataForHideOpenParents(changedPath);\n    }\n    calculateDirtyNodes(rowNodeTransactions) {\n        const dirtyNodes = {};\n        const addNodesFunc = (rowNodes) => {\n            if (rowNodes) {\n                rowNodes.forEach(rowNode => dirtyNodes[rowNode.id] = true);\n            }\n        };\n        // all leaf level nodes in the transaction were impacted\n        if (rowNodeTransactions) {\n            rowNodeTransactions.forEach(tran => {\n                addNodesFunc(tran.add);\n                addNodesFunc(tran.update);\n                addNodesFunc(tran.remove);\n            });\n        }\n        return dirtyNodes;\n    }\n    doDeltaSort(rowNode, allTouchedNodes, changedPath, sortOptions) {\n        const unsortedRows = rowNode.childrenAfterAggFilter;\n        const oldSortedRows = rowNode.childrenAfterSort;\n        if (!oldSortedRows) {\n            return this.rowNodeSorter.doFullSort(unsortedRows, sortOptions);\n        }\n        const untouchedRowsMap = {};\n        const touchedRows = [];\n        unsortedRows.forEach(row => {\n            if (allTouchedNodes[row.id] || !changedPath.canSkip(row)) {\n                touchedRows.push(row);\n            }\n            else {\n                untouchedRowsMap[row.id] = true;\n            }\n        });\n        const sortedUntouchedRows = oldSortedRows.filter(child => untouchedRowsMap[child.id]);\n        const mapNodeToSortedNode = (rowNode, pos) => ({ currentPos: pos, rowNode: rowNode });\n        const sortedChangedRows = touchedRows\n            .map(mapNodeToSortedNode)\n            .sort((a, b) => this.rowNodeSorter.compareRowNodes(sortOptions, a, b));\n        return this.mergeSortedArrays(sortOptions, sortedChangedRows, sortedUntouchedRows.map(mapNodeToSortedNode)).map(({ rowNode }) => rowNode);\n    }\n    // Merge two sorted arrays into each other\n    mergeSortedArrays(sortOptions, arr1, arr2) {\n        const res = [];\n        let i = 0;\n        let j = 0;\n        // Traverse both array, adding them in order\n        while (i < arr1.length && j < arr2.length) {\n            // Check if current element of first\n            // array is smaller than current element\n            // of second array. If yes, store first\n            // array element and increment first array\n            // index. Otherwise do same with second array\n            const compareResult = this.rowNodeSorter.compareRowNodes(sortOptions, arr1[i], arr2[j]);\n            if (compareResult < 0) {\n                res.push(arr1[i++]);\n            }\n            else {\n                res.push(arr2[j++]);\n            }\n        }\n        // add remaining from arr1\n        while (i < arr1.length) {\n            res.push(arr1[i++]);\n        }\n        // add remaining from arr2\n        while (j < arr2.length) {\n            res.push(arr2[j++]);\n        }\n        return res;\n    }\n    updateChildIndexes(rowNode) {\n        if (_.missing(rowNode.childrenAfterSort)) {\n            return;\n        }\n        const listToSort = rowNode.childrenAfterSort;\n        for (let i = 0; i < listToSort.length; i++) {\n            const child = listToSort[i];\n            const firstChild = i === 0;\n            const lastChild = i === rowNode.childrenAfterSort.length - 1;\n            child.setFirstChild(firstChild);\n            child.setLastChild(lastChild);\n            child.setChildIndex(i);\n        }\n    }\n    updateGroupDataForHideOpenParents(changedPath) {\n        if (!this.gridOptionsService.is('groupHideOpenParents')) {\n            return;\n        }\n        if (this.gridOptionsService.is('treeData')) {\n            const msg = `AG Grid: The property hideOpenParents dose not work with Tree Data. This is because Tree Data has values at the group level, it doesn't make sense to hide them (as opposed to Row Grouping, which only has Aggregated Values at the group level).`;\n            _.doOnce(() => console.warn(msg), 'sortService.hideOpenParentsWithTreeData');\n            return false;\n        }\n        // recurse breadth first over group nodes after sort to 'pull down' group data to child groups\n        const callback = (rowNode) => {\n            this.pullDownGroupDataForHideOpenParents(rowNode.childrenAfterSort, false);\n            rowNode.childrenAfterSort.forEach(child => {\n                if (child.hasChildren()) {\n                    callback(child);\n                }\n            });\n        };\n        if (changedPath) {\n            changedPath.executeFromRootNode(rowNode => callback(rowNode));\n        }\n    }\n    pullDownGroupDataForHideOpenParents(rowNodes, clearOperation) {\n        if (!this.gridOptionsService.is('groupHideOpenParents') || _.missing(rowNodes)) {\n            return;\n        }\n        rowNodes.forEach(childRowNode => {\n            const groupDisplayCols = this.columnModel.getGroupDisplayColumns();\n            groupDisplayCols.forEach(groupDisplayCol => {\n                const showRowGroup = groupDisplayCol.getColDef().showRowGroup;\n                if (typeof showRowGroup !== 'string') {\n                    console.error('AG Grid: groupHideOpenParents only works when specifying specific columns for colDef.showRowGroup');\n                    return;\n                }\n                const displayingGroupKey = showRowGroup;\n                const rowGroupColumn = this.columnModel.getPrimaryColumn(displayingGroupKey);\n                const thisRowNodeMatches = rowGroupColumn === childRowNode.rowGroupColumn;\n                if (thisRowNodeMatches) {\n                    return;\n                }\n                if (clearOperation) {\n                    // if doing a clear operation, we clear down the value for every possible group column\n                    childRowNode.setGroupValue(groupDisplayCol.getId(), undefined);\n                }\n                else {\n                    // if doing a set operation, we set only where the pull down is to occur\n                    const parentToStealFrom = childRowNode.getFirstChildOfFirstChild(rowGroupColumn);\n                    if (parentToStealFrom) {\n                        childRowNode.setGroupValue(groupDisplayCol.getId(), parentToStealFrom.key);\n                    }\n                }\n            });\n        });\n    }\n};\n__decorate([\n    Autowired('columnModel')\n], SortService.prototype, \"columnModel\", void 0);\n__decorate([\n    Autowired('rowNodeSorter')\n], SortService.prototype, \"rowNodeSorter\", void 0);\n__decorate([\n    PostConstruct\n], SortService.prototype, \"init\", null);\nSortService = __decorate([\n    Bean('sortService')\n], SortService);\nexport { SortService };\n", "var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nimport { Autowired, Bean, BeanStub } from \"@ag-grid-community/core\";\nlet FilterService = class FilterService extends BeanStub {\n    filter(changedPath) {\n        const filterActive = this.filterManager.isChildFilterPresent();\n        this.filterNodes(filterActive, changedPath);\n    }\n    filterNodes(filterActive, changedPath) {\n        const filterCallback = (rowNode, includeChildNodes) => {\n            // recursively get all children that are groups to also filter\n            if (rowNode.hasChildren()) {\n                // result of filter for this node. when filtering tree data, includeChildNodes = true when parent passes\n                if (filterActive && !includeChildNodes) {\n                    rowNode.childrenAfterFilter = rowNode.childrenAfterGroup.filter(childNode => {\n                        // a group is included in the result if it has any children of it's own.\n                        // by this stage, the child groups are already filtered\n                        const passBecauseChildren = childNode.childrenAfterFilter && childNode.childrenAfterFilter.length > 0;\n                        // both leaf level nodes and tree data nodes have data. these get added if\n                        // the data passes the filter\n                        const passBecauseDataPasses = childNode.data\n                            && this.filterManager.doesRowPassFilter({ rowNode: childNode });\n                        // note - tree data nodes pass either if a) they pass themselves or b) any children of that node pass\n                        return passBecauseChildren || passBecauseDataPasses;\n                    });\n                }\n                else {\n                    // if not filtering, the result is the original list\n                    rowNode.childrenAfterFilter = rowNode.childrenAfterGroup;\n                }\n            }\n            else {\n                rowNode.childrenAfterFilter = rowNode.childrenAfterGroup;\n            }\n            if (rowNode.sibling) {\n                rowNode.sibling.childrenAfterFilter = rowNode.childrenAfterFilter;\n            }\n        };\n        if (this.doingTreeDataFiltering()) {\n            const treeDataDepthFirstFilter = (rowNode, alreadyFoundInParent) => {\n                // tree data filter traverses the hierarchy depth first and includes child nodes if parent passes\n                // filter, and parent nodes will be include if any children exist.\n                if (rowNode.childrenAfterGroup) {\n                    for (let i = 0; i < rowNode.childrenAfterGroup.length; i++) {\n                        const childNode = rowNode.childrenAfterGroup[i];\n                        // first check if current node passes filter before invoking child nodes\n                        const foundInParent = alreadyFoundInParent\n                            || this.filterManager.doesRowPassFilter({ rowNode: childNode });\n                        if (childNode.childrenAfterGroup) {\n                            treeDataDepthFirstFilter(rowNode.childrenAfterGroup[i], foundInParent);\n                        }\n                        else {\n                            filterCallback(childNode, foundInParent);\n                        }\n                    }\n                }\n                filterCallback(rowNode, alreadyFoundInParent);\n            };\n            const treeDataFilterCallback = (rowNode) => treeDataDepthFirstFilter(rowNode, false);\n            changedPath.executeFromRootNode(treeDataFilterCallback);\n        }\n        else {\n            const defaultFilterCallback = (rowNode) => filterCallback(rowNode, false);\n            changedPath.forEachChangedNodeDepthFirst(defaultFilterCallback, true);\n        }\n    }\n    doingTreeDataFiltering() {\n        return this.gridOptionsService.is('treeData') && !this.gridOptionsService.is('excludeChildrenWhenTreeDataFiltering');\n    }\n};\n__decorate([\n    Autowired('filterManager')\n], FilterService.prototype, \"filterManager\", void 0);\nFilterService = __decorate([\n    Bean(\"filterService\")\n], FilterService);\nexport { FilterService };\n", "var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nimport { Autowired, Bean, BeanStub, PostConstruct, _ } from \"@ag-grid-community/core\";\nlet ImmutableService = class ImmutableService extends BeanStub {\n    postConstruct() {\n        if (this.rowModel.getType() === 'clientSide') {\n            this.clientSideRowModel = this.rowModel;\n        }\n    }\n    isActive() {\n        const getRowIdProvided = this.gridOptionsService.exists('getRowId');\n        // this property is a backwards compatibility property, for those who want\n        // the old behaviour of Row ID's but NOT Immutable Data.\n        const resetRowDataOnUpdate = this.gridOptionsService.is('resetRowDataOnUpdate');\n        if (resetRowDataOnUpdate) {\n            return false;\n        }\n        return getRowIdProvided;\n    }\n    setRowData(rowData) {\n        const transactionAndMap = this.createTransactionForRowData(rowData);\n        if (!transactionAndMap) {\n            return;\n        }\n        const [transaction, orderIdMap] = transactionAndMap;\n        this.clientSideRowModel.updateRowData(transaction, orderIdMap);\n    }\n    // converts the setRowData() command to a transaction\n    createTransactionForRowData(rowData) {\n        if (_.missing(this.clientSideRowModel)) {\n            console.error('AG Grid: ImmutableService only works with ClientSideRowModel');\n            return;\n        }\n        const getRowIdFunc = this.gridOptionsService.getCallback('getRowId');\n        if (getRowIdFunc == null) {\n            console.error('AG Grid: ImmutableService requires getRowId() callback to be implemented, your row data needs IDs!');\n            return;\n        }\n        // convert the data into a transaction object by working out adds, removes and updates\n        const transaction = {\n            remove: [],\n            update: [],\n            add: []\n        };\n        const existingNodesMap = this.clientSideRowModel.getCopyOfNodesMap();\n        const suppressSortOrder = this.gridOptionsService.is('suppressMaintainUnsortedOrder');\n        const orderMap = suppressSortOrder ? undefined : {};\n        if (_.exists(rowData)) {\n            // split all the new data in the following:\n            // if new, push to 'add'\n            // if update, push to 'update'\n            // if not changed, do not include in the transaction\n            rowData.forEach((data, index) => {\n                const id = getRowIdFunc({ data, level: 0 });\n                const existingNode = existingNodesMap[id];\n                if (orderMap) {\n                    orderMap[id] = index;\n                }\n                if (existingNode) {\n                    const dataHasChanged = existingNode.data !== data;\n                    if (dataHasChanged) {\n                        transaction.update.push(data);\n                    }\n                    // otherwise, if data not changed, we just don't include it anywhere, as it's not a delta\n                    // remove from list, so we know the item is not to be removed\n                    existingNodesMap[id] = undefined;\n                }\n                else {\n                    transaction.add.push(data);\n                }\n            });\n        }\n        // at this point, all rows that are left, should be removed\n        _.iterateObject(existingNodesMap, (id, rowNode) => {\n            if (rowNode) {\n                transaction.remove.push(rowNode.data);\n            }\n        });\n        return [transaction, orderMap];\n    }\n};\n__decorate([\n    Autowired('rowModel')\n], ImmutableService.prototype, \"rowModel\", void 0);\n__decorate([\n    Autowired('rowRenderer')\n], ImmutableService.prototype, \"rowRenderer\", void 0);\n__decorate([\n    PostConstruct\n], ImmutableService.prototype, \"postConstruct\", null);\nImmutableService = __decorate([\n    Bean('immutableService')\n], ImmutableService);\nexport { ImmutableService };\n", "// DO NOT UPDATE MANUALLY: Generated from script during build time\nexport const VERSION = '30.2.1';\n", "import { ModuleNames } from \"@ag-grid-community/core\";\nimport { ClientSideRowModel } from \"./clientSideRowModel/clientSideRowModel.mjs\";\nimport { FilterStage } from \"./clientSideRowModel/filterStage.mjs\";\nimport { SortStage } from \"./clientSideRowModel/sortStage.mjs\";\nimport { FlattenStage } from \"./clientSideRowModel/flattenStage.mjs\";\nimport { SortService } from \"./clientSideRowModel/sortService.mjs\";\nimport { FilterService } from \"./clientSideRowModel/filterService.mjs\";\nimport { ImmutableService } from \"./clientSideRowModel/immutableService.mjs\";\nimport { VERSION } from \"./version.mjs\";\nexport const ClientSideRowModelModule = {\n    version: VERSION,\n    moduleName: ModuleNames.ClientSideRowModelModule,\n    rowModel: 'clientSide',\n    beans: [ClientSideRowModel, FilterStage, SortStage, FlattenStage, SortService, FilterService, ImmutableService],\n};\n"],
  "mappings": ";;;;;;;;;;;;;;;;;AACO,IAAM,wBAAN,MAAM,uBAAsB;AAAA,EAC/B,YAAY,UAAU,oBAAoB,cAAc,aAAa,kBAAkB,OAAO;AAC1F,SAAK,SAAS;AAEd,SAAK,cAAc,CAAC;AACpB,SAAK,WAAW;AAChB,SAAK,qBAAqB;AAC1B,SAAK,eAAe;AACpB,SAAK,cAAc;AACnB,SAAK,QAAQ;AACb,SAAK,mBAAmB;AACxB,SAAK,SAAS,QAAQ;AACtB,SAAK,SAAS,QAAQ;AACtB,SAAK,SAAS,KAAK,uBAAsB;AACzC,SAAK,SAAS,kBAAkB,CAAC;AACjC,SAAK,SAAS,qBAAqB,CAAC;AACpC,SAAK,SAAS,oBAAoB,CAAC;AACnC,SAAK,SAAS,yBAAyB,CAAC;AACxC,SAAK,SAAS,sBAAsB,CAAC;AAErC,SAAK,cAAc;AAAA,EACvB;AAAA;AAAA,EAEA,gBAAgB;AAEZ,SAAK,4BAA4B,KAAK,mBAAmB,GAAG,2BAA2B;AACvF,SAAK,kBAAkB,KAAK,mBAAmB,IAAI,aAAa;AAChE,SAAK,oBAAoB,KAAK,mBAAmB,GAAG,cAAc;AAAA,EACtE;AAAA,EACA,oBAAoB;AAChB,WAAO,EAAE,YAAY,KAAK,WAAW;AAAA,EACzC;AAAA,EACA,WAAW,IAAI;AACX,WAAO,KAAK,YAAY,EAAE;AAAA,EAC9B;AAAA,EACA,WAAW,SAAS;AAChB,QAAI,OAAO,YAAY,UAAU;AAC7B,cAAQ,KAAK,+JAA+J;AAC5K;AAAA,IACJ;AACA,SAAK,kCAAkC,OAAO;AAC9C,UAAM,WAAW,KAAK;AACtB,UAAM,UAAU,KAAK,SAAS;AAC9B,aAAS,sBAAsB;AAC/B,aAAS,qBAAqB;AAC9B,aAAS,yBAAyB;AAClC,aAAS,oBAAoB;AAC7B,aAAS,iBAAiB;AAC1B,aAAS,kBAAkB;AAC3B,SAAK,SAAS;AACd,SAAK,cAAc,CAAC;AACpB,QAAI,SAAS;AAIT,eAAS,kBAAkB,QAAQ,IAAI,cAAY,KAAK,WAAW,UAAU,KAAK,UAAU,uBAAsB,SAAS,CAAC;AAAA,IAChI,OACK;AACD,eAAS,kBAAkB,CAAC;AAC5B,eAAS,qBAAqB,CAAC;AAAA,IACnC;AACA,QAAI,SAAS;AACT,cAAQ,sBAAsB,SAAS;AACvC,cAAQ,qBAAqB,SAAS;AACtC,cAAQ,yBAAyB,SAAS;AAC1C,cAAQ,oBAAoB,SAAS;AACrC,cAAQ,iBAAiB,SAAS;AAClC,cAAQ,kBAAkB,SAAS;AAAA,IACvC;AAAA,EACJ;AAAA,EACA,cAAc,aAAa,cAAc;AACrC,SAAK,kCAAkC,YAAY,GAAG;AACtD,UAAM,qBAAqB;AAAA,MACvB,QAAQ,CAAC;AAAA,MACT,QAAQ,CAAC;AAAA,MACT,KAAK,CAAC;AAAA,IACV;AACA,UAAM,kBAAkB,CAAC;AACzB,SAAK,cAAc,aAAa,oBAAoB,eAAe;AACnE,SAAK,cAAc,aAAa,oBAAoB,eAAe;AACnE,SAAK,WAAW,aAAa,kBAAkB;AAC/C,SAAK,gBAAgB,iBAAiB,gBAAgB;AACtD,QAAI,cAAc;AACd,QAAE,oBAAoB,KAAK,SAAS,iBAAiB,YAAY;AAAA,IACrE;AACA,WAAO;AAAA,EACX;AAAA,EACA,kCAAkC,SAAS;AACvC,UAAM,QAAQ;AAAA,MACV,MAAM,OAAO;AAAA,MACb,eAAe,YAAY,QAAQ,YAAY,SAAS,SAAS,QAAQ,UAAU,QAAQ,CAAC,IAAI;AAAA,IACpG;AACA,SAAK,aAAa,cAAc,KAAK;AAAA,EACzC;AAAA,EACA,gBAAgB,iBAAiB,QAAQ;AACrC,UAAM,mBAAmB,gBAAgB,SAAS;AAClD,QAAI,kBAAkB;AAClB,WAAK,iBAAiB,iBAAiB;AAAA,QACnC,UAAU;AAAA,QACV,OAAO;AAAA,QACP,uBAAuB;AAAA,QACvB;AAAA,MACJ,CAAC;AAAA,IACL;AAKA,SAAK,iBAAiB,mCAAmC,MAAM;AAC/D,QAAI,kBAAkB;AAClB,YAAM,QAAQ;AAAA,QACV,MAAM,OAAO;AAAA,QACb;AAAA,MACJ;AACA,WAAK,aAAa,cAAc,KAAK;AAAA,IACzC;AAAA,EACJ;AAAA,EACA,WAAW,aAAa,oBAAoB;AACxC,QAAI;AACJ,UAAM,EAAE,KAAK,SAAS,IAAI;AAC1B,QAAI,EAAE,eAAe,GAAG,GAAG;AACvB;AAAA,IACJ;AAEA,UAAM,WAAW,IAAI,IAAI,UAAQ,KAAK,WAAW,MAAM,KAAK,UAAU,uBAAsB,SAAS,CAAC;AACtG,QAAI,OAAO,aAAa,YAAY,YAAY,GAAG;AAG/C,YAAM,EAAE,gBAAgB,IAAI,KAAK;AACjC,YAAM,MAAM,gBAAgB;AAC5B,UAAI,qBAAqB;AACzB,YAAM,aAAa,KAAK,mBAAmB,GAAG,UAAU;AACxD,UAAI,cAAc,WAAW,KAAK,MAAM,GAAG;AACvC,iBAAS,IAAI,GAAG,IAAI,KAAK,KAAK;AAC1B,gBAAM,KAAK,gBAAgB,CAAC,OAAO,QAAQ,OAAO,SAAS,SAAS,GAAG,aAAa,WAAW,GAAG;AAC9F,iCAAqB,IAAI;AACzB;AAAA,UACJ;AAAA,QACJ;AAAA,MACJ;AACA,YAAM,mBAAmB,gBAAgB,MAAM,GAAG,kBAAkB;AACpE,YAAM,kBAAkB,gBAAgB,MAAM,oBAAoB,gBAAgB,MAAM;AACxF,WAAK,SAAS,kBAAkB,CAAC,GAAG,kBAAkB,GAAG,UAAU,GAAG,eAAe;AAAA,IACzF,OACK;AACD,WAAK,SAAS,kBAAkB,CAAC,GAAG,KAAK,SAAS,iBAAiB,GAAG,QAAQ;AAAA,IAClF;AACA,QAAI,KAAK,SAAS,SAAS;AACvB,WAAK,SAAS,QAAQ,kBAAkB,KAAK,SAAS;AAAA,IAC1D;AAEA,uBAAmB,MAAM;AAAA,EAC7B;AAAA,EACA,cAAc,aAAa,oBAAoB,iBAAiB;AAC5D,UAAM,EAAE,OAAO,IAAI;AACnB,QAAI,EAAE,eAAe,MAAM,GAAG;AAC1B;AAAA,IACJ;AACA,UAAM,gBAAgB,CAAC;AACvB,WAAO,QAAQ,UAAQ;AACnB,YAAM,UAAU,KAAK,cAAc,IAAI;AACvC,UAAI,CAAC,SAAS;AACV;AAAA,MACJ;AAGA,UAAI,QAAQ,WAAW,GAAG;AACtB,wBAAgB,KAAK,OAAO;AAAA,MAChC;AAEA,cAAQ,uBAAuB;AAG/B,oBAAc,QAAQ,EAAE,IAAI;AAE5B,aAAO,KAAK,YAAY,QAAQ,EAAE;AAClC,yBAAmB,OAAO,KAAK,OAAO;AAAA,IAC1C,CAAC;AACD,SAAK,SAAS,kBAAkB,KAAK,SAAS,gBAAgB,OAAO,aAAW,CAAC,cAAc,QAAQ,EAAE,CAAC;AAC1G,QAAI,KAAK,SAAS,SAAS;AACvB,WAAK,SAAS,QAAQ,kBAAkB,KAAK,SAAS;AAAA,IAC1D;AAAA,EACJ;AAAA,EACA,cAAc,aAAa,oBAAoB,iBAAiB;AAC5D,UAAM,EAAE,OAAO,IAAI;AACnB,QAAI,EAAE,eAAe,MAAM,GAAG;AAC1B;AAAA,IACJ;AACA,WAAO,QAAQ,UAAQ;AACnB,YAAM,UAAU,KAAK,cAAc,IAAI;AACvC,UAAI,CAAC,SAAS;AACV;AAAA,MACJ;AACA,cAAQ,WAAW,IAAI;AACvB,UAAI,CAAC,QAAQ,cAAc,QAAQ,WAAW,GAAG;AAC7C,wBAAgB,KAAK,OAAO;AAAA,MAChC;AACA,WAAK,gBAAgB,SAAS,MAAM,uBAAsB,WAAW,KAAK;AAC1E,yBAAmB,OAAO,KAAK,OAAO;AAAA,IAC1C,CAAC;AAAA,EACL;AAAA,EACA,cAAc,MAAM;AAChB,UAAM,eAAe,KAAK,mBAAmB,YAAY,UAAU;AACnE,QAAI;AACJ,QAAI,cAAc;AAEd,YAAM,KAAK,aAAa,EAAE,MAAM,OAAO,EAAE,CAAC;AAC1C,gBAAU,KAAK,YAAY,EAAE;AAC7B,UAAI,CAAC,SAAS;AACV,gBAAQ,MAAM,kCAAkC,EAAE,uCAAuC;AACzF,eAAO;AAAA,MACX;AAAA,IACJ,OACK;AAED,gBAAU,KAAK,SAAS,gBAAgB,KAAK,UAAQ,KAAK,SAAS,IAAI;AACvE,UAAI,CAAC,SAAS;AACV,gBAAQ,MAAM,6DAA6D,IAAI;AAC/E,gBAAQ,MAAM,iEAAiE;AAC/E,eAAO;AAAA,MACX;AAAA,IACJ;AACA,WAAO,WAAW;AAAA,EACtB;AAAA,EACA,WAAW,UAAU,QAAQ,OAAO;AAChC,UAAM,OAAO,IAAI,QAAQ,KAAK,KAAK;AACnC,SAAK,QAAQ;AACb,SAAK,gBAAgB,MAAM,UAAU,OAAO,IAAI;AAChD,QAAI,UAAU,CAAC,KAAK,2BAA2B;AAC3C,WAAK,SAAS;AAAA,IAClB;AACA,SAAK,QAAQ;AACb,SAAK,aAAa,UAAU,KAAK,OAAO,SAAS,CAAC;AAClD,QAAI,KAAK,YAAY,KAAK,EAAE,GAAG;AAC3B,cAAQ,KAAK,+BAA+B,KAAK,EAAE,0EAA0E;AAAA,IACjI;AACA,SAAK,YAAY,KAAK,EAAE,IAAI;AAC5B,SAAK;AACL,WAAO;AAAA,EACX;AAAA,EACA,gBAAgB,SAAS,MAAM,OAAO,aAAa;AAC/C,UAAM,aAAa,KAAK,mBAAmB,GAAG,UAAU;AACxD,QAAI,YAAY;AACZ,cAAQ,UAAU,KAAK;AACvB,UAAI,aAAa;AACb,gBAAQ,WAAW;AAAA,MACvB;AAAA,IACJ,OACK;AAED,UAAI,KAAK,mBAAmB;AAGxB,YAAI,KAAK,iBAAiB;AACtB,kBAAQ,UAAU,KAAK,gBAAgB,IAAI,CAAC;AAAA,QAChD,OACK;AACD,kBAAQ,UAAU,IAAI;AAAA,QAC1B;AAAA,MACJ,OACK;AACD,gBAAQ,UAAU,KAAK;AAAA,MAC3B;AACA,UAAI,aAAa;AACb,cAAM,kBAAkB,KAAK,YAAY,mBAAmB;AAC5D,cAAM,qBAAqB,kBAAkB,gBAAgB,SAAS;AAEtE,cAAM,iBAAiB,QAAQ;AAC/B,gBAAQ,WAAW,QAAQ,SAAS,KAAK,WAAW,cAAc,IAAI;AAAA,MAC1E;AAAA,IACJ;AAAA,EACJ;AAAA,EACA,WAAW,OAAO;AACd,UAAM,kBAAkB,KAAK,mBAAmB,OAAO,sBAAsB;AAC7E,QAAI,oBAAoB,IAAI;AACxB,aAAO;AAAA,IACX;AACA,WAAO,QAAQ;AAAA,EACnB;AACJ;AACA,sBAAsB,YAAY;AAClC,sBAAsB,eAAe;;;AC1RrC,IAAI,aAA0C,SAAU,YAAY,QAAQ,KAAK,MAAM;AACnF,MAAI,IAAI,UAAU,QAAQ,IAAI,IAAI,IAAI,SAAS,SAAS,OAAO,OAAO,OAAO,yBAAyB,QAAQ,GAAG,IAAI,MAAM;AAC3H,MAAI,OAAO,YAAY,YAAY,OAAO,QAAQ,aAAa,WAAY,KAAI,QAAQ,SAAS,YAAY,QAAQ,KAAK,IAAI;AAAA,MACxH,UAAS,IAAI,WAAW,SAAS,GAAG,KAAK,GAAG,IAAK,KAAI,IAAI,WAAW,CAAC,EAAG,MAAK,IAAI,IAAI,EAAE,CAAC,IAAI,IAAI,IAAI,EAAE,QAAQ,KAAK,CAAC,IAAI,EAAE,QAAQ,GAAG,MAAM;AAChJ,SAAO,IAAI,KAAK,KAAK,OAAO,eAAe,QAAQ,KAAK,CAAC,GAAG;AAChE;AAGA,IAAI;AAAA,CACH,SAAUA,gBAAe;AACtB,EAAAA,eAAcA,eAAc,QAAQ,IAAI,CAAC,IAAI;AAC7C,EAAAA,eAAcA,eAAc,aAAa,IAAI,CAAC,IAAI;AAClD,EAAAA,eAAcA,eAAc,oBAAoB,IAAI,CAAC,IAAI;AACzD,EAAAA,eAAcA,eAAc,YAAY,IAAI,CAAC,IAAI;AACrD,GAAG,kBAAkB,gBAAgB,CAAC,EAAE;AACxC,IAAI,qBAAqB,MAAMC,4BAA2B,SAAS;AAAA,EAC/D,cAAc;AACV,UAAM,GAAG,SAAS;AAClB,SAAK,+BAA+B,EAAE,SAAS,KAAK,mBAAmB,KAAK,IAAI,GAAG,GAAG;AACtF,SAAK,gBAAgB,CAAC;AAAA,EAC1B;AAAA,EACA,OAAO;AACH,UAAM,wBAAwB,KAAK,aAAa,KAAK,MAAM,EAAE,MAAM,wBAAwB,WAAW,CAAC;AACvG,UAAM,UAAU,CAAC,KAAK,mBAAmB,GAAG,wBAAwB;AACpE,UAAM,wCAAwC,KAAK,aAAa,KAAK,MAAM;AAAA,MACvE,MAAM,wBAAwB;AAAA,MAC9B,qBAAqB;AAAA,MACrB,kBAAkB;AAAA,MAClB;AAAA,IACJ,CAAC;AACD,SAAK,mBAAmB,KAAK,cAAc,OAAO,0BAA0B,qCAAqC;AACjH,SAAK,mBAAmB,KAAK,cAAc,OAAO,gCAAgC,qBAAqB;AACvG,SAAK,mBAAmB,KAAK,cAAc,OAAO,4BAA4B,KAAK,eAAe,KAAK,IAAI,CAAC;AAC5G,SAAK,mBAAmB,KAAK,cAAc,OAAO,4BAA4B,KAAK,aAAa,KAAK,MAAM,EAAE,MAAM,wBAAwB,MAAM,CAAC,CAAC;AACnJ,SAAK,mBAAmB,KAAK,cAAc,OAAO,sBAAsB,KAAK,gBAAgB,KAAK,IAAI,CAAC;AACvG,SAAK,mBAAmB,KAAK,cAAc,OAAO,oBAAoB,KAAK,cAAc,KAAK,IAAI,CAAC;AACnG,SAAK,mBAAmB,KAAK,cAAc,OAAO,iCAAiC,qBAAqB;AACxG,SAAK,mBAAmB,KAAK,cAAc,OAAO,2BAA2B,KAAK,oBAAoB,KAAK,IAAI,CAAC;AAChH,UAAM,qBAAqB,KAAK,aAAa,KAAK,MAAM;AAAA,MACpD,MAAM,wBAAwB;AAAA,MAC9B,kBAAkB;AAAA,MAClB;AAAA,IACJ,CAAC;AACD,SAAK,4BAA4B;AAAA,MAC7B;AAAA,MAA6B;AAAA,MAC7B;AAAA,IACJ,GAAG,kBAAkB;AACrB,UAAM,qBAAqB,KAAK,aAAa,KAAK,MAAM;AAAA,MACpD,MAAM,wBAAwB;AAAA,MAC9B,kBAAkB;AAAA,MAClB;AAAA,IACJ,CAAC;AACD,SAAK,4BAA4B;AAAA,MAC7B;AAAA,IACJ,GAAG,kBAAkB;AACrB,SAAK,WAAW,IAAI,QAAQ,KAAK,KAAK;AACtC,SAAK,cAAc,IAAI,sBAAsB,KAAK,UAAU,KAAK,oBAAoB,KAAK,cAAc,KAAK,aAAa,KAAK,kBAAkB,KAAK,KAAK;AAC3J,SAAK,2BAA2B,YAAY,MAAM;AAE9C,WAAK,WAAW,KAAK,SAAS,gBAAgB,IAAI,WAAS,MAAM,IAAI,CAAC;AAAA,IAC1E,CAAC;AAAA,EACL;AAAA,EACA,QAAQ;AACJ,UAAM,UAAU,KAAK,mBAAmB,IAAI,SAAS;AACrD,QAAI,SAAS;AACT,WAAK,WAAW,OAAO;AAAA,IAC3B;AAAA,EACJ;AAAA,EACA,sBAAsB,YAAY,UAAU,iBAAiB,eAAe;AACxE,QAAI;AACJ,QAAI,MAAM;AAIV,OAAG;AACC,yBAAmB;AACnB,YAAM,kBAAkB,KAAK,mBAAmB,UAAU;AAC1D,YAAM,gBAAgB,KAAK,mBAAmB,QAAQ;AAEtD,YAAM,WAAW,KAAK,IAAI,iBAAiB,eAAe;AAC1D,YAAM,UAAU,KAAK,IAAI,eAAe,aAAa;AACrD,eAAS,WAAW,UAAU,YAAY,SAAS,YAAY;AAC3D,cAAM,UAAU,KAAK,OAAO,QAAQ;AACpC,YAAI,QAAQ,oBAAoB;AAC5B,gBAAM,YAAY,KAAK,mBAAmB,oBAAoB,OAAO;AACrE,kBAAQ,aAAa,UAAU,MAAM;AACrC,6BAAmB;AACnB,gBAAM;AAAA,QACV;AAAA,MACJ;AACA,UAAI,kBAAkB;AAClB,aAAK,qBAAqB;AAAA,MAC9B;AAAA,IACJ,SAAS;AACT,WAAO;AAAA,EACX;AAAA,EACA,uBAAuB;AACnB,UAAM,mBAAmB,KAAK,YAAY,oBAAoB;AAC9D,QAAI,aAAa;AAKjB,UAAM,sBAAsB,oBAAI,IAAI;AAGpC,UAAM,gBAAgB,KAAK,mBAAmB,YAAY,QAAQ;AAClE,aAAS,IAAI,GAAG,IAAI,KAAK,cAAc,QAAQ,KAAK;AAChD,YAAM,UAAU,KAAK,cAAc,CAAC;AACpC,UAAI,QAAQ,MAAM,MAAM;AACpB,4BAAoB,IAAI,QAAQ,EAAE;AAAA,MACtC;AACA,UAAI,QAAQ,aAAa,MAAM;AAC3B,cAAM,YAAY,KAAK,mBAAmB,oBAAoB,SAAS,eAAe,gBAAgB;AACtG,gBAAQ,aAAa,UAAU,QAAQ,UAAU,SAAS;AAAA,MAC9D;AACA,cAAQ,UAAU,UAAU;AAC5B,cAAQ,YAAY,CAAC;AACrB,oBAAc,QAAQ;AAAA,IAC1B;AACA,WAAO;AAAA,EACX;AAAA,EACA,uBAAuB,aAAa,qBAAqB;AACrD,UAAM,oBAAoB,YAAY,SAAS;AAC/C,UAAM,sBAAsB,CAAC,YAAY;AACrC,UAAI,WAAW,QAAQ,MAAM,QAAQ,CAAC,oBAAoB,IAAI,QAAQ,EAAE,GAAG;AACvE,gBAAQ,uBAAuB;AAAA,MACnC;AAAA,IACJ;AACA,UAAM,UAAU,CAAC,YAAY;AACzB,0BAAoB,OAAO;AAC3B,0BAAoB,QAAQ,UAAU;AACtC,0BAAoB,QAAQ,OAAO;AACnC,UAAI,QAAQ,YAAY,GAAG;AACvB,YAAI,QAAQ,oBAAoB;AAM5B,gBAAM,aAAa,QAAQ,SAAS;AAEpC,gBAAM,eAAe,qBAAqB,CAAC,cAAc,CAAC,QAAQ;AAClE,cAAI,CAAC,cAAc;AACf,oBAAQ,mBAAmB,QAAQ,OAAO;AAAA,UAC9C;AAAA,QACJ;AAAA,MACJ;AAAA,IACJ;AACA,YAAQ,KAAK,QAAQ;AAAA,EACzB;AAAA;AAAA,EAEA,kBAAkB,UAAU,OAAO,YAAY,GAAG;AAC9C,UAAM,kBAAkB,KAAK,mBAAmB,KAAK;AACrD,UAAM,oBAAoB,KAAK,OAAO,eAAe;AACrD,UAAM,UAAU,CAAC,KAAK,mBAAmB,GAAG,wBAAwB;AACpE,QAAI,sBAAsB,SAAS,CAAC,GAAG;AACnC,aAAO;AAAA,IACX;AACA,aAAS,QAAQ,aAAW;AACxB,QAAE,gBAAgB,KAAK,SAAS,iBAAiB,OAAO;AAAA,IAC5D,CAAC;AACD,aAAS,QAAQ,CAAC,SAAS,QAAQ;AAC/B,QAAE,gBAAgB,KAAK,SAAS,iBAAiB,SAAS,KAAK,IAAI,kBAAkB,WAAW,CAAC,IAAI,GAAG;AAAA,IAC5G,CAAC;AACD,SAAK,aAAa;AAAA,MACd,MAAM,wBAAwB;AAAA,MAC9B,kBAAkB;AAAA,MAClB,iBAAiB;AAAA,MACjB;AAAA,IACJ,CAAC;AACD,WAAO;AAAA,EACX;AAAA,EACA,oBAAoB,SAAS,OAAO;AAChC,UAAM,kBAAkB,SAAS,OAAO,KAAK,mBAAmB,KAAK,IAAI;AACzE,UAAM,oBAAoB,mBAAmB,OAAO,KAAK,OAAO,eAAe,IAAI;AACnF,QAAI,CAAC,qBAAqB,CAAC,WAAW,sBAAsB,WAAW,SAAS,MAAM;AAClF,UAAI,KAAK,oBAAoB;AACzB,aAAK,mBAAmB,eAAe,IAAI;AAC3C,aAAK,qBAAqB;AAAA,MAC9B;AACA;AAAA,IACJ;AACA,UAAM,YAAY,KAAK,qBAAqB,OAAO,iBAAiB;AACpE,QAAI,KAAK,sBAAsB,KAAK,uBAAuB,mBAAmB;AAC1E,WAAK,mBAAmB,eAAe,IAAI;AAC3C,WAAK,qBAAqB;AAAA,IAC9B;AACA,sBAAkB,eAAe,SAAS;AAC1C,SAAK,qBAAqB;AAAA,EAC9B;AAAA,EACA,qBAAqB,OAAO,SAAS;AACjC,QAAI,CAAC,SAAS;AACV,YAAM,QAAQ,KAAK,mBAAmB,KAAK;AAC3C,gBAAU,KAAK,OAAO,SAAS,CAAC;AAChC,UAAI,CAAC,SAAS;AACV,eAAO,qBAAqB;AAAA,MAChC;AAAA,IACJ;AACA,UAAM,EAAE,QAAQ,UAAU,IAAI;AAC9B,WAAO,QAAQ,SAAS,YAAY,IAAI,qBAAqB,QAAQ,qBAAqB;AAAA,EAC9F;AAAA,EACA,4BAA4B;AACxB,WAAO,KAAK;AAAA,EAChB;AAAA,EACA,sBAAsB;AAClB,WAAO;AAAA,EACX;AAAA,EACA,cAAc;AACV,QAAI,KAAK,eAAe;AACpB,aAAO,KAAK,cAAc;AAAA,IAC9B;AACA,WAAO;AAAA,EACX;AAAA,EACA,sBAAsB;AAClB,UAAM,kBAAkB,KAAK,iBAAiB,KAAK,cAAc,CAAC,MAAM,KAAK;AAC7E,QAAI,iBAAiB;AACjB,aAAO;AAAA,IACX;AACA,UAAM,mBAAmB,KAAK,SAAS;AACvC,WAAO,mBAAmB,iBAAiB,SAAS;AAAA,EACxD;AAAA,EACA,6BAA6B,eAAe;AACxC,UAAM,kBAAkB,KAAK,iBAAiB,KAAK,cAAc,CAAC,MAAM,KAAK;AAC7E,QAAI,iBAAiB;AACjB,aAAO;AAAA,IACX;AACA,QAAI,UAAU,KAAK,SAAS,kBAAkB,aAAa;AAC3D,QAAI,KAAK,mBAAmB,GAAG,sBAAsB,GAAG;AAEpD,aAAO,QAAQ,YAAY,QAAQ,qBAAqB,QAAQ,kBAAkB,SAAS,GAAG;AAC1F,kBAAU,QAAQ,kBAAkB,CAAC;AAAA,MACzC;AAAA,IACJ;AACA,WAAO,QAAQ;AAAA,EACnB;AAAA,EACA,aAAa,OAAO;AAChB,QAAI,EAAE,QAAQ,KAAK,aAAa,GAAG;AAC/B,aAAO;AAAA,IACX;AACA,UAAM,UAAU,KAAK,cAAc,KAAK;AACxC,QAAI,SAAS;AACT,aAAO;AAAA,QACH,QAAQ,QAAQ;AAAA,QAChB,WAAW,QAAQ;AAAA,MACvB;AAAA,IACJ;AACA,WAAO;AAAA,EACX;AAAA,EACA,mBAAmB;AACf,UAAM,UAAU,KAAK,mBAAmB,cAAc;AACtD,SAAK,aAAa,EAAE,MAAM,wBAAwB,KAAK,kBAAkB,MAAM,QAAiB,CAAC;AAAA,EACrG;AAAA,EACA,gBAAgB,OAAO;AACnB,QAAI,MAAM,iBAAiB;AACvB;AAAA,IACJ;AACA,UAAM,UAAU,KAAK,mBAAmB,cAAc;AACtD,UAAM,8BAA8B,MAAM,QAAQ,WAAW,KAAK,MAAM,QAAQ,KAAK,SAAO,IAAI,UAAU,CAAC;AAC3G,UAAM,OAAO,8BAA8B,wBAAwB,SAAS,wBAAwB;AACpG,SAAK,aAAa,EAAE,MAAY,kBAAkB,MAAM,QAAiB,CAAC;AAAA,EAC9E;AAAA,EACA,gBAAgB;AACZ,UAAM,UAAU,KAAK,mBAAmB,cAAc;AACtD,SAAK,aAAa,EAAE,MAAM,wBAAwB,MAAM,kBAAkB,MAAM,SAAkB,iBAAiB,KAAK,CAAC;AAAA,EAC7H;AAAA,EACA,UAAU;AACN,WAAO;AAAA,EACX;AAAA,EACA,iBAAiB;AACb,QAAI,KAAK,YAAY,cAAc,GAAG;AAClC,WAAK,aAAa,EAAE,MAAM,wBAAwB,MAAM,CAAC;AAAA,IAC7D,OACK;AACD,WAAK,aAAa,EAAE,MAAM,wBAAwB,UAAU,CAAC;AAAA,IACjE;AAAA,EACJ;AAAA,EACA,iBAAiB,qBAAqB;AAQlC,UAAM,iBAAiB,EAAE,eAAe,mBAAmB;AAC3D,UAAM,cAAc,IAAI,YAAY,OAAO,KAAK,QAAQ;AACxD,QAAI,kBAAkB,KAAK,mBAAmB,GAAG,UAAU,GAAG;AAC1D,kBAAY,YAAY;AAAA,IAC5B;AACA,WAAO;AAAA,EACX;AAAA,EACA,4CAA4C,QAAQ;AAChD,QAAI,CAAC,KAAK,mBAAmB,GAAG,2CAA2C,GAAG;AAC1E,aAAO;AAAA,IACX;AAEA,QAAI,OAAO,uBAAuB,MAAM;AACpC,aAAO;AAAA,IACX;AACA,UAAM,yBAAyB,OAAO,oBAAoB,OAAO,QAAO,GAAG,OAAO,QAAQ,GAAG,IAAI,SAAS,KAAO,GAAG,UAAU,QAAQ,GAAG,OAAO,SAAS,CAAE;AAC3J,UAAM,iCAAiC,0BAA0B,QAAQ,uBAAuB,UAAU;AAC1G,WAAO;AAAA,EACX;AAAA,EACA,wBAAwB,MAAM;AAC1B,QAAI,aAAa,wBAAwB;AACzC,UAAM,cAAc;AAAA,MAChB,YAAY,wBAAwB;AAAA,MACpC,OAAO,wBAAwB;AAAA,MAC/B,QAAQ,wBAAwB;AAAA,MAChC,KAAK,wBAAwB;AAAA,MAC7B,WAAW,wBAAwB;AAAA,MACnC,MAAM,wBAAwB;AAAA,MAC9B,OAAO,wBAAwB;AAAA,IACnC;AACA,QAAI,EAAE,OAAO,IAAI,GAAG;AAChB,mBAAa,YAAY,IAAI;AAAA,IACjC;AACA,QAAI,EAAE,QAAQ,UAAU,GAAG;AACvB,cAAQ,MAAM,yBAAyB,IAAI,yBAAyB,OAAO,KAAK,WAAW,EAAE,KAAK,IAAI,CAAC,EAAE;AACzG,aAAO;AAAA,IACX;AACA,UAAM,UAAU,CAAC,KAAK,mBAAmB,GAAG,wBAAwB;AACpE,UAAM,cAAc;AAAA,MAChB,MAAM;AAAA,MACN,kBAAkB;AAAA,MAClB,iBAAiB;AAAA,MACjB;AAAA,IACJ;AACA,WAAO;AAAA,EACX;AAAA,EACA,aAAa,cAAc;AACvB,QAAI,SAAS,OAAO,iBAAiB,YAAY,UAAU,eAAe,eAAe,KAAK,wBAAwB,YAAY;AAClI,QAAI,CAAC,QAAQ;AACT;AAAA,IACJ;AACA,QAAI,KAAK,4CAA4C,MAAM,GAAG;AAC1D;AAAA,IACJ;AAWA,UAAM,cAAc,KAAK,iBAAiB,OAAO,mBAAmB;AACpE,YAAQ,OAAO,MAAM;AAAA,MACjB,KAAK,wBAAwB;AACzB,aAAK,cAAc,OAAO,YAAY,OAAO,qBAAqB,OAAO,cAAc,aAAa,CAAC,CAAC,OAAO,mBAAmB;AAAA,MACpI,KAAK,wBAAwB;AACzB,aAAK,SAAS,WAAW;AAAA,MAC7B,KAAK,wBAAwB;AACzB,aAAK,QAAQ,WAAW;AAAA,MAC5B,KAAK,wBAAwB;AACzB,aAAK,YAAY,WAAW;AAAA,MAChC,KAAK,wBAAwB;AACzB,aAAK,mBAAmB,WAAW;AAAA,MACvC,KAAK,wBAAwB;AACzB,aAAK,OAAO,OAAO,qBAAqB,WAAW;AAAA,MACvD,KAAK,wBAAwB;AACzB,aAAK,gBAAgB;AAAA,IAC7B;AAIA,UAAM,uBAAuB,KAAK,qBAAqB;AACvD,SAAK,uBAAuB,aAAa,oBAAoB;AAC7D,UAAM,QAAQ;AAAA,MACV,MAAM,OAAO;AAAA,MACb,SAAS,OAAO;AAAA,MAChB,kBAAkB,OAAO;AAAA,MACzB,SAAS,OAAO;AAAA,MAChB,SAAS;AAAA,MACT,mBAAmB,OAAO;AAAA,IAC9B;AACA,SAAK,aAAa,cAAc,KAAK;AAAA,EACzC;AAAA,EACA,UAAU;AACN,UAAM,cAAc,EAAE,QAAQ,KAAK,SAAS,eAAe,KAAK,KAAK,SAAS,gBAAgB,WAAW;AACzG,WAAO,EAAE,QAAQ,KAAK,QAAQ,KAAK,eAAe,CAAC,KAAK,YAAY,QAAQ;AAAA,EAChF;AAAA,EACA,iBAAiB;AACb,WAAO,EAAE,OAAO,KAAK,aAAa,KAAK,KAAK,cAAc,SAAS;AAAA,EACvE;AAAA,EACA,4BAA4B,cAAc,aAAa;AAEnD,QAAI,UAAU,CAAC;AACf,QAAI,WAAW;AACf,UAAM,SAAS,CAAC;AAChB,UAAM,uBAAuB,KAAK,mBAAmB,GAAG,sBAAsB;AAC9E,SAAK,8BAA8B,aAAW;AAE1C,UAAI,UAAU;AACV;AAAA,MACJ;AACA,UAAI,SAAS;AACT,YAAI,YAAY,eAAe,YAAY,cAAc;AAErD,qBAAW;AAGX,cAAI,QAAQ,SAAS,sBAAsB;AACvC,mBAAO,KAAK,GAAG,QAAQ,eAAe;AACtC;AAAA,UACJ;AAAA,QACJ;AAAA,MACJ;AACA,UAAI,CAAC,SAAS;AACV,YAAI,YAAY,eAAe,YAAY,cAAc;AAErD;AAAA,QACJ;AACA,kBAAU;AAAA,MACd;AAEA,YAAM,kBAAkB,CAAC,QAAQ,SAAS,CAAC;AAC3C,UAAI,iBAAiB;AACjB,eAAO,KAAK,OAAO;AACnB;AAAA,MACJ;AAAA,IACJ,CAAC;AACD,WAAO;AAAA,EACX;AAAA,EACA,cAAc,YAAY;AACtB,YAAQ,MAAM,qEAAqE;AAAA,EACvF;AAAA,EACA,mBAAmB;AACf,WAAO,KAAK,WAAW,KAAK,SAAS,qBAAqB;AAAA,EAC9D;AAAA,EACA,cAAc;AACV,WAAO,KAAK;AAAA,EAChB;AAAA,EACA,OAAO,OAAO;AACV,WAAO,KAAK,cAAc,KAAK;AAAA,EACnC;AAAA,EACA,aAAa,SAAS;AAClB,WAAO,KAAK,cAAc,QAAQ,OAAO,KAAK;AAAA,EAClD;AAAA,EACA,mBAAmB,cAAc;AAC7B,QAAI,KAAK,QAAQ,KAAK,KAAK,cAAc,WAAW,GAAG;AACnD,aAAO;AAAA,IACX;AAGA,QAAI,gBAAgB;AACpB,QAAI,aAAa,KAAK,cAAc,SAAS;AAE7C,QAAI,gBAAgB,GAAG;AAEnB,aAAO;AAAA,IACX;AACA,UAAM,WAAW,EAAE,KAAK,KAAK,aAAa;AAC1C,QAAI,SAAS,UAAU,cAAc;AACjC,aAAO,KAAK,cAAc,SAAS;AAAA,IACvC;AACA,QAAI,mBAAmB;AACvB,QAAI,gBAAgB;AACpB,WAAO,MAAM;AACT,YAAM,aAAa,KAAK,OAAO,gBAAgB,cAAc,CAAC;AAC9D,YAAM,iBAAiB,KAAK,cAAc,UAAU;AACpD,UAAI,KAAK,aAAa,gBAAgB,YAAY,GAAG;AACjD,eAAO;AAAA,MACX;AACA,UAAI,eAAe,SAAS,cAAc;AACtC,wBAAgB,aAAa;AAAA,MACjC,WACS,eAAe,SAAS,cAAc;AAC3C,qBAAa,aAAa;AAAA,MAC9B;AAIA,YAAM,uBAAuB,qBAAqB,iBAC3C,kBAAkB;AACzB,UAAI,sBAAsB;AACtB,eAAO;AAAA,MACX;AACA,yBAAmB;AACnB,sBAAgB;AAAA,IACpB;AAAA,EACJ;AAAA,EACA,aAAa,SAAS,cAAc;AAChC,UAAM,WAAW,QAAQ;AACzB,UAAM,cAAc,QAAQ,SAAS,QAAQ;AAC7C,UAAM,aAAa,YAAY,gBAAgB,cAAc;AAC7D,WAAO;AAAA,EACX;AAAA,EACA,gBAAgB,UAAU;AACtB,QAAI,KAAK,SAAS,iBAAiB;AAC/B,WAAK,SAAS,gBAAgB,QAAQ,CAAC,SAAS,UAAU,SAAS,SAAS,KAAK,CAAC;AAAA,IACtF;AAAA,EACJ;AAAA,EACA,YAAY,UAAU,qBAAqB,OAAO;AAC9C,SAAK,gCAAgC;AAAA,MACjC,OAAO,CAAC,GAAI,KAAK,SAAS,sBAAsB,CAAC,CAAE;AAAA,MACnD;AAAA,MACA,eAAe,cAAc;AAAA,MAC7B,OAAO;AAAA,MACP;AAAA,IACJ,CAAC;AAAA,EACL;AAAA,EACA,uBAAuB,UAAU,qBAAqB,OAAO;AACzD,SAAK,gCAAgC;AAAA,MACjC,OAAO,CAAC,GAAI,KAAK,SAAS,0BAA0B,CAAC,CAAE;AAAA,MACvD;AAAA,MACA,eAAe,cAAc;AAAA,MAC7B,OAAO;AAAA,MACP;AAAA,IACJ,CAAC;AAAA,EACL;AAAA,EACA,8BAA8B,UAAU,qBAAqB,OAAO;AAChE,SAAK,gCAAgC;AAAA,MACjC,OAAO,CAAC,GAAI,KAAK,SAAS,qBAAqB,CAAC,CAAE;AAAA,MAClD;AAAA,MACA,eAAe,cAAc;AAAA,MAC7B,OAAO;AAAA,MACP;AAAA,IACJ,CAAC;AAAA,EACL;AAAA,EACA,iBAAiB,UAAU,qBAAqB,OAAO;AACnD,SAAK,gCAAgC;AAAA,MACjC,OAAO,CAAC,KAAK,QAAQ;AAAA,MACrB;AAAA,MACA,eAAe,cAAc;AAAA,MAC7B,OAAO;AAAA,MACP;AAAA,IACJ,CAAC;AAAA,EACL;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAMA,gCAAgC,QAAQ;AACpC,QAAI;AACJ,UAAM,EAAE,OAAO,UAAU,eAAe,mBAAmB,IAAI;AAC/D,QAAI,EAAE,MAAM,IAAI;AAChB,aAAS,IAAI,GAAG,IAAI,MAAM,QAAQ,KAAK;AACnC,YAAM,OAAO,MAAM,CAAC;AACpB,eAAS,MAAM,OAAO;AAEtB,UAAI,KAAK,YAAY,KAAK,CAAC,KAAK,QAAQ;AAEpC,YAAI,eAAe;AACnB,gBAAQ,eAAe;AAAA,UACnB,KAAK,cAAc;AACf,2BAAe,KAAK;AACpB;AAAA,UACJ,KAAK,cAAc;AACf,2BAAe,KAAK;AACpB;AAAA,UACJ,KAAK,cAAc;AACf,2BAAe,KAAK;AACpB;AAAA,UACJ,KAAK,cAAc;AAEf,2BAAe,CAAC,KAAK,YAAY,KAAK,oBAAoB;AAC1D;AAAA,QACR;AACA,YAAI,cAAc;AACd,kBAAQ,KAAK,gCAAgC;AAAA,YACzC,OAAO,CAAC,GAAG,YAAY;AAAA,YACvB;AAAA,YACA;AAAA,YACA;AAAA,YACA;AAAA,UACJ,CAAC;AAAA,QACL;AAAA,MACJ;AAAA,IACJ;AACA,UAAM,cAAc,KAAK,MAAM,CAAC,OAAO,QAAQ,OAAO,SAAS,SAAS,GAAG;AAC3E,QAAI,CAAC,sBAAsB,CAAC;AACxB,aAAO;AACX,UAAM,aAAa,eAAe,KAAK;AACvC,QAAI,YAAY;AACZ,YAAM,eAAe,KAAK,mBAAmB,GAAG,yBAAyB;AACzE,UAAI,CAAC;AACD,eAAO;AAAA,IACf,OACK;AACD,YAAM,uBAAuB,KAAK,mBAAmB,sBAAsB;AAC3E,UAAI,CAAC,qBAAqB,EAAE,MAAM,WAAW,CAAC;AAC1C,eAAO;AAAA,IACf;AACA,eAAW,aAAa;AACxB,aAAS,WAAW,SAAS,OAAO;AACpC,WAAO;AAAA,EACX;AAAA;AAAA;AAAA,EAGA,YAAY,aAAa;AACrB,QAAI,KAAK,kBAAkB;AACvB,WAAK,iBAAiB,QAAQ,EAAE,SAAS,KAAK,UAAU,YAAyB,CAAC;AAAA,IACtF;AAAA,EACJ;AAAA,EACA,mBAAmB,aAAa;AAC5B,QAAI,KAAK,uBAAuB;AAC5B,WAAK,sBAAsB,QAAQ,EAAE,SAAS,KAAK,UAAU,YAAyB,CAAC;AAAA,IAC3F,OACK;AAED,WAAK,SAAS,yBAAyB,KAAK,SAAS;AAAA,IACzD;AAAA,EACJ;AAAA;AAAA;AAAA,EAGA,oBAAoB,QAAQ;AACxB,UAAM,gBAAgB,KAAK,mBAAmB,GAAG,UAAU;AAC3D,UAAM,iBAAiB,KAAK,YAAY,cAAc;AACtD,UAAM,4BAA4B,CAAC,aAAa;AAC5C,UAAI,CAAC,UAAU;AACX;AAAA,MACJ;AACA,eAAS,QAAQ,aAAW;AACxB,cAAM,YAAY,MAAM;AACpB,kBAAQ,WAAW;AACnB,oCAA0B,QAAQ,kBAAkB;AAAA,QACxD;AACA,YAAI,eAAe;AACf,gBAAM,cAAc,EAAE,OAAO,QAAQ,kBAAkB;AACvD,cAAI,aAAa;AACb,sBAAU;AAAA,UACd;AACA;AAAA,QACJ;AACA,YAAI,gBAAgB;AAChB,gBAAM,eAAe,CAAC,QAAQ;AAC9B,cAAI,cAAc;AACd,sBAAU;AAAA,UACd;AACA;AAAA,QACJ;AACA,cAAM,aAAa,QAAQ;AAC3B,YAAI,YAAY;AACZ,oBAAU;AAAA,QACd;AAAA,MACJ,CAAC;AAAA,IACL;AACA,QAAI,KAAK,UAAU;AACf,gCAA0B,KAAK,SAAS,kBAAkB;AAAA,IAC9D;AACA,SAAK,aAAa,EAAE,MAAM,wBAAwB,IAAI,CAAC;AACvD,UAAM,cAAc,SAAS,cAAc;AAC3C,UAAM,QAAQ;AAAA,MACV,MAAM,OAAO;AAAA,MACb,QAAQ;AAAA,IACZ;AACA,SAAK,aAAa,cAAc,KAAK;AAAA,EACzC;AAAA,EACA,OAAO,qBAAqB,aAAa;AACrC,SAAK,UAAU,QAAQ;AAAA,MACnB,SAAS,KAAK;AAAA,MACd;AAAA,MACA;AAAA,IACJ,CAAC;AAAA,EACL;AAAA,EACA,cAAc,YAAY,qBAAqB,cAAc,aAAa,qBAAqB;AAC3F,QAAI,KAAK,YAAY;AACjB,UAAI,qBAAqB;AACrB,aAAK,WAAW,QAAQ;AAAA,UACpB,SAAS,KAAK;AAAA,UACd;AAAA,UACA;AAAA,UACA;AAAA,QACJ,CAAC;AAAA,MACL,OACK;AACD,aAAK,WAAW,QAAQ;AAAA,UACpB,SAAS,KAAK;AAAA,UACd;AAAA,UACA;AAAA,QACJ,CAAC;AAED,aAAK,kBAAkB,UAAU;AAAA,MACrC;AACA,UAAI,KAAK,mBAAmB,GAAG,sBAAsB,GAAG;AACpD,cAAM,mBAAmB,KAAK,iBAAiB,mCAAmC,mBAAmB,WAAW;AAChH,YAAI,kBAAkB;AAClB,gBAAM,QAAQ;AAAA,YACV,MAAM,OAAO;AAAA,YACb,QAAQ;AAAA,UACZ;AACA,eAAK,aAAa,cAAc,KAAK;AAAA,QACzC;AAAA,MACJ;AAAA,IACJ,OACK;AACD,WAAK,SAAS,qBAAqB,KAAK,SAAS;AACjD,UAAI,KAAK,SAAS,SAAS;AACvB,aAAK,SAAS,QAAQ,qBAAqB,KAAK,SAAS;AAAA,MAC7D;AACA,WAAK,SAAS,kBAAkB;AAAA,IACpC;AAAA,EACJ;AAAA,EACA,kBAAkB,YAAY;AAC1B,QAAI,CAAC,YAAY;AACb;AAAA,IACJ;AACA,MAAE,qBAAqB,KAAK,SAAS,oBAAoB,CAAC,MAAM,QAAQ;AAIpE,UAAI,OAAO,WAAW,GAAG,MAAM,WAAW;AACtC,aAAK,WAAW,WAAW,GAAG;AAAA,MAClC;AAAA,IACJ,CAAC;AAAA,EACL;AAAA,EACA,SAAS,aAAa;AAClB,SAAK,YAAY,QAAQ,EAAE,SAAS,KAAK,UAAU,YAAyB,CAAC;AAAA,EACjF;AAAA,EACA,QAAQ,aAAa;AACjB,QAAI,KAAK,YAAY;AACjB,WAAK,WAAW,QAAQ,EAAE,SAAS,KAAK,UAAU,YAAyB,CAAC;AAAA,IAChF;AAAA,EACJ;AAAA,EACA,gBAAgB;AACZ,QAAI,CAAC,KAAK,SAAS,sBAAsB,CAAC,KAAK,mBAAmB,GAAG,+BAA+B,GAAG;AACnG,aAAO;AAAA,IACX;AACA,UAAM,SAAS,CAAC;AAChB,MAAE,qBAAqB,KAAK,SAAS,oBAAoB,CAAC,MAAM,QAAQ,OAAO,GAAG,IAAI,KAAK,QAAQ;AACnG,WAAO;AAAA,EACX;AAAA,EACA,oBAAoB;AAChB,WAAO,KAAK,YAAY,kBAAkB;AAAA,EAC9C;AAAA,EACA,WAAW,IAAI;AAEX,UAAM,YAAY,OAAO,MAAM,YAAY,GAAG,QAAQ,QAAQ,mBAAmB,KAAK;AACtF,QAAI,WAAW;AAKX,UAAI,MAAM;AACV,WAAK,YAAY,UAAQ;AACrB,YAAI,KAAK,OAAO,IAAI;AAChB,gBAAM;AAAA,QACV;AAAA,MACJ,CAAC;AACD,aAAO;AAAA,IACX;AACA,WAAO,KAAK,YAAY,WAAW,EAAE;AAAA,EACzC;AAAA;AAAA,EAEA,WAAW,SAAS;AAIhB,UAAM,aAAa,KAAK,cAAc;AACtC,SAAK,YAAY,WAAW,OAAO;AAEnC,SAAK,iBAAiB,MAAM;AAE5B,SAAK,cAAc,gBAAgB,gBAAgB;AAGnD,UAAM,sBAAsB;AAAA,MACxB,MAAM,OAAO;AAAA,IACjB;AACA,SAAK,aAAa,cAAc,mBAAmB;AACnD,SAAK,aAAa;AAAA,MACd,MAAM,wBAAwB;AAAA,MAC9B;AAAA,MACA,SAAS;AAAA,IACb,CAAC;AAAA,EACL;AAAA,EACA,mBAAmB,oBAAoB,UAAU;AAC7C,QAAI,KAAK,iCAAiC,MAAM;AAC5C,WAAK,0BAA0B,CAAC;AAChC,YAAM,aAAa,KAAK,mBAAmB,8BAA8B;AACzE,WAAK,gCAAgC,OAAO,WAAW,MAAM;AACzD,aAAK,0BAA0B;AAAA,MACnC,GAAG,UAAU;AAAA,IACjB;AACA,SAAK,wBAAwB,KAAK,EAAE,oBAAwC,SAAmB,CAAC;AAAA,EACpG;AAAA,EACA,yBAAyB;AACrB,QAAI,KAAK,iCAAiC,MAAM;AAC5C,mBAAa,KAAK,6BAA6B;AAC/C,WAAK,0BAA0B;AAAA,IACnC;AAAA,EACJ;AAAA,EACA,4BAA4B;AACxB,SAAK,WAAW,cAAc;AAC9B,UAAM,qBAAqB,CAAC;AAC5B,UAAM,eAAe,CAAC;AAGtB,QAAI,oBAAoB;AACxB,QAAI,KAAK,yBAAyB;AAC9B,WAAK,wBAAwB,QAAQ,cAAY;AAC7C,cAAM,cAAc,KAAK,YAAY,cAAc,SAAS,oBAAoB,MAAS;AACzF,qBAAa,KAAK,WAAW;AAC7B,YAAI,SAAS,UAAU;AACnB,6BAAmB,KAAK,SAAS,SAAS,KAAK,MAAM,WAAW,CAAC;AAAA,QACrE;AACA,YAAI,OAAO,SAAS,mBAAmB,aAAa,UAAU;AAC1D,8BAAoB;AAAA,QACxB;AAAA,MACJ,CAAC;AAAA,IACL;AACA,SAAK,oBAAoB,cAAc,QAAW,iBAAiB;AAEnE,QAAI,mBAAmB,SAAS,GAAG;AAC/B,aAAO,WAAW,MAAM;AACpB,2BAAmB,QAAQ,UAAQ,KAAK,CAAC;AAAA,MAC7C,GAAG,CAAC;AAAA,IACR;AACA,QAAI,aAAa,SAAS,GAAG;AACzB,YAAM,QAAQ;AAAA,QACV,MAAM,OAAO;AAAA,QACb,SAAS;AAAA,MACb;AACA,WAAK,aAAa,cAAc,KAAK;AAAA,IACzC;AACA,SAAK,0BAA0B;AAC/B,SAAK,gCAAgC;AAAA,EACzC;AAAA,EACA,cAAc,aAAa,cAAc;AACrC,SAAK,WAAW,cAAc;AAC9B,UAAM,cAAc,KAAK,YAAY,cAAc,aAAa,YAAY;AAI5E,UAAM,oBAAoB,OAAO,YAAY,aAAa;AAC1D,SAAK,oBAAoB,CAAC,WAAW,GAAG,cAAc,iBAAiB;AACvE,WAAO;AAAA,EACX;AAAA,EACA,qBAAqB;AACjB,UAAM,oBAAoB,KAAK,mBAAmB,GAAG,+BAA+B;AACpF,QAAI,mBAAmB;AACnB;AAAA,IACJ;AACA,UAAM,WAAW,CAAC;AAClB,QAAI,KAAK,YAAY,KAAK,SAAS,iBAAiB;AAChD,eAAS,QAAQ,GAAG,QAAQ,KAAK,SAAS,gBAAgB,QAAQ,SAAS;AACvE,cAAM,OAAO,KAAK,SAAS,gBAAgB,KAAK;AAChD,iBAAS,KAAK,EAAE,IAAI;AAAA,MACxB;AAAA,IACJ;AACA,WAAO;AAAA,EACX;AAAA;AAAA,EAEA,oBAAoB,cAAc,cAAc,mBAAmB;AAC/D,UAAM,UAAU,CAAC,KAAK,mBAAmB,GAAG,wBAAwB;AACpE,QAAI,mBAAmB;AACnB,qBAAe,KAAK,mBAAmB;AAAA,IAC3C;AACA,SAAK,aAAa;AAAA,MACd,MAAM,wBAAwB;AAAA,MAC9B,qBAAqB;AAAA,MACrB;AAAA,MACA,kBAAkB;AAAA,MAClB,iBAAiB;AAAA,MACjB;AAAA,IACJ,CAAC;AAED,SAAK,cAAc,gBAAgB,gBAAgB;AACnD,UAAM,QAAQ;AAAA,MACV,MAAM,OAAO;AAAA,IACjB;AACA,SAAK,aAAa,cAAc,KAAK;AAAA,EACzC;AAAA,EACA,kBAAkB;AACd,SAAK,gBAAgB,KAAK,aAAa,QAAQ,EAAE,SAAS,KAAK,SAAS,CAAC;AAAA,EAC7E;AAAA,EACA,qBAAqB;AACjB,SAAK,aAAa,EAAE,MAAM,wBAAwB,KAAK,kBAAkB,MAAM,iBAAiB,MAAM,mBAAmB,KAAK,CAAC;AAAA,EACnI;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOA,8BAA8B;AAC1B,SAAK,6BAA6B;AAAA,EACtC;AAAA,EACA,kBAAkB;AACd,UAAM,aAAa,KAAK,8BAA8B;AACtD,SAAK,SAAS,aAAa,KAAK,SAAS,WAAW,IAAI;AACxD,QAAI,KAAK,SAAS,SAAS;AACvB,WAAK,SAAS,QAAQ,aAAa,KAAK,SAAS,QAAQ,WAAW,IAAI;AAAA,IAC5E;AAGA,QAAI,YAAY;AACZ,WAAK,mBAAmB;AAAA,IAC5B;AAAA,EACJ;AAAA,EACA,gCAAgC;AAC5B,QAAI,aAAa;AACjB,SAAK,YAAY,aAAW;AACxB,cAAQ,aAAa,QAAQ,WAAW,IAAI;AAI5C,YAAM,aAAa,QAAQ;AAC3B,UAAI,YAAY;AACZ,mBAAW,aAAa,WAAW,WAAW,IAAI;AAAA,MACtD;AACA,UAAI,QAAQ,SAAS;AACjB,gBAAQ,QAAQ,aAAa,QAAQ,QAAQ,WAAW,IAAI;AAAA,MAChE;AACA,mBAAa;AAAA,IACjB,CAAC;AACD,WAAO;AAAA,EACX;AAAA,EACA,sBAAsB;AAClB,QAAI,KAAK,YAAY,sBAAsB,GAAG;AAC1C;AAAA,IACJ;AACA,SAAK,gBAAgB;AAAA,EACzB;AACJ;AACA,WAAW;AAAA,EACP,UAAU,aAAa;AAC3B,GAAG,mBAAmB,WAAW,eAAe,MAAM;AACtD,WAAW;AAAA,EACP,UAAU,kBAAkB;AAChC,GAAG,mBAAmB,WAAW,oBAAoB,MAAM;AAC3D,WAAW;AAAA,EACP,UAAU,eAAe;AAC7B,GAAG,mBAAmB,WAAW,iBAAiB,MAAM;AACxD,WAAW;AAAA,EACP,UAAU,YAAY;AAC1B,GAAG,mBAAmB,WAAW,cAAc,MAAM;AACrD,WAAW;AAAA,EACP,UAAU,OAAO;AACrB,GAAG,mBAAmB,WAAW,SAAS,MAAM;AAChD,WAAW;AAAA,EACP,UAAU,aAAa;AAC3B,GAAG,mBAAmB,WAAW,eAAe,MAAM;AACtD,WAAW;AAAA,EACP,UAAU,WAAW;AACzB,GAAG,mBAAmB,WAAW,aAAa,MAAM;AACpD,WAAW;AAAA,EACP,UAAU,cAAc;AAC5B,GAAG,mBAAmB,WAAW,gBAAgB,MAAM;AACvD,WAAW;AAAA,EACP,SAAS,YAAY;AACzB,GAAG,mBAAmB,WAAW,cAAc,MAAM;AACrD,WAAW;AAAA,EACP,SAAS,kBAAkB;AAC/B,GAAG,mBAAmB,WAAW,oBAAoB,MAAM;AAC3D,WAAW;AAAA,EACP,SAAS,YAAY;AACzB,GAAG,mBAAmB,WAAW,cAAc,MAAM;AACrD,WAAW;AAAA,EACP,SAAS,uBAAuB;AACpC,GAAG,mBAAmB,WAAW,yBAAyB,MAAM;AAChE,WAAW;AAAA,EACP;AACJ,GAAG,mBAAmB,WAAW,QAAQ,IAAI;AAC7C,qBAAqB,WAAW;AAAA,EAC5B,KAAK,UAAU;AACnB,GAAG,kBAAkB;;;ACj8BrB,IAAIC,cAA0C,SAAU,YAAY,QAAQ,KAAK,MAAM;AACnF,MAAI,IAAI,UAAU,QAAQ,IAAI,IAAI,IAAI,SAAS,SAAS,OAAO,OAAO,OAAO,yBAAyB,QAAQ,GAAG,IAAI,MAAM;AAC3H,MAAI,OAAO,YAAY,YAAY,OAAO,QAAQ,aAAa,WAAY,KAAI,QAAQ,SAAS,YAAY,QAAQ,KAAK,IAAI;AAAA,MACxH,UAAS,IAAI,WAAW,SAAS,GAAG,KAAK,GAAG,IAAK,KAAI,IAAI,WAAW,CAAC,EAAG,MAAK,IAAI,IAAI,EAAE,CAAC,IAAI,IAAI,IAAI,EAAE,QAAQ,KAAK,CAAC,IAAI,EAAE,QAAQ,GAAG,MAAM;AAChJ,SAAO,IAAI,KAAK,KAAK,OAAO,eAAe,QAAQ,KAAK,CAAC,GAAG;AAChE;AAEA,IAAI,cAAc,MAAMC,qBAAoB,SAAS;AAAA,EACjD,QAAQ,QAAQ;AACZ,UAAM,EAAE,YAAY,IAAI;AACxB,SAAK,cAAc,OAAO,WAAW;AAAA,EACzC;AACJ;AACAD,YAAW;AAAA,EACP,UAAU,eAAe;AAC7B,GAAG,YAAY,WAAW,iBAAiB,MAAM;AACjD,cAAcA,YAAW;AAAA,EACrB,KAAK,aAAa;AACtB,GAAG,WAAW;;;AClBd,IAAIE,cAA0C,SAAU,YAAY,QAAQ,KAAK,MAAM;AACnF,MAAI,IAAI,UAAU,QAAQ,IAAI,IAAI,IAAI,SAAS,SAAS,OAAO,OAAO,OAAO,yBAAyB,QAAQ,GAAG,IAAI,MAAM;AAC3H,MAAI,OAAO,YAAY,YAAY,OAAO,QAAQ,aAAa,WAAY,KAAI,QAAQ,SAAS,YAAY,QAAQ,KAAK,IAAI;AAAA,MACxH,UAAS,IAAI,WAAW,SAAS,GAAG,KAAK,GAAG,IAAK,KAAI,IAAI,WAAW,CAAC,EAAG,MAAK,IAAI,IAAI,EAAE,CAAC,IAAI,IAAI,IAAI,EAAE,QAAQ,KAAK,CAAC,IAAI,EAAE,QAAQ,GAAG,MAAM;AAChJ,SAAO,IAAI,KAAK,KAAK,OAAO,eAAe,QAAQ,KAAK,CAAC,GAAG;AAChE;AAEA,IAAI,YAAY,MAAMC,mBAAkB,SAAS;AAAA,EAC7C,QAAQ,QAAQ;AACZ,UAAM,cAAc,KAAK,eAAe,eAAe;AACvD,UAAM,aAAa,EAAE,OAAO,WAAW,KAAK,YAAY,SAAS;AACjE,UAAM,YAAY,cACX,EAAE,OAAO,OAAO,mBAAmB,KAKnC,KAAK,mBAAmB,GAAG,WAAW;AAC7C,UAAM,2BAA2B,YAAY,KAAK,SAAO;AACrD,YAAM,mBAAmB,KAAK,mBAAmB,+BAA+B;AAChF,UAAI,kBAAkB;AAClB,eAAO,IAAI,OAAO,UAAU,KAAK,IAAI,OAAO,iBAAiB;AAAA,MACjE;AACA,aAAO,CAAC,CAAC,IAAI,OAAO,UAAU,EAAE;AAAA,IACpC,CAAC;AACD,SAAK,YAAY,KAAK,aAAa,YAAY,WAAW,OAAO,qBAAqB,OAAO,aAAa,wBAAwB;AAAA,EACtI;AACJ;AACAD,YAAW;AAAA,EACP,UAAU,aAAa;AAC3B,GAAG,UAAU,WAAW,eAAe,MAAM;AAC7CA,YAAW;AAAA,EACP,UAAU,gBAAgB;AAC9B,GAAG,UAAU,WAAW,kBAAkB,MAAM;AAChDA,YAAW;AAAA,EACP,UAAU,aAAa;AAC3B,GAAG,UAAU,WAAW,eAAe,MAAM;AAC7C,YAAYA,YAAW;AAAA,EACnB,KAAK,WAAW;AACpB,GAAG,SAAS;;;ACvCZ,IAAIE,cAA0C,SAAU,YAAY,QAAQ,KAAK,MAAM;AACnF,MAAI,IAAI,UAAU,QAAQ,IAAI,IAAI,IAAI,SAAS,SAAS,OAAO,OAAO,OAAO,yBAAyB,QAAQ,GAAG,IAAI,MAAM;AAC3H,MAAI,OAAO,YAAY,YAAY,OAAO,QAAQ,aAAa,WAAY,KAAI,QAAQ,SAAS,YAAY,QAAQ,KAAK,IAAI;AAAA,MACxH,UAAS,IAAI,WAAW,SAAS,GAAG,KAAK,GAAG,IAAK,KAAI,IAAI,WAAW,CAAC,EAAG,MAAK,IAAI,IAAI,EAAE,CAAC,IAAI,IAAI,IAAI,EAAE,QAAQ,KAAK,CAAC,IAAI,EAAE,QAAQ,GAAG,MAAM;AAChJ,SAAO,IAAI,KAAK,KAAK,OAAO,eAAe,QAAQ,KAAK,CAAC,GAAG;AAChE;AAEA,IAAI,eAAe,MAAMC,sBAAqB,SAAS;AAAA,EACnD,QAAQ,QAAQ;AACZ,UAAM,WAAW,OAAO;AAGxB,UAAM,SAAS,CAAC;AAChB,UAAM,gBAAgB,KAAK,YAAY,YAAY;AAGnD,UAAM,eAAe,iBAAiB,SAAS;AAC/C,UAAM,UAAU,eAAe,CAAC,QAAQ,IAAI,SAAS;AACrD,UAAM,UAAU,KAAK,kBAAkB;AACvC,SAAK,8BAA8B,SAAS,SAAS,QAAQ,eAAe,CAAC;AAE7E,UAAM,uBAAuB,OAAO,SAAS;AAC7C,UAAM,0BAA0B,CAAC,gBAE1B,wBACA,QAAQ;AACf,QAAI,yBAAyB;AACzB,eAAS,aAAa;AACtB,WAAK,0BAA0B,SAAS,SAAS,SAAS,QAAQ,CAAC;AAAA,IACvE;AACA,WAAO;AAAA,EACX;AAAA,EACA,oBAAoB;AAEhB,UAAM,4BAA4B,KAAK,mBAAmB,GAAG,2BAA2B;AACxF,UAAM,kCAAkC,CAAC,6BAA6B,KAAK,mBAAmB,GAAG,iCAAiC;AAClI,WAAO;AAAA,MACH;AAAA,MACA;AAAA,MACA,wBAAwB,KAAK,mBAAmB,uBAAuB;AAAA,MACvE,iBAAiB,KAAK,mBAAmB,GAAG,sBAAsB;AAAA,MAClE,yBAAyB,KAAK,mBAAmB,GAAG,yBAAyB;AAAA,MAC7E,uBAAuB,KAAK,mBAAmB,sBAAsB;AAAA,IACzE;AAAA,EACJ;AAAA,EACA,8BAA8B,SAAS,eAAe,QAAQ,eAAe,SAAS;AAClF,QAAI,EAAE,eAAe,aAAa,GAAG;AACjC;AAAA,IACJ;AACA,aAAS,IAAI,GAAG,IAAI,cAAc,QAAQ,KAAK;AAC3C,YAAM,UAAU,cAAc,CAAC;AAE/B,YAAM,WAAW,QAAQ,YAAY;AACrC,YAAM,oBAAoB,iBAAiB,CAAC;AAC5C,YAAM,+BAA+B,QAAQ,6BAA6B,YAAY,QAAQ,mBAAmB,WAAW;AAC5H,YAAM,qCAAqC,QAAQ,mCAC/C,YACA,QAAQ,aACR,QAAQ,mBAAmB,WAAW;AAI1C,YAAM,qBAAqB,iBAAiB,QAAQ;AACpD,YAAM,qBAAqB,QAAQ,mBAAmB,QAAQ,YAAY,CAAC,QAAQ,UAAU,CAAC;AAC9F,YAAM,0BAA0B,CAAC,qBAAqB,CAAC,sBACnD,CAAC,gCAAgC,CAAC;AACtC,UAAI,yBAAyB;AACzB,aAAK,0BAA0B,SAAS,SAAS,QAAQ,OAAO;AAAA,MACpE;AAEA,UAAI,iBAAiB,QAAQ,WAAW;AACpC;AAAA,MACJ;AACA,UAAI,UAAU;AACV,cAAM,iBAAiB,gCAAgC;AAGvD,YAAI,QAAQ,YAAY,gBAAgB;AAEpC,gBAAM,qBAAqB,iBAAiB,UAAU,UAAU;AAChE,eAAK,8BAA8B,SAAS,QAAQ,mBAAmB,QAAQ,eAAe,kBAAkB;AAEhH,gBAAM,oBAAoB,QAAQ,sBAAsB,EAAE,MAAM,QAAQ,CAAC;AACzE,cAAI,mBAAmB;AAEnB,oBAAQ,aAAa;AACrB,iBAAK,0BAA0B,SAAS,QAAQ,SAAS,QAAQ,kBAAkB;AAAA,UACvF,OACK;AAED,oBAAQ,cAAc;AAAA,UAC1B;AAAA,QACJ;AAAA,MACJ,WACS,QAAQ,UAAU,QAAQ,UAAU;AACzC,cAAM,aAAa,KAAK,iBAAiB,OAAO;AAChD,aAAK,0BAA0B,SAAS,YAAY,QAAQ,OAAO;AAAA,MACvE;AAAA,IACJ;AAAA,EACJ;AAAA;AAAA,EAEA,0BAA0B,SAAS,SAAS,QAAQ,SAAS;AACzD,WAAO,KAAK,OAAO;AACnB,YAAQ,WAAW,QAAQ,yBAAyB,IAAI,OAAO;AAAA,EACnE;AAAA,EACA,iBAAiB,YAAY;AACzB,QAAI,EAAE,OAAO,WAAW,UAAU,GAAG;AACjC,aAAO,WAAW;AAAA,IACtB;AACA,UAAM,aAAa,IAAI,QAAQ,KAAK,KAAK;AACzC,eAAW,SAAS;AACpB,eAAW,aAAa;AACxB,eAAW,SAAS;AACpB,QAAI,EAAE,OAAO,WAAW,EAAE,GAAG;AACzB,iBAAW,KAAK,YAAY,WAAW;AAAA,IAC3C;AACA,eAAW,OAAO,WAAW;AAC7B,eAAW,QAAQ,WAAW,QAAQ;AACtC,eAAW,aAAa;AACxB,WAAO;AAAA,EACX;AACJ;AACAD,YAAW;AAAA,EACP,UAAU,aAAa;AAC3B,GAAG,aAAa,WAAW,eAAe,MAAM;AAChDA,YAAW;AAAA,EACP,UAAU,OAAO;AACrB,GAAG,aAAa,WAAW,SAAS,MAAM;AAC1C,eAAeA,YAAW;AAAA,EACtB,KAAK,cAAc;AACvB,GAAG,YAAY;;;AClIf,IAAIE,cAA0C,SAAU,YAAY,QAAQ,KAAK,MAAM;AACnF,MAAI,IAAI,UAAU,QAAQ,IAAI,IAAI,IAAI,SAAS,SAAS,OAAO,OAAO,OAAO,yBAAyB,QAAQ,GAAG,IAAI,MAAM;AAC3H,MAAI,OAAO,YAAY,YAAY,OAAO,QAAQ,aAAa,WAAY,KAAI,QAAQ,SAAS,YAAY,QAAQ,KAAK,IAAI;AAAA,MACxH,UAAS,IAAI,WAAW,SAAS,GAAG,KAAK,GAAG,IAAK,KAAI,IAAI,WAAW,CAAC,EAAG,MAAK,IAAI,IAAI,EAAE,CAAC,IAAI,IAAI,IAAI,EAAE,QAAQ,KAAK,CAAC,IAAI,EAAE,QAAQ,GAAG,MAAM;AAChJ,SAAO,IAAI,KAAK,KAAK,OAAO,eAAe,QAAQ,KAAK,CAAC,GAAG;AAChE;AAEA,IAAI,cAAc,MAAMC,qBAAoB,SAAS;AAAA,EACjD,OAAO;AACH,SAAK,eAAe,KAAK,mBAAmB,YAAY,cAAc;AAAA,EAC1E;AAAA,EACA,KAAK,aAAa,YAAY,cAAc,qBAAqB,aAAa,0BAA0B;AACpG,UAAM,qBAAqB,KAAK,mBAAmB,GAAG,oBAAoB;AAC1E,UAAM,sBAAsB,KAAK,YAAY,kBAAkB,EAAE,KAAK,OAAK,EAAE,iBAAiB,CAAC;AAC/F,QAAI,gBAAgB,CAAC;AACrB,QAAI,gBAAgB,qBAAqB;AACrC,sBAAgB,KAAK,oBAAoB,mBAAmB;AAAA,IAChE;AACA,UAAM,cAAc,KAAK,YAAY,YAAY;AACjD,UAAM,WAAW,CAAC,YAAY;AAE1B,WAAK,oCAAoC,QAAQ,wBAAwB,IAAI;AAE7E,YAAM,wBAAwB,eAAe,QAAQ;AAIrD,UAAI,oBAAoB,sBAAsB,uBAAuB,CAAC,QAAQ,aAAa,CAAC;AAC5F,UAAI,mBAAmB;AACnB,cAAM,qBAAqB,QAAQ,uBAAuB,MAAM,CAAC;AACjE,YAAI,QAAQ,mBAAmB;AAC3B,gBAAM,gBAAgB,CAAC;AACvB,kBAAQ,kBAAkB,QAAQ,CAAC,MAAM,QAAQ;AAC7C,0BAAc,KAAK,EAAE,IAAI;AAAA,UAC7B,CAAC;AACD,6BAAmB,KAAK,CAAC,MAAM,SAAS;AAAE,gBAAI,IAAI;AAAI,qBAAS,KAAK,cAAc,KAAK,EAAE,OAAO,QAAQ,OAAO,SAAS,KAAK,OAAO,KAAK,cAAc,KAAK,EAAE,OAAO,QAAQ,OAAO,SAAS,KAAK;AAAA,UAAI,CAAC;AAAA,QAC3M;AACA,gBAAQ,oBAAoB;AAAA,MAChC,WACS,CAAC,cAAc,uBAAuB;AAE3C,gBAAQ,oBAAoB,QAAQ,uBAAuB,MAAM,CAAC;AAAA,MACtE,WACS,cAAc;AACnB,gBAAQ,oBAAoB,KAAK,YAAY,SAAS,eAAe,aAAa,WAAW;AAAA,MACjG,OACK;AACD,gBAAQ,oBAAoB,KAAK,cAAc,WAAW,QAAQ,wBAAwB,WAAW;AAAA,MACzG;AACA,UAAI,QAAQ,SAAS;AACjB,gBAAQ,QAAQ,oBAAoB,QAAQ;AAAA,MAChD;AACA,WAAK,mBAAmB,OAAO;AAC/B,UAAI,KAAK,cAAc;AACnB,cAAM,SAAS,EAAE,OAAO,QAAQ,kBAAkB;AAClD,aAAK,aAAa,MAAM;AAAA,MAC5B;AAAA,IACJ;AACA,QAAI,aAAa;AACb,kBAAY,6BAA6B,QAAQ;AAAA,IACrD;AACA,SAAK,kCAAkC,WAAW;AAAA,EACtD;AAAA,EACA,oBAAoB,qBAAqB;AACrC,UAAM,aAAa,CAAC;AACpB,UAAM,eAAe,CAAC,aAAa;AAC/B,UAAI,UAAU;AACV,iBAAS,QAAQ,aAAW,WAAW,QAAQ,EAAE,IAAI,IAAI;AAAA,MAC7D;AAAA,IACJ;AAEA,QAAI,qBAAqB;AACrB,0BAAoB,QAAQ,UAAQ;AAChC,qBAAa,KAAK,GAAG;AACrB,qBAAa,KAAK,MAAM;AACxB,qBAAa,KAAK,MAAM;AAAA,MAC5B,CAAC;AAAA,IACL;AACA,WAAO;AAAA,EACX;AAAA,EACA,YAAY,SAAS,iBAAiB,aAAa,aAAa;AAC5D,UAAM,eAAe,QAAQ;AAC7B,UAAM,gBAAgB,QAAQ;AAC9B,QAAI,CAAC,eAAe;AAChB,aAAO,KAAK,cAAc,WAAW,cAAc,WAAW;AAAA,IAClE;AACA,UAAM,mBAAmB,CAAC;AAC1B,UAAM,cAAc,CAAC;AACrB,iBAAa,QAAQ,SAAO;AACxB,UAAI,gBAAgB,IAAI,EAAE,KAAK,CAAC,YAAY,QAAQ,GAAG,GAAG;AACtD,oBAAY,KAAK,GAAG;AAAA,MACxB,OACK;AACD,yBAAiB,IAAI,EAAE,IAAI;AAAA,MAC/B;AAAA,IACJ,CAAC;AACD,UAAM,sBAAsB,cAAc,OAAO,WAAS,iBAAiB,MAAM,EAAE,CAAC;AACpF,UAAM,sBAAsB,CAACC,UAAS,SAAS,EAAE,YAAY,KAAK,SAASA,SAAQ;AACnF,UAAM,oBAAoB,YACrB,IAAI,mBAAmB,EACvB,KAAK,CAAC,GAAG,MAAM,KAAK,cAAc,gBAAgB,aAAa,GAAG,CAAC,CAAC;AACzE,WAAO,KAAK,kBAAkB,aAAa,mBAAmB,oBAAoB,IAAI,mBAAmB,CAAC,EAAE,IAAI,CAAC,EAAE,SAAAA,SAAQ,MAAMA,QAAO;AAAA,EAC5I;AAAA;AAAA,EAEA,kBAAkB,aAAa,MAAM,MAAM;AACvC,UAAM,MAAM,CAAC;AACb,QAAI,IAAI;AACR,QAAI,IAAI;AAER,WAAO,IAAI,KAAK,UAAU,IAAI,KAAK,QAAQ;AAMvC,YAAM,gBAAgB,KAAK,cAAc,gBAAgB,aAAa,KAAK,CAAC,GAAG,KAAK,CAAC,CAAC;AACtF,UAAI,gBAAgB,GAAG;AACnB,YAAI,KAAK,KAAK,GAAG,CAAC;AAAA,MACtB,OACK;AACD,YAAI,KAAK,KAAK,GAAG,CAAC;AAAA,MACtB;AAAA,IACJ;AAEA,WAAO,IAAI,KAAK,QAAQ;AACpB,UAAI,KAAK,KAAK,GAAG,CAAC;AAAA,IACtB;AAEA,WAAO,IAAI,KAAK,QAAQ;AACpB,UAAI,KAAK,KAAK,GAAG,CAAC;AAAA,IACtB;AACA,WAAO;AAAA,EACX;AAAA,EACA,mBAAmB,SAAS;AACxB,QAAI,EAAE,QAAQ,QAAQ,iBAAiB,GAAG;AACtC;AAAA,IACJ;AACA,UAAM,aAAa,QAAQ;AAC3B,aAAS,IAAI,GAAG,IAAI,WAAW,QAAQ,KAAK;AACxC,YAAM,QAAQ,WAAW,CAAC;AAC1B,YAAM,aAAa,MAAM;AACzB,YAAM,YAAY,MAAM,QAAQ,kBAAkB,SAAS;AAC3D,YAAM,cAAc,UAAU;AAC9B,YAAM,aAAa,SAAS;AAC5B,YAAM,cAAc,CAAC;AAAA,IACzB;AAAA,EACJ;AAAA,EACA,kCAAkC,aAAa;AAC3C,QAAI,CAAC,KAAK,mBAAmB,GAAG,sBAAsB,GAAG;AACrD;AAAA,IACJ;AACA,QAAI,KAAK,mBAAmB,GAAG,UAAU,GAAG;AACxC,YAAM,MAAM;AACZ,QAAE,OAAO,MAAM,QAAQ,KAAK,GAAG,GAAG,yCAAyC;AAC3E,aAAO;AAAA,IACX;AAEA,UAAM,WAAW,CAAC,YAAY;AAC1B,WAAK,oCAAoC,QAAQ,mBAAmB,KAAK;AACzE,cAAQ,kBAAkB,QAAQ,WAAS;AACvC,YAAI,MAAM,YAAY,GAAG;AACrB,mBAAS,KAAK;AAAA,QAClB;AAAA,MACJ,CAAC;AAAA,IACL;AACA,QAAI,aAAa;AACb,kBAAY,oBAAoB,aAAW,SAAS,OAAO,CAAC;AAAA,IAChE;AAAA,EACJ;AAAA,EACA,oCAAoC,UAAU,gBAAgB;AAC1D,QAAI,CAAC,KAAK,mBAAmB,GAAG,sBAAsB,KAAK,EAAE,QAAQ,QAAQ,GAAG;AAC5E;AAAA,IACJ;AACA,aAAS,QAAQ,kBAAgB;AAC7B,YAAM,mBAAmB,KAAK,YAAY,uBAAuB;AACjE,uBAAiB,QAAQ,qBAAmB;AACxC,cAAM,eAAe,gBAAgB,UAAU,EAAE;AACjD,YAAI,OAAO,iBAAiB,UAAU;AAClC,kBAAQ,MAAM,mGAAmG;AACjH;AAAA,QACJ;AACA,cAAM,qBAAqB;AAC3B,cAAM,iBAAiB,KAAK,YAAY,iBAAiB,kBAAkB;AAC3E,cAAM,qBAAqB,mBAAmB,aAAa;AAC3D,YAAI,oBAAoB;AACpB;AAAA,QACJ;AACA,YAAI,gBAAgB;AAEhB,uBAAa,cAAc,gBAAgB,MAAM,GAAG,MAAS;AAAA,QACjE,OACK;AAED,gBAAM,oBAAoB,aAAa,0BAA0B,cAAc;AAC/E,cAAI,mBAAmB;AACnB,yBAAa,cAAc,gBAAgB,MAAM,GAAG,kBAAkB,GAAG;AAAA,UAC7E;AAAA,QACJ;AAAA,MACJ,CAAC;AAAA,IACL,CAAC;AAAA,EACL;AACJ;AACAF,YAAW;AAAA,EACP,UAAU,aAAa;AAC3B,GAAG,YAAY,WAAW,eAAe,MAAM;AAC/CA,YAAW;AAAA,EACP,UAAU,eAAe;AAC7B,GAAG,YAAY,WAAW,iBAAiB,MAAM;AACjDA,YAAW;AAAA,EACP;AACJ,GAAG,YAAY,WAAW,QAAQ,IAAI;AACtC,cAAcA,YAAW;AAAA,EACrB,KAAK,aAAa;AACtB,GAAG,WAAW;;;ACrNd,IAAIG,cAA0C,SAAU,YAAY,QAAQ,KAAK,MAAM;AACnF,MAAI,IAAI,UAAU,QAAQ,IAAI,IAAI,IAAI,SAAS,SAAS,OAAO,OAAO,OAAO,yBAAyB,QAAQ,GAAG,IAAI,MAAM;AAC3H,MAAI,OAAO,YAAY,YAAY,OAAO,QAAQ,aAAa,WAAY,KAAI,QAAQ,SAAS,YAAY,QAAQ,KAAK,IAAI;AAAA,MACxH,UAAS,IAAI,WAAW,SAAS,GAAG,KAAK,GAAG,IAAK,KAAI,IAAI,WAAW,CAAC,EAAG,MAAK,IAAI,IAAI,EAAE,CAAC,IAAI,IAAI,IAAI,EAAE,QAAQ,KAAK,CAAC,IAAI,EAAE,QAAQ,GAAG,MAAM;AAChJ,SAAO,IAAI,KAAK,KAAK,OAAO,eAAe,QAAQ,KAAK,CAAC,GAAG;AAChE;AAEA,IAAI,gBAAgB,MAAMC,uBAAsB,SAAS;AAAA,EACrD,OAAO,aAAa;AAChB,UAAM,eAAe,KAAK,cAAc,qBAAqB;AAC7D,SAAK,YAAY,cAAc,WAAW;AAAA,EAC9C;AAAA,EACA,YAAY,cAAc,aAAa;AACnC,UAAM,iBAAiB,CAAC,SAAS,sBAAsB;AAEnD,UAAI,QAAQ,YAAY,GAAG;AAEvB,YAAI,gBAAgB,CAAC,mBAAmB;AACpC,kBAAQ,sBAAsB,QAAQ,mBAAmB,OAAO,eAAa;AAGzE,kBAAM,sBAAsB,UAAU,uBAAuB,UAAU,oBAAoB,SAAS;AAGpG,kBAAM,wBAAwB,UAAU,QACjC,KAAK,cAAc,kBAAkB,EAAE,SAAS,UAAU,CAAC;AAElE,mBAAO,uBAAuB;AAAA,UAClC,CAAC;AAAA,QACL,OACK;AAED,kBAAQ,sBAAsB,QAAQ;AAAA,QAC1C;AAAA,MACJ,OACK;AACD,gBAAQ,sBAAsB,QAAQ;AAAA,MAC1C;AACA,UAAI,QAAQ,SAAS;AACjB,gBAAQ,QAAQ,sBAAsB,QAAQ;AAAA,MAClD;AAAA,IACJ;AACA,QAAI,KAAK,uBAAuB,GAAG;AAC/B,YAAM,2BAA2B,CAAC,SAAS,yBAAyB;AAGhE,YAAI,QAAQ,oBAAoB;AAC5B,mBAAS,IAAI,GAAG,IAAI,QAAQ,mBAAmB,QAAQ,KAAK;AACxD,kBAAM,YAAY,QAAQ,mBAAmB,CAAC;AAE9C,kBAAM,gBAAgB,wBACf,KAAK,cAAc,kBAAkB,EAAE,SAAS,UAAU,CAAC;AAClE,gBAAI,UAAU,oBAAoB;AAC9B,uCAAyB,QAAQ,mBAAmB,CAAC,GAAG,aAAa;AAAA,YACzE,OACK;AACD,6BAAe,WAAW,aAAa;AAAA,YAC3C;AAAA,UACJ;AAAA,QACJ;AACA,uBAAe,SAAS,oBAAoB;AAAA,MAChD;AACA,YAAM,yBAAyB,CAAC,YAAY,yBAAyB,SAAS,KAAK;AACnF,kBAAY,oBAAoB,sBAAsB;AAAA,IAC1D,OACK;AACD,YAAM,wBAAwB,CAAC,YAAY,eAAe,SAAS,KAAK;AACxE,kBAAY,6BAA6B,uBAAuB,IAAI;AAAA,IACxE;AAAA,EACJ;AAAA,EACA,yBAAyB;AACrB,WAAO,KAAK,mBAAmB,GAAG,UAAU,KAAK,CAAC,KAAK,mBAAmB,GAAG,sCAAsC;AAAA,EACvH;AACJ;AACAD,YAAW;AAAA,EACP,UAAU,eAAe;AAC7B,GAAG,cAAc,WAAW,iBAAiB,MAAM;AACnD,gBAAgBA,YAAW;AAAA,EACvB,KAAK,eAAe;AACxB,GAAG,aAAa;;;AC/EhB,IAAIE,cAA0C,SAAU,YAAY,QAAQ,KAAK,MAAM;AACnF,MAAI,IAAI,UAAU,QAAQ,IAAI,IAAI,IAAI,SAAS,SAAS,OAAO,OAAO,OAAO,yBAAyB,QAAQ,GAAG,IAAI,MAAM;AAC3H,MAAI,OAAO,YAAY,YAAY,OAAO,QAAQ,aAAa,WAAY,KAAI,QAAQ,SAAS,YAAY,QAAQ,KAAK,IAAI;AAAA,MACxH,UAAS,IAAI,WAAW,SAAS,GAAG,KAAK,GAAG,IAAK,KAAI,IAAI,WAAW,CAAC,EAAG,MAAK,IAAI,IAAI,EAAE,CAAC,IAAI,IAAI,IAAI,EAAE,QAAQ,KAAK,CAAC,IAAI,EAAE,QAAQ,GAAG,MAAM;AAChJ,SAAO,IAAI,KAAK,KAAK,OAAO,eAAe,QAAQ,KAAK,CAAC,GAAG;AAChE;AAEA,IAAI,mBAAmB,MAAMC,0BAAyB,SAAS;AAAA,EAC3D,gBAAgB;AACZ,QAAI,KAAK,SAAS,QAAQ,MAAM,cAAc;AAC1C,WAAK,qBAAqB,KAAK;AAAA,IACnC;AAAA,EACJ;AAAA,EACA,WAAW;AACP,UAAM,mBAAmB,KAAK,mBAAmB,OAAO,UAAU;AAGlE,UAAM,uBAAuB,KAAK,mBAAmB,GAAG,sBAAsB;AAC9E,QAAI,sBAAsB;AACtB,aAAO;AAAA,IACX;AACA,WAAO;AAAA,EACX;AAAA,EACA,WAAW,SAAS;AAChB,UAAM,oBAAoB,KAAK,4BAA4B,OAAO;AAClE,QAAI,CAAC,mBAAmB;AACpB;AAAA,IACJ;AACA,UAAM,CAAC,aAAa,UAAU,IAAI;AAClC,SAAK,mBAAmB,cAAc,aAAa,UAAU;AAAA,EACjE;AAAA;AAAA,EAEA,4BAA4B,SAAS;AACjC,QAAI,EAAE,QAAQ,KAAK,kBAAkB,GAAG;AACpC,cAAQ,MAAM,8DAA8D;AAC5E;AAAA,IACJ;AACA,UAAM,eAAe,KAAK,mBAAmB,YAAY,UAAU;AACnE,QAAI,gBAAgB,MAAM;AACtB,cAAQ,MAAM,oGAAoG;AAClH;AAAA,IACJ;AAEA,UAAM,cAAc;AAAA,MAChB,QAAQ,CAAC;AAAA,MACT,QAAQ,CAAC;AAAA,MACT,KAAK,CAAC;AAAA,IACV;AACA,UAAM,mBAAmB,KAAK,mBAAmB,kBAAkB;AACnE,UAAM,oBAAoB,KAAK,mBAAmB,GAAG,+BAA+B;AACpF,UAAM,WAAW,oBAAoB,SAAY,CAAC;AAClD,QAAI,EAAE,OAAO,OAAO,GAAG;AAKnB,cAAQ,QAAQ,CAAC,MAAM,UAAU;AAC7B,cAAM,KAAK,aAAa,EAAE,MAAM,OAAO,EAAE,CAAC;AAC1C,cAAM,eAAe,iBAAiB,EAAE;AACxC,YAAI,UAAU;AACV,mBAAS,EAAE,IAAI;AAAA,QACnB;AACA,YAAI,cAAc;AACd,gBAAM,iBAAiB,aAAa,SAAS;AAC7C,cAAI,gBAAgB;AAChB,wBAAY,OAAO,KAAK,IAAI;AAAA,UAChC;AAGA,2BAAiB,EAAE,IAAI;AAAA,QAC3B,OACK;AACD,sBAAY,IAAI,KAAK,IAAI;AAAA,QAC7B;AAAA,MACJ,CAAC;AAAA,IACL;AAEA,MAAE,cAAc,kBAAkB,CAAC,IAAI,YAAY;AAC/C,UAAI,SAAS;AACT,oBAAY,OAAO,KAAK,QAAQ,IAAI;AAAA,MACxC;AAAA,IACJ,CAAC;AACD,WAAO,CAAC,aAAa,QAAQ;AAAA,EACjC;AACJ;AACAD,YAAW;AAAA,EACP,UAAU,UAAU;AACxB,GAAG,iBAAiB,WAAW,YAAY,MAAM;AACjDA,YAAW;AAAA,EACP,UAAU,aAAa;AAC3B,GAAG,iBAAiB,WAAW,eAAe,MAAM;AACpDA,YAAW;AAAA,EACP;AACJ,GAAG,iBAAiB,WAAW,iBAAiB,IAAI;AACpD,mBAAmBA,YAAW;AAAA,EAC1B,KAAK,kBAAkB;AAC3B,GAAG,gBAAgB;;;AC/FZ,IAAM,UAAU;;;ACQhB,IAAM,2BAA2B;AAAA,EACpC,SAAS;AAAA,EACT,YAAY,YAAY;AAAA,EACxB,UAAU;AAAA,EACV,OAAO,CAAC,oBAAoB,aAAa,WAAW,cAAc,aAAa,eAAe,gBAAgB;AAClH;",
  "names": ["RecursionType", "ClientSideRowModel", "__decorate", "FilterStage", "__decorate", "SortStage", "__decorate", "FlattenStage", "__decorate", "SortService", "rowNode", "__decorate", "FilterService", "__decorate", "ImmutableService"]
}
